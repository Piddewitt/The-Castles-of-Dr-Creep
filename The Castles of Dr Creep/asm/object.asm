; --------------------------------------------------------------------------------------------------------------------- ;
; Castles of Dr Creep - object.prg
; --------------------------------------------------------------------------------------------------------------------- ;
; Memory Map
; --------------------------------------------------------------------------------------------------------------------- ;
; $0000 - $00ff:  Zero Page BASIC ($02) and KERNAL ($90)
; $0100 - $01ff:  6510 hardware stack
; $0200 - $03ff:  Working storage
; $0400 - $07e8:  Video Screen 1  - Displays Game Options and Castle Load File Names
;
; $0800 - $77ff:  Game Code - Initial load up to 7919
;
; $7800 - $97ff:  Game Level Data (modified during game) or Demo Music
; $9800 - $b7ff:  Game Store Data (unmodified)
; $b800 - $b8ff:  Castle Escape Times for a ONE and a TWO players game
;
; $b900 - $b9ff:  <not used>
; 
; $ba00 - $baff:  Work Area Game Options and Castle Load Screen selection row
; $bb00 - $bbff:  Pointer HiRes Screen Rows: High
; $bc00 - $bcff:  Pointer HiRes Screen Rows: Low
; $bd00 - $bdff:  Work Area Sprite           - $08 Blocks of $20 Bytes
; $be00 - $beff:  Work Area Item Status      - $20 Blocks of $08 Bytes
; $bf00 - $bfff:  Work Area Item Description - $20 Blocks of $08 Bytes
; 
; $c000 - $c7ff:  Room Move Control Memory - Floors / Ladders / Poles
; $c800 - $c9ff:  Sprite Data Buffer 1
; $ca00 - $cbff:  Sprite Data Buffer 2
; $cc00 - $cfe8:  Video Screen 2 - Holds Color Values for Multicolour HiRes Screen
; $cff8 - $cfff:  Sprite Data Pointers
; $e000 - $fff9:  Multicolour HiRes Screen
; 
; $fffa - $fffb:  Vector: NMI
; $fffc - $fffd:  Vector: <not set> System Reset
; $fffe - $ffff:  Vector: IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
                            * = $0800
; --------------------------------------------------------------------------------------------------------------------- ;
; compiler settings
; --------------------------------------------------------------------------------------------------------------------- ;
                            .cpu "6502"                     ; standard 65xx processor
                            
Mem                         .include "../../inc/c64.MEM.asm"  ; Memory layout (includes found via -I cmd line option)
Dir                         .include "../../inc/1541.dir.asm" ; 1541 directory layout
; --------------------------------------------------------------------------------------------------------------------- ;
Var                         .include "../inc/CC_Var.asm"    ; Variables
ZPG                         .include "../inc/CC_Zpg.asm"    ; Zero Page
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStart                 Does    : start the game - called from creepload
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
                           .block                           ; 
GameStart                   jmp GameColdStart               ; where it all starts
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemDrawRoutineAdr        Does    : room item draw routines dispatch table 
;                           Expects : 
;                           Returns : 
;                           Remark  : dispatched by soubroutine CastleRoomDrawHandler
; --------------------------------------------------------------------------------------------------------------------- ;
ItemDrawRoutineAdr         .block                           ; 
ItemAdr_03_08               jmp DrawDoor_Bad                ; 
ItemAdr_03_08_Hi            = * - $01                       ; corrected to DrawDoor  in subroutine: CopyProtection
ItemAdr_06_08               jmp DrawFloor_Bad               ; 
ItemAdr_06_08_Hi            = * - $01                       ; corrected to DrawFloor in subroutine: CopyProtection
ItemAdr_09_08               jmp DrawPole_Bad                ; 
ItemAdr_09_08_Hi            = * - $01                       ; corrected to DrawPole  in subroutine: CopyProtection
ItemAdr_08_08               jmp DrawLadder                  ; 
ItemAdr_0f_08               jmp DrawBell_Bad                ; 
ItemAdr_0f_08_Hi            = * - $01                       ; corrected to DrawBell  in subroutine: CopyProtection
ItemAdr_12_08               jmp DrawLightningMachine        ; 
ItemAdr_15_08               jmp DrawForceField              ; 
ItemAdr_18_08               jmp DrawMummy                   ; 
ItemAdr_1b_08               jmp DrawKey                     ; 
ItemAdr_1e_08               jmp DrawLock                    ; 
ItemAdr_21_08               jmp DrawRoomGraphic             ; 
ItemAdr_24_08               jmp DrawRayGun                  ; 
ItemAdr_27_08               jmp DrawMatterXmitter           ; 
ItemAdr_2a_08               jmp DrawTrapDoor                ; 
ItemAdr_2d_08               jmp DrawMovingSideWalk          ; 
ItemAdr_30_08               jmp DrawFrankenstein            ; 
ItemAdr_33_08               jmp DrawText                    ; 
                            
ItemAdr_36_08               jmp DrawExitGraphic             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagMusicDataCopy        = *       ; 
TabFlagMusicDataCopy_No     = $00     ; 
TabFlagMusicDataCopy_Yes    = $01     ; 
                            .byte TabFlagMusicDataCopy_No ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlags_NotUsed            .byte $80 ; 
                            .byte $40 ; 
                            .byte $20 ; 
                            .byte $10 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabItem_WA_UseCount         .byte $00 ; 
TabItem_WA_UseCount_Max         = $20 ; 

TabItem_WA_Flag_Init        .byte $80 ; Flag: item initialized but inactive
TabItem_WA_Flag_Ready       .byte $40 ; Flag: item ready to be dispatched in RoomItemHandler
TabItem_WA_Flag_Gone        .byte $20 ; Flag: item not available anymore
; --------------------------------------------------------------------------------------------------------------------- ;
; Item action handler block layout for the $10 different item types
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn                 = *                              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; two action routine address words for each of the $10 possible items - $0000 = routine not available
; --------------------------------------------------------------------------------------------------------------------- ;
TabMoveHandler_Item         = * + $00 ; dispatched by RoomItemHandler - move each object automatically
TabMoveHandler_Player       = * + $02 ; dispatched by RoomPlayerMoveHandler - move each object after a player action
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_Door            = *                              ; Item Type $00: Door
                            .word ItemDoorOpen               ; open a door
                            .word PlayerRoomLeave            ; exit a player through an open castle room door
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_DoorBell        = *                              ; Item Type $01: Door Bell
                            .word $0000                      ; 
                            .word PlayerDoorBellRing         ; a player rings a door bell to open a door
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_LightOrb        = *                              ; Item Type $02: Lightning Machine Ball
                            .word ItemLightPole              ; handle the lightning machine pole movement
                            .word $0000                      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_LightSwitch     = *                              ; Item Type $03: Lightning Machine Switch
                            .word $0000                      ; 
                            .word PlayerLightSwitch          ; a player switches a lighning machine orb on/off
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_ForceField      = *                              ; Item Type $04: Force Field
                            .word ItemForceFieldClose        ; handle the closing of a force field
                            .word PlayerForceFieldSwitch     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_Mummy           = *                              ; Item Type $05: Mummy
                            .word ItemMummyAnkhFlash         ; handle the mummy ankh flashing
                            .word PlayerMummyAnkhTouch       ; a player touches a mummy ankh
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_Key             = *                              ; Item Type $06: Key
                            .word $0000                      ; 
                            .word PlayerKeyPick              ; a player picks up a key
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_Lock            = *                              ; Item Type $07: Lock
                            .word $0000                      ; 
                            .word PlayerDoorUnLock           ; a player unlocks a door with the appropriate key
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_RayGun          = *                              ; Item Type $08: Ray Gun
                            .word RayGunAimLaserHead         ; aim the ray gun laser head
                            .word $0000                      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_RayGunCtrl      = *                              ; Item Type $09: Ray Gun Switch
                            .word $0000                      ; 
                            .word PlayerRayGunMove           ; a player manually moves a ray gun laser head up or down
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_Xmitter         = *                              ; Item Type $0a: Matter Transmitter Receiver Oval
                            .word ItemXmitTargetFlash        ; handle the xmit booth and target flashing
                            .word PlayerMatterTargetSelect   ; a player selects an xmit taget dot
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_TrapDoor        = *                              ; Item Type $0b: Trap Door
                            .word ItemTrapDoorMove           ; open or close a trap door
                            .word $0000                      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_TrapDoorSwitch  = *                              ; Item Type $0c: Trap Door Switch
                            .word $0000                      ; 
                            .word $0000                      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_SideWalk        = *                              ; Item Type $0d: Side Walk
                            .word ItemSideWalkMove           ; handle the side walk moving
                            .word PlayerSideWalkPace         ; a sprite is accelerated/pushed back by the walk move dir
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_WalkSwitch      = *                              ; Item Type $0e: Side Walk Switch
                            .word $0000                      ; 
                            .word PlayerSideWalkSwitch       ; a player controls a side walk move dir
; --------------------------------------------------------------------------------------------------------------------- ;
TabItemActn_Frank           = *                              ; Item Type $0f: Frankenstein
                            .word $0000                      ; 
                            .word $0000                      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagSprt_WA_Init         .byte %10000000 ; $80 - Flag: sprite work area initialized and ready to use
TabFlagSprt_Dead            .byte %01000000 ; $40 - Flag: sprite is dead
TabFlagSprt_Dies            .byte %00100000 ; $20 - Flag: sprite active death animation
TabFlagSprt_Moves           .byte %00010000 ; $10 - Flag: sprite to be moved    in RoomSpriteHandler
TabFlagSprt_Disable         .byte %00001000 ; $08 - Flag: sprite to be disabled in RoomSpriteHandler
TabFlagSprt_Coll_Back       .byte %00000100 ; $04 - Flag: sprite collided with background
TabFlagSprt_Coll_Sprt       .byte %00000010 ; $02 - Flag: sprite collided with sprite
TabFlagSprt_WA_Free         .byte %00000001 ; $01 - Flag: sprite work area free again
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagSprt_XXPAND          .byte $80 ; #....... Flag: sprite horizontal expansion
TabFlagSprt_YXPAND          .byte $40 ; .#...... Flag: sprite vertical expansion
TabFlagSprt_SPBGPR          .byte $20 ; ..#..... Flag: sprite background display priority
TabFlagSprt_SPMC            .byte $10 ; ...#.... Flag: sprite multicolor
                            
TabFlagSprt_Mortal          .byte $01 ; .......# Flag: sprite mortality
; --------------------------------------------------------------------------------------------------------------------- ;
; Sprite action handler block layout for the $06 different sprite types
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn                 = *       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; part 1: three action routine addresses for each of the $06 different spritea - $0000 = routine not available
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn_Move_Sprt       = * + $00 ; Sprite moves around           - dispatched by RoomSpriteHandler
TabSprtActn_Coll_Sprt       = * + $02 ; Sprite collided with a sprite - dispatched by RoomSpriteKillHandler
TabSprtActn_Coll_Item       = * + $04 ; Sprite collided with an item  - dispatched by RoomPlayerMoveHandler
; --------------------------------------------------------------------------------------------------------------------- ;
; part 2: two action flag bytes - killing prio and mortality
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn_KillPrio        = * + $06 ; sprite-sprite killing prio
TabSprtActn_KillPrio_Player   = %00000000 ; $00  low  - will be killed by all others
TabSprtActn_KillPrio_Frank    = %00000000 ; $00  !    
TabSprtActn_KillPrio_Mummy    = %00000010 ; $02  !    
TabSprtActn_KillPrio_Force    = %00000011 ; $03  !    
TabSprtActn_KillPrio_Light    = %00000100 ; $04  !    
TabSprtActn_KillPrio_Beam     = %00000100 ; $04  high - kills all others
                            
TabSprtActn_Mortal          = * + $07 ; sprite mortality
TabSprtActn_Mortal_Yes        = $01   ; 
TabSprtActn_Mortal_No         = $00   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn_Player          = *                              ;       Sprite Type $00 - Player
                            .word PlayerSpriteMove           ;       Get player into a room and control his moves
                            .word PlayerSpriteCollide        ;       Player collides with another sprite
                            .word PlayerTrapTouch            ;       Player possibly touches a trap door or switch
                            .byte TabSprtActn_KillPrio_Player; Flag: Killing priority: killed by all other sprites
                            .byte TabSprtActn_Mortal_Yes     ; Flag: Mortal: Player/Mummy/Frankenstein
                            
TabSprtActn_Len             = * - TabSprtActn_Player         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn_Spark           = *                              ;       Sprite Type $01 - Lightning Machine
                            .word LightSparkSpriteMove       ;       get next lightning machine random spark sprite
                            .word LightSparkSpriteCollide    ;       set flag lightning machine spark is still active
                            .word $0000                      ; 
                            .byte TabSprtActn_KillPrio_Light ; Flag: Killing priority: kills all except beam
                            .byte TabSprtActn_Mortal_No      ; Flag: Immortal: Light/Force/Gun
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn_ForceField      = *                              ;       Sprite Type $02 - Force Field
                            .word ForceSpriteMove            ;       Force Field moves
                            .word ForceSpriteCollide         ;       set flag force field sprite is still active
                            .word $0000                      ; 
                            .byte TabSprtActn_KillPrio_Force ; Flag: Killing priority: kills Player/Mummy/Farankenstein
                            .byte TabSprtActn_Mortal_No      ; Flag: Immortal: Light/Force/Gun
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn_Mummy           = *                              ;       Sprite Type $03 - Mummy
                            .word MummySpriteMove            ;       Get mummy out of his tomb or let him follow preferably player #1
                            .word MummySpriteCollide         ;       Mummy collides with another sprite
                            .word MummyTrapTouch             ;       Mummy possibly touches a trap door or switch
                            .byte TabSprtActn_KillPrio_Mummy ; Flag: Killing priority: kills a player sprite
                            .byte TabSprtActn_Mortal_Yes     ; Flag: Mortal: Player/Mummy/Frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn_GunBeam         = *                              ;       Sprite Type $04 - Ray Gun Beam
                            .word RayGunBeamSpriteMove       ;       Beam moves
                            .word $0000                      ;       
                            .word RayGunBeamItemCollide      ;       Beam collides with a room item
                            .byte TabSprtActn_KillPrio_Beam  ; Flag: Killing priority: kills all sprites except light
                            .byte TabSprtActn_Mortal_No      ; Flag: Immortal: Light/Force/Gun
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprtActn_Frank           = *                              ;       Sprite Type $05 - Frank N Forter
                            .word FrankSpriteMove            ;       Frank moves
                            .word FrankSpriteCollide         ;       Frank collides with another sprite
                            .word FrankTrapTouch             ;       Frank possibly touches a trap door or switch
                            .byte TabSprtActn_KillPrio_Frank ; Flag: Killing priority: kills player sprite
                            .byte TabSprtActn_Mortal_Yes     ; Flag: Mortal: Player/Mummy/Frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $80   ; Flag: EndOfJumpTab / TabValues
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagRoom_Visited         .byte $80   ; Flag: Room was visited and will be drawn on the castle map
TabFlagRoom_EndOfList       .byte $40   ; Flag: End of Room data definition list entries
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameColdStart             Does    : prepare start of game
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameColdStart              .block                           ; 
                            lda #<$e000 - $07 * $140        ; init hires row address pointer to $e000-$08c0 = $d740
                            sta CCZ_HiResScreenRowAdr_Lo    ; 
                            
                            lda #>$e000 - $07 * $140        ; 
                            sta CCZ_HiResScreenRowAdr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; bit-mapped memory
; --------------------------------------------------------------------------------------------------------------------- ;
; $19 blocks ($00-$18)
;   each block contains $140 (320) bytes and controls $08 horizontal pixel rows
;   every 8th Y-value starts a new block of $140 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
;   byte number of the 1st byte in any block (X=pixel col number/Y=pixel row number)
;     $140*(INT(Y/8))
;   byte number contaning the requested hires bit
;     $140*(INT(Y/8)) + (Y AND 7) + 8*(INT(X/8)) 
; --------+---------------+---------------+---------------+-----+---------------+---------------+---------------------- ;
;         ! col $000-$007 ! col $008-$007 ! col $010-$017 !     ! col $130-$137 ! col $138-$13f !  
; --------+---------------+---------------+---------------+-----+---------------+---------------+---------------------- ;
; row $00 !  byte $0000   !  byte $0008   !  byte $0010   ! ... !  byte $0130   !  byte $0138   !  
; ... ... !       ....    !       .....   !       .....   ! ... !       .....   !       .....   !  Block $00
; row $07 !  byte $0007   !  byte $000f   !  byte $0017   ! ... !  byte $0137   !  byte $013f   !  
; --------+---------------+---------------+---------------+-----+---------------+---------------+---------------------- ;
; row $08 !  byte $0140   !  byte $0148   !  byte $150    ! ... !  byte $0282   !  byte $0278   !  
; ... ... !       ....    !       .....   !       ....    ! ... !       .....   !       .....   !  Block $01
; row $0f !  byte $0147   !  byte $014f   !  byte $157    ! ... !  byte $0277   !  byte $027f   !  
; --------+---------------+---------------+---------------+-----+---------------+---------------+---------------------- ;
; ... ... !       ....    !       .....   !       ....    ! ... !       .....   !       .....   !  
; --------+---------------+---------------+---------------+-----+---------------+---------------+---------------------- ;
; row $c0 !  byte $1e00   !  byte $1e08   !  byte $e10    ! ... !  byte $1f30   !  byte $1f38   !  
;     ... !       ....    !       .....   !       ....    ! ... !       .....   !       .....   !  Block $18
; row $c7 !  byte $1e07   !  byte $1e0f   !  byte $e17    ! ... !  byte $1f37   !  byte $1f3f   !  
; --------+---------------+---------------+---------------+-----+---------------+---------------+---------------------- ;

; --------------------------------------------------------------------------------------------------------------------- ;
; table: HI byte start addresses of $19 blocks of $08 stacked pixel rows ($c8)
; --------------------------------------------------------------------------------------------------------------------- ;
; $bb00: block $00 - $e0 $e0 $e0 $e0 $e0 $e0 $e0 $e0 - $08 pixel rows $00-07 ; 
; $bb08: block $01 - $e1 $e1 $e1 $e1 $e1 $e1 $e1 $e1 - $08 pixel rows $08-0f ; 
; $bb10: block $02 - $e2 $e2 $e2 $e2 $e2 $e2 $e2 $e2 - $08 pixel rows $10-17 ; 
; $bb18: block $03 - $e3 $e3 $e3 $e3 $e3 $e3 $e3 $e3 - $08 pixel rows $18-1f ; 
; $bb20: block $04 - $e5 $e5 $e5 $e5 $e5 $e5 $e5 $e5 - $08 pixel rows $20-27 ; 
; $bb28: block $05 - $e6 $e6 $e6 $e6 $e6 $e6 $e6 $e6 - $08 pixel rows $28-2f ; 
; $bb30: block $06 - $e7 $e7 $e7 $e7 $e7 $e7 $e7 $e7 - $08 pixel rows $30-37 ; 
; $bb38: block $07 - $e8 $e8 $e8 $e8 $e8 $e8 $e8 $e8 - $08 pixel rows $38-3f ; 
; $bb40: block $08 - $ea $ea $ea $ea $ea $ea $ea $ea - $08 pixel rows $40-47 ; 
; $bb48: block $09 - $eb $eb $eb $eb $eb $eb $eb $eb - $08 pixel rows $48-4f ; 
; $bb50: block $0a - $ec $ec $ec $ec $ec $ec $ec $ec - $08 pixel rows $50-57 ; 
; $bb58: block $0b - $ed $ed $ed $ed $ed $ed $ed $ed - $08 pixel rows $58-5f ; 
; $bb60: block $0c - $ef $ef $ef $ef $ef $ef $ef $ef - $08 pixel rows $60-67 ; 
; $bb68: block $0d - $f0 $f0 $f0 $f0 $f0 $f0 $f0 $f0 - $08 pixel rows $68-6f ; 
; $bb70: block $0e - $f1 $f1 $f1 $f1 $f1 $f1 $f1 $f1 - $08 pixel rows $70-77 ; 
; $bb78: block $0f - $f2 $f2 $f2 $f2 $f2 $f2 $f2 $f2 - $08 pixel rows $78-7f ; 
; $bb80: block $10 - $f4 $f4 $f4 $f4 $f4 $f4 $f4 $f4 - $08 pixel rows $80-87 ; 
; $bb88: block $11 - $f5 $f5 $f5 $f5 $f5 $f5 $f5 $f5 - $08 pixel rows $88-8f ; 
; $bb90: block $12 - $f6 $f6 $f6 $f6 $f6 $f6 $f6 $f6 - $08 pixel rows $90-97 ; 
; $bb98: block $13 - $f7 $f7 $f7 $f7 $f7 $f7 $f7 $f7 - $08 pixel rows $98-9f ; 
; $bba0: block $14 - $f9 $f9 $f9 $f9 $f9 $f9 $f9 $f9 - $08 pixel rows $a0-a7 ; 
; $bba8: block $15 - $fa $fa $fa $fa $fa $fa $fa $fa - $08 pixel rows $a8-af ; 
; $bbb0: block $16 - $fb $fb $fb $fb $fb $fb $fb $fb - $08 pixel rows $b0-b7 ; 
; $bbb8: block $17 - $fc $fc $fc $fc $fc $fc $fc $fc - $08 pixel rows $b8-bf ; 
; $bbc0: block $18 - $fe $fe $fe $fe $fe $fe $fe $fe - $08 pixel rows $c0-c7 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; unused - not in bitmap
; --------------------------------------------------------------------------------------------------------------------- ;
; $bbc8: block $19 - $d7 $d7 $d7 $d7 $d7 $d7 $d7 $d7 - $08 pixel rows $c8-cf ; 
; $bbd0: block $1a - $d8 $d8 $d8 $d8 $d8 $d8 $d8 $d8 - $08 pixel rows $d0-d7 ; 
; $bbd8: block $1b - $d9 $d9 $d9 $d9 $d9 $d9 $d9 $d9 - $08 pixel rows $d8-df ; 
; $bbe0: block $1c - $db $db $db $db $db $db $db $db - $08 pixel rows $e0-e7 ; 
; $bbe8: block $1d - $dc $dc $dc $dc $dc $dc $dc $dc - $08 pixel rows $e8-ef ; 
; $bbf0: block $1e - $dd $dd $dd $dd $dd $dd $dd $dd - $08 pixel rows $f0-f7 ; 
; $bbf8: block $1f - $de $de $de $de $de $de $de $de - $08 pixel rows $f8-ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; table: LO byte start addresses of $19 blocks of $08 stacked pixel rows ($c8)
; --------------------------------------------------------------------------------------------------------------------- ;
; $bc00: block $00 - $00 $01 $02 $03 $04 $05 $06 $07 ; $08 pixel rows $00-07 ; 
; $bc08: block $01 - $40 $41 $42 $43 $44 $45 $46 $47 ; $08 pixel rows $08-0f ; 
; $bc10: block $02 - $80 $81 $82 $83 $84 $85 $86 $87 ; $08 pixel rows $10-17 ; 
; $bc18: block $03 - $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7 ; $08 pixel rows $18-1f ; 
; $bc20: block $04 - $00 $01 $02 $03 $04 $05 $06 $07 ; $08 pixel rows $20-27 ; 
; $bc28: block $05 - $40 $41 $42 $43 $44 $45 $46 $47 ; $08 pixel rows $28-2f ; 
; $bc30: block $06 - $80 $81 $82 $83 $84 $85 $86 $87 ; $08 pixel rows $30-37 ; 
; $bc38: block $07 - $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7 ; $08 pixel rows $38-3f ; 
; $bc40: block $08 - $00 $01 $02 $03 $04 $05 $06 $07 ; $08 pixel rows $40-47 ; 
; $bc48: block $09 - $40 $41 $42 $43 $44 $45 $46 $47 ; $08 pixel rows $48-4f ; 
; $bc50: block $0a - $80 $81 $82 $83 $84 $85 $86 $87 ; $08 pixel rows $50-57 ; 
; $bc58: block $0b - $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7 ; $08 pixel rows $58-5f ; 
; $bc60: block $0c - $00 $01 $02 $03 $04 $05 $06 $07 ; $08 pixel rows $60-67 ; 
; $bc68: block $0d - $40 $41 $42 $43 $44 $45 $46 $47 ; $08 pixel rows $68-6f ; 
; $bc70: block $0e - $80 $81 $82 $83 $84 $85 $86 $87 ; $08 pixel rows $70-77 ; 
; $bc78: block $0f - $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7 ; $08 pixel rows $78-7f ; 
; $bc80: block $10 - $00 $01 $02 $03 $04 $05 $06 $07 ; $08 pixel rows $80-87 ; 
; $bc88: block $11 - $40 $41 $42 $43 $44 $45 $46 $47 ; $08 pixel rows $88-8f ; 
; $bc90: block $12 - $80 $81 $82 $83 $84 $85 $86 $87 ; $08 pixel rows $90-97 ; 
; $bc98: block $13 - $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7 ; $08 pixel rows $98-9f ; 
; $bca0: block $14 - $00 $01 $02 $03 $04 $05 $06 $07 ; $08 pixel rows $a0-a7 ; 
; $bca8: block $15 - $40 $41 $42 $43 $44 $45 $46 $47 ; $08 pixel rows $a8-af ; 
; $bcb0: block $16 - $80 $81 $82 $83 $84 $85 $86 $87 ; $08 pixel rows $b0-b7 ; 
; $bcb8: block $17 - $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7 ; $08 pixel rows $b8-bf ; 
; $bcc0: block $18 - $00 $01 $02 $03 $04 $05 $06 $07 ; $08 pixel rows $c0-c7 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; unused - not in bitmap
; --------------------------------------------------------------------------------------------------------------------- ;
; $bcc8: block $19 - $40 $41 $42 $43 $44 $45 $46 $47 ; $08 pixel rows $c8-cf ; 
; $bcd0: block $1a - $80 $81 $82 $83 $84 $85 $86 $87 ; $08 pixel rows $d0-d7 ; 
; $bcd8: block $1b - $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7 ; $08 pixel rows $d8-df ; 
; $bce0: block $1c - $00 $01 $02 $03 $04 $05 $06 $07 ; $08 pixel rows $e0-e7 ; 
; $bce8: block $1d - $40 $41 $42 $43 $44 $45 $46 $47 ; $08 pixel rows $e8-ef ; 
; $bcf0: block $1e - $80 $81 $82 $83 $84 $85 $86 $87 ; $08 pixel rows $f0-f7 ; 
; $bcf8: block $1f - $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7 ; $08 pixel rows $f8-ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$c8                        ; start with max hires pixel rows (block $19)
GetNextHiresRowByte_Lo      lda CCZ_HiResScreenRowAdr_Lo    ; 
                            sta CC_ScreenGfxRowPtr_Lo,x     ; 
                            
                            lda CCZ_HiResScreenRowAdr_Hi    ; 
                            sta CC_ScreenGfxRowPtr_Hi,x     ; 
                            
                            inx                             ; 
                            cpx #$c8                        ; test max hires pixel rows
                            beq IniScreenRowAddressTable    ; check: EQ - yes: done
                            
                            txa                             ; 
                            and #$07                        ; .....### - isolate counter
                            beq AddAmountNextRow            ; check: max $08 steps reached - yes: set new hires line
; --------------------------------------------------------------------------------------------------------------------- ;
; inc page address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_HiResScreenRowAdr_Lo    ; 
                            bne GetNextHiresRowByte_Lo      ; check: overflow - no
                            inc CCZ_HiResScreenRowAdr_Hi    ; 
                            
                            jmp GetNextHiresRowByte_Lo      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance hires row address pointer to next row
; --------------------------------------------------------------------------------------------------------------------- ;
AddAmountNextRow            clc                             ; 
                            lda CCZ_HiResScreenRowAdr_Lo    ; 
                            adc #<$140 - $07                ; add $140 (320) - sub 7 --> 8 rows are counted already in the inner loop
                            sta CCZ_HiResScreenRowAdr_Lo    ; set work graphic row start address LO
                            
                            lda CCZ_HiResScreenRowAdr_Hi    ; 
                            adc #>$140 - $07                ; 
                            sta CCZ_HiResScreenRowAdr_Hi    ; 
                            
                            jmp GetNextHiresRowByte_Lo      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; fill the game menu screen row address table
; --------------------------------------------------------------------------------------------------------------------- ;
IniScreenRowAddressTable    lda #$00                        ; 
                            sta CCZ_TextScreenRowAdr_Lo     ; 
                            sta CCZ_TextScreenRowAdr_Hi     ; init game menu row address pointer
                            
                            ldx #$00                        ; init table offset
GetNextScreenRowAdr         lda CCZ_TextScreenRowAdr_Lo     ; 
                            sta TabTextScreenRowAdr_Lo,x    ; set game menu screen row address Lo
                            
                            lda CCZ_TextScreenRowAdr_Hi     ; 
                            sta TabTextScreenRowAdr_Hi,x    ; set game menu screen row address Hi
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the game menu screen row address table ponter to next row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_TextScreenRowAdr_Lo     ; 
                            adc #VICSCN_LLEN                ; add single line = $28 (40) columns
                            sta CCZ_TextScreenRowAdr_Lo     ; 
                            bcc IncScreenRowAdrTableOff     ; check: overflow - no
                            inc CCZ_TextScreenRowAdr_Hi     ; 
                            
IncScreenRowAdrTableOff     inx                             ; inc table offset
                            cpx #TabTextScreenRowAdr_Len    ; test max entries reached
                            bcc GetNextScreenRowAdr         ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; copy protection: read of track 35 sector 09 must give a "27, READ ERROR,tt,ss" (Header block checksum error)
;                  the "27" is used to correct the four bad Room_ Item Jump Table entries
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr CopyProtection              ; read tt=35 ss=09 for a "27, READ ERROR" and correct room item jump table
; --------------------------------------------------------------------------------------------------------------------- ;
; Subroutine GameMenuScreenInit becomes obsolete as it is executed only once
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameMenuScreenInit          ; init the game menu screen
                            
                            lda TabFlagMusicDataCopy        ; 
                            cmp #TabFlagMusicDataCopy_Yes   ; test flag copy music data
                            beq CopyMusicData               ; check: EQ - yes: bypass game data copy
; --------------------------------------------------------------------------------------------------------------------- ;
; overwrite GameMenuScreenInit with Sound Effect data - frees memory for CC_GameDataBuf
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<GameMenuScreenInit        ; 
                            sta CCZ_CopyDataTargetPtr_Lo    ; 
                            lda #>GameMenuScreenInit        ; 
                            sta CCZ_CopyDataTargetPtr_Hi    ; init target address pointer
                            
                            lda #<TabGameSfxData            ; 
                            sta CCZ_CopyDataSourcePtr_Lo    ; 
                            lda #>TabGameSfxData            ; 
                            sta CCZ_CopyDataSourcePtr_Hi    ; init source address pointer
                            
                            ldy #$00                        ; 
GetNextCopyDataByte         lda (CCZ_CopyDataSourcePtr),y   ; 
                            sta (CCZ_CopyDataTargetPtr),y   ; 
                            
                            iny                             ; inc page offset
                            bne GetNextCopyDataByte         ; check: max - no: continue
                            
                            inc CCZ_CopyDataTargetPtr_Hi    ; 
                            inc CCZ_CopyDataSourcePtr_Hi    ; set next address pages
                            
                            lda CCZ_CopyDataTargetPtr_Hi    ; 
                            cmp #>CC_GameDataBuf            ; test max - CC_GameDataBuf Hi address reached
                            bcc GetNextCopyDataByte         ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; get 1st castle data work area offset for castle data file load
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #CC_WA_GameMenu_Len * $04   ; get offset 5th game menu work area - normally TUTORIAL
                            jsr CastleDataMenuDirLoad       ; try to load a cursor selected game menu castle data file
                            jmp GameColdStart_Exit          ; bypass copy 
; --------------------------------------------------------------------------------------------------------------------- ;
CopyMusicData               jsr DemoMusicDataCopy           ; copy demo music data over to level load data buffer
; --------------------------------------------------------------------------------------------------------------------- ;
GameColdStart_Exit          lda #TabFlagColdStart_Done_Yes  ; 
                            sta TabFlagColdStart_Done       ; flag cold start done
                            
                            jmp MainLoop                    ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagColdStart_Done      .byte TabFlagColdStart_Done_No   ; 
TabFlagColdStart_Done_Yes      = $00 ; 
TabFlagColdStart_Done_No       = $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameWarmStart             Does    : set up the machine for game play
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameWarmStart              .block                           ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            
                            nop                             ; 
                            nop                             ; 
                            nop                             ; 
                            
                            sei                             ; disallow interrupts
                            
                            lda #CI2ICR_SC_CLR_ALL          ; .#######
                            sta CI2ICR                      ; CIA2($DD0D) Interrupt Control Register
                            lda CI2ICR                      ; CIA2($DD0D) Interrupt Control Register - Cleared on read
                            
                            lda #D6510_CHAREN_OUT | D6510_HIRAM_OUT | D6510_LORAM_OUT ; 
                            sta D6510                       ; 6510 On-Chip I/O Data Direction
; --------------------------------------------------------------------------------------------------------------------- ;
; switch IO on - KERNAL and BASIC off
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CHAREN_IO_ON & HIRAM_KERNAL_OFF | LORAM_BASIC_ON ; 
                            sta R6510                       ; 6510 On-Chip I/O Data
; --------------------------------------------------------------------------------------------------------------------- ;
; set IRQ/NMI vectors
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<IRQ                       ; 
                            sta SHV_IRQ_LO                  ; Kernal($FFFE) IRQ and Break Sytstem Hardware Vector ($FF48)
                            lda #>IRQ                       ; 
                            sta SHV_IRQ_HI                  ; Kernal($FFFE) IRQ and Break Sytstem Hardware Vector ($FF48)
                            
                            lda #<NMI                       ; 
                            sta SHV_NMI_LO                  ; Kernal($FFFA) NMI System Hardware Vector ($FE43)
                            lda #>NMI                       ; 
                            sta SHV_NMI_HI                  ; Kernal($FFFA) NMI System Hardware Vector  ($FE43)
; --------------------------------------------------------------------------------------------------------------------- ;
; init sprite data pointers
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; init table offset
                            lda #(CC_SpriteDataBuf_1 - CI2PRA_VIC_BASE_3) / SPRT_BLK_LEN ; 
SetNextSpriteDataPtr        sta CCZ_TabSprtDataPtrs,x       ; set sprite data pointer $00-$07 to $20-$27 ($0800-$09c0)
                            
                            inx                             ; inc table offset
                            cpx #CCZ_TabSprtDataPtrs_Len + $01 ; test max 
                            bcs InitMachine                 ; check: GE - yes: done
                            
                            adc #$01                        ; set next sprite data pointer
                            jmp SetNextSpriteDataPtr        ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare the machine
; --------------------------------------------------------------------------------------------------------------------- ;
InitMachine                 lda #SCROLX_MCM_ON | SCROLX_CSEL_40 ; get multicolor bitmap mode / 40 columns
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
                            sta CCZ_VIC_SCROLX              ; set IRQ work register value
                            
                            lda #$00                        ; 
                            sta RASTER                      ; VIC($D012) Read : Current Raster Scan Line (Bit 8 in SCROLY = $D011)
; --------------------------------------------------------------------------------------------------------------------- ;
; VIC memory bank #00: $c000-$ffff  screen base: $cc00-$cfe7  char: $e000-$e7ff
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #VMCSB_VM_0C00              ; screen base address   - $0c00-$0fe7 + VIC base in CI2PRA ($c000-$ffff)
                            and #VMCSB_VM_MASK              ; clear char rom bits
                            ora #VMCSB_CB_2000              ; set char rom location - $2000-$27ff + VIC base in CI2PRA ($c000-$ffff)
                            sta CCZ_VIC_VMCSB               ; set IRQ work register value
                            
                            lda #IRQMASK_ERST               ; Bit0: Enable Raster Compare
                            sta IRQMASK                     ; VIC($D01A) IRQ Mask Register
                            
                            lda #$ff                        ; get clear all value
                            sta VICIRQ                      ; VIC($D019) Interrupt Flags - Latched flags cleared if set to 1
                            
                            lda #BLACK                      ; 
                            sta CCZ_VIC_EXTCOL              ; set IRQ work register value
                            sta TabExitScrnValues_Color     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init color of the players clothes
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LT_RED                     ; get players shirt color
                            sta SPMC0                       ; VIC($D025) Sprite Multicolor Register 0
                            
                            lda #LT_GREEN                   ; get players trouser color
                            sta SPMC1                       ; VIC($D026) Sprite Multicolor Register 1
; --------------------------------------------------------------------------------------------------------------------- ;
; select VIC base memory bank #00: $c000-$ffff
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CI2DDRA_BANK_B0 | CI2DDRA_BANK_B1 ; 
                            sta CI2DDRA                     ; CIA2($DD02) Data Dir A
                            
                            lda #CI2PRA_VIC_BANK_3          ; $00: $c000-$ffff - bank 3
                            sta CI2PRA                      ; CIA2($DD00) Data Port A - Bits 0-1 = VIC mem bank
; --------------------------------------------------------------------------------------------------------------------- ;
; clear timer #1
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta CIACRA                      ; CIA1($DC0E) Control Register A - clear timers
                            sta CI2CRA                      ; CIA2($DD0E) Control Register A - clear timers
                            sta CIACRB                      ; CIA1($DC0F) Control Register B - clear timers
                            sta CI2CRB                      ; CIA2($DD0F) Control Register B - clear timers
; --------------------------------------------------------------------------------------------------------------------- ;
; clear interrupt sources
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CIAICR_SC_CLR_ALL          ; .####### - Clear All Interrupt Sources
                            sta CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            lda CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            
                            cli                             ; reallow interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; switch on sprites only once
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabFlagSprite_Init_No      ; get flag skip not init
                            cmp TabFlagSprite_Init          ; test with actual skip value
                            beq IniGfxAndTimer              ; check: EQ - yes: bypass skip flag set
                            
                            sta TabFlagSprite_Init          ; set flag skip init to no
                            
                            lda #SPENA_ALL_ON               ; 
                            sta CCZ_VIC_SPENA               ; set IRQ work register value
; --------------------------------------------------------------------------------------------------------------------- ;
; wait 2 IRQ cycles
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$02                        ; init IRQ wait counter
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQcounted down to $00 with every IRQ
                            
WaitForCountDownReady       lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne WaitForCountDownReady       ; check: count down ready - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init graphic screen and Timer A
; --------------------------------------------------------------------------------------------------------------------- ;
IniGfxAndTimer              lda #SPENA_ALL_OFF              ; 
                            sta CCZ_VIC_SPENA               ; set IRQ work register value
                            
                            lda #SCROLY_BMM_ON | SCROLY_DEN_ON | SCROLY_RSEL_25 | SCROLY_YSCROLL_INIT_25 ; 
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            
                            lda #$ff                        ; 
                            sta TIMALO                      ; CIA1($DC04) Timer A (low byte)
                            
                            lda TabWrkSidVal_CUTLO_Save     ; 
                            asl a                           ; *2
                            asl a                           ; *4
                            ora #$03                        ; ......##
                            sta TIMAHI                      ; CIA1($DC05) Timer A (high byte)
                            
                            lda #TabWrkItemSfx_Ini          ; 
                            sta TabWrkItemSfx               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; eventually prepare SID for demo music
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda WrkFlagDemoMusicActive      ; get flag demo active  music
                            cmp #WrkFlagDemoMusicActive_Yes ; test with flag demo music is played
                            bne GameWarmStartX              ; check: played - no: bypass SID init
                            
                            ldx #TabWrkSidVal_Len           ; SID ini table offset
GetNextSIDInitValue         lda TabWrkSidVal,x              ; 
                            sta SID,x                       ; SID($D400) Registers
                            
                            dex                             ; dec table offset
                            bpl GetNextSIDInitValue         ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init timer A
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CIAICR_SC_SET | CIAICR_DATA_TA ; get interrupt underflow Timer A
                            sta CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            
                            lda #CIACRA_START               ; get start Timer A
                            sta CIACRA                      ; CIA1($DC0E) Control Register A
; --------------------------------------------------------------------------------------------------------------------- ;
GameWarmStartX              pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagSprite_Init          .byte TabFlagSprite_Init_Yes    ; 
TabFlagSprite_Init_Yes          = $00 ; 
TabFlagSprite_Init_No           = $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoMusicDataCopy         Does    : copy demo music data over to level load data buffer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoMusicDataCopy          .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; init data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set music data source pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_DemoMusicData          ; 
                            sta CCZ_MusicDataSourcePtr_Lo   ; 
                            lda #>CC_DemoMusicData          ; 
                            sta CCZ_MusicDataSourcePtr_Hi   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set music data target pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_LoadDataBuf            ; 
                            sta CCZ_MusicDataTargetPtr_Lo   ; 
                            lda #>CC_LoadDataBuf            ; 
                            sta CCZ_MusicDataTargetPtr_Hi   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init music data counters
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_DemoMusicData_CountLast  ; get number of bytes in last page
                            sta CCZ_LevelDataCountLast      ; 
                            
                            lda CC_DemoMusicData_CountPages ; get music data page count
                            sta CCZ_LevelDataCountPage      ; 
                            beq ChkLastPageByteCount        ; check: full page to copy - no: copy data of last page
; --------------------------------------------------------------------------------------------------------------------- ;
; copy data of whole pages
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextLevelDataSourceByte  lda (CCZ_MusicDataSourcePtr),y  ; 
                            sta (CCZ_MusicDataTargetPtr),y  ; 
                            
                            iny                             ; inc data offset
                            bne GetNextLevelDataSourceByte  ; check: whole page copied - no: continue
                            
                            inc CCZ_MusicDataSourcePtr_Hi   ; inc castle data page pointer
                            inc CCZ_MusicDataTargetPtr_Hi   ; 
                            
                            dec CCZ_LevelDataCountPage      ; dec castle data page count
                            bne GetNextLevelDataSourceByte  ; check: da
; --------------------------------------------------------------------------------------------------------------------- ;
; copy data of last page
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLastPageByteCount        cpy CCZ_LevelDataCountLast      ; test last page byte count
                            beq DemoMusicDataCopyX          ; check: max reached - yes: done
                            
                            lda (CCZ_MusicDataSourcePtr),y  ; 
                            sta (CCZ_MusicDataTargetPtr),y  ; 
                            
                            iny                             ; inc data offset
                            jmp ChkLastPageByteCount        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoMusicDataCopyX          pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ                       Does    : game IRQ handler
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ                        .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            cld                             ; 
                            
                            lda VICIRQ                      ; VIC($D019) Interrupt Flags - Latched flags cleared if set to 1
                            and #VICIRQ_IRST                ; isolate bit0: Raster Compare IRQ
                            bne WasRasterIRQ                ; check: did a raster IRG happen - yes: handle it
                            
                            jmp CheckTimerIRQ               ; check interrupt Timer A
; --------------------------------------------------------------------------------------------------------------------- ;
; clear interrupt flags
; --------------------------------------------------------------------------------------------------------------------- ;
WasRasterIRQ                lda VICIRQ                      ; VIC($D019) Interrupt Flags - Latched flags cleared if set to 1
                            sta VICIRQ                      ; VIC($D019) Interrupt Flags - Latched flags cleared if set to 1
                            
                            ldx TabWrkExitScrnValues_Off    ; get actual offset castle escape screen value table
                            lda TabExitScrnValues_Color,x   ; 
                            
                            nop                             ; 
                            nop                             ; 
                            nop                             ; 
                            nop                             ; 
                            nop                             ; 
                            nop                             ; 
                            
                            sta BGCOL0                      ; VIC($D021) Background Color 0
                            
                            cpx #$00                        ; test min
                            beq InitSprites                 ; check: min - yes: bypass raster value update
                            
                            jmp SetNextExitScrnRasterVal    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
InitSprites                 lda CCZ_VIC_SP0X                ; 
                            sta SP0X                        ; VIC($D000) Sprite 0 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            lda CCZ_VIC_SP1X                ; 
                            sta SP1X                        ; VIC($D002) Sprite 1 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            lda CCZ_VIC_SP2X                ; 
                            sta SP2X                        ; VIC($D004) Sprite 2 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            lda CCZ_VIC_SP3X                ; 
                            sta SP3X                        ; VIC($D006) Sprite 3 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            lda CCZ_VIC_SP4X                ; 
                            sta SP4X                        ; VIC($D008) Sprite 4 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            lda CCZ_VIC_SP5X                ; 
                            sta SP5X                        ; VIC($D00A) Sprite 5 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            lda CCZ_VIC_SP6X                ; 
                            sta SP6X                        ; VIC($D00C) Sprite 6 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            lda CCZ_VIC_SP7X                ; 
                            sta SP7X                        ; VIC($D00E) Sprite 7 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            lda CCZ_VIC_SP0Y                ; 
                            sta SP0Y                        ; VIC($D001) Sprite 0 Y-Pos (Bits 0-7)
                            
                            lda CCZ_VIC_SP1Y                ; 
                            sta SP1Y                        ; VIC($D003) Sprite 1 Y-Pos (Bits 0-7)
                            
                            lda CCZ_VIC_SP2Y                ; 
                            sta SP2Y                        ; VIC($D005) Sprite 2 Y-Pos (Bits 0-7)
                            
                            lda CCZ_VIC_SP3Y                ; 
                            sta SP3Y                        ; VIC($D007) Sprite 3 Y-Pos (Bits 0-7)
                            
                            lda CCZ_VIC_SP4Y                ; 
                            sta SP4Y                        ; VIC($D009) Sprite 4 Y-Pos (Bits 0-7)
                            
                            lda CCZ_VIC_SP5Y                ; 
                            sta SP5Y                        ; VIC($D00B) Sprite 5 Y-Pos (Bits 0-7)
                            
                            lda CCZ_VIC_SP6Y                ; 
                            sta SP6Y                        ; VIC($D00D) Sprite 6 Y-Pos (Bits 0-7)
                            
                            lda CCZ_VIC_SP7Y                ; 
                            sta SP7Y                        ; VIC($D00F) Sprite 7 Y-Pos (Bits 0-7)
                            
                            lda CCZ_VIC_MSIGX               ; 
                            sta MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            
                            lda CCZ_VIC_SPENA               ; 
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            lda CCZ_VIC_VMCSB               ; 
                            sta VMCSB                       ; VIC($D018) VIC Chip Memory Control
                            
                            lda CCZ_VIC_EXTCOL              ; 
                            sta EXTCOL                      ; VIC($D020) Border Color
                            
                            lda TabExitScrnValues_Color     ; 
                            sta BGCOL0                      ; VIC($D021) Background Color 0
                            
                            lda CCZ_VIC_SCROLX              ; 
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite data pointers - stored in the last 8 bytes of the video matrix
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_TabSprtDataPtr_00       ; 
                            sta CC_ScreenMultiColors + SPNTR_OFFSET + $00 ; 
                            
                            lda CCZ_TabSprtDataPtr_01       ; 
                            sta CC_ScreenMultiColors + SPNTR_OFFSET + $01 ; 
                            
                            lda CCZ_TabSprtDataPtr_02       ; 
                            sta CC_ScreenMultiColors + SPNTR_OFFSET + $02 ; 
                            
                            lda CCZ_TabSprtDataPtr_03       ; 
                            sta CC_ScreenMultiColors + SPNTR_OFFSET + $03 ; 
                            
                            lda CCZ_TabSprtDataPtr_04       ; 
                            sta CC_ScreenMultiColors + SPNTR_OFFSET + $04 ; 
                            
                            lda CCZ_TabSprtDataPtr_05       ; 
                            sta CC_ScreenMultiColors + SPNTR_OFFSET + $05 ; 
                            
                            lda CCZ_TabSprtDataPtr_06       ; 
                            sta CC_ScreenMultiColors + SPNTR_OFFSET + $06 ; 
                            
                            lda CCZ_TabSprtDataPtr_07       ; 
                            sta CC_ScreenMultiColors + SPNTR_OFFSET + $07 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; handle IRQ counter
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            beq SetNextExitScrnRasterVal    ; check: min - yes: bypass count down
                            
                            dec TabWrkIRQ_Count             ; counted down to $00 with every IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
; handle castle escape screen raster postions
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextExitScrnRasterVal    inx                             ; point to next castle escape screen value pair
                            inx                             ; 
                            cpx TabWrkExitScrnValues_Max    ; test with max offset castle escape screen value table
                            beq GetExitScreenValue          ; check: EQ - yes: bypass get reset value
                            bcc GetExitScreenValue          ; check: LT - yes: bypass get reset value
                            
                            ldx #$00                        ; get table restart value
                            
GetExitScreenValue          lda TabExitScrnValues_Raster,x  ; 
                            sta RASTER                      ; VIC($D012) Read : Current Raster Scan Line (Bit 8 in SCROLY = $D011)
                            
                            stx TabWrkExitScrnValues_Off    ; set actual offset castle escape screen value table
; --------------------------------------------------------------------------------------------------------------------- ;
; handle sfx
; --------------------------------------------------------------------------------------------------------------------- ;
CheckTimerIRQ               lda CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            and #CIAICR_DATA_TA             ; isolate Tmer A interrupt flag
                            beq IRQX                        ; check: timer interrupt - no: bypass sfx handler
                            
                            jsr IRQ_SFX_Handler             ; handle all game sound effects
; --------------------------------------------------------------------------------------------------------------------- ;
IRQX                        pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rti                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkExitScrnValues_Off    .byte $00 ; offset castle escape screen value table
TabWrkExitScrnValues_Max    .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; castle escape sxreen raster values (2 bytes each - color and raster)
; --------------------------------------------------------------------------------------------------------------------- ;
TabExitScrnValues_Color      = * + $00    ; 
TabExitScrnValues_Raster     = * + $01    ; 
                            .byte BLACK   ; 
                            .byte $00     ; raster scan line: start BLACK   - sky
                            .byte DK_GREY ; 
                            .byte $a2     ; raster scan line: start DK_GREY - ground
                            .byte BROWN   ; 
                            .byte $ca     ; raster scan line: start BROWN   - exit screen path
                            .byte DK_GREY ; 
                            .byte $d2     ; raster scan line: start DK_GREY - 
TabExitScrnValues_Len       = * - TabExitScrnValues_Raster - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; NMI                       Does    : game NMI handler
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
NMI                        .block                           ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkKey_Restore_Yes      ; 
                            sta TabWrkKey_Restore           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            rti                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkKey_Restore           .byte $00 ; 
TabWrkKey_Restore_No            = $00 ; 
TabWrkKey_Restore_Yes           = $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MainLoop                  Does    : game main loop
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop                   .block                           ; 
                            jsr Main_DemoHandler            ; display game title / loaded castle data rooms / play music
                            jsr Main_GameHandler            ; init castle work data and move the players towards the exit door
                            
                            jmp MainLoop                    ; next round
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; Main_DemoHandler          Does    : display game title / show castle rooms / play music after 1st three rooms
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
Main_DemoHandler           .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoInit                    lda #$00                        ; get initial value
                            sta TabWrkDemo_SongNumber       ; init demo song number
                            
                            lda #TabWrkDemoRoom_Count_Max   ; get initial value
                            sta TabWrkDemoRoom_Count        ; show title screen after the display of every max rooms
; --------------------------------------------------------------------------------------------------------------------- ;
; request castle data load buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabFlagDataBufAdr_Load     ; get flag castle data load memory
                            sta TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            
                            lda #$00                        ; get initial value
                            sta TabWrkDemo_PlayerNumber     ; init player #1
                            sta TabWrkDemo_RoomNumber       ; init room #0
; --------------------------------------------------------------------------------------------------------------------- ;
; loop through all the available castle rooms
; --------------------------------------------------------------------------------------------------------------------- ;
ShowNextDemoRoom            inc TabWrkDemoRoom_Count        ; inc demo room counter
                            
                            lda TabWrkDemoRoom_Count        ; 
                            and #TabWrkDemoRoom_Count_Max   ; limit to $00-max
                            sta TabWrkDemoRoom_Count        ; 
                            beq ShowDemoTitleScreen         ; check: max rooms displayed - yes: display title screen
                            
                            inc TabWrkDemo_RoomNumber       ; set next room number
; --------------------------------------------------------------------------------------------------------------------- ;
; set the level load data memory pointer to the selected target memory for the selected room number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDemo_RoomNumber       ; get room number
                            jsr CastleRoomDataPointerSet    ; set the room data pointer to the requested entry in the target data store
                            
                            ldy #CC_Room_Map_Status         ; get offset room status
                            lda (CCZ_RoomListDataPtr),y     ; get room status
                            bit TabFlagRoom_EndOfList       ; test flag CC_Room_Map_EoL
                            beq DisplayThisDemoRoom         ; check: end of room definition data - no: bypass room counter reset
                            
                            lda #$00                        ; last room displayed - get restart demo room number
                            sta TabWrkDemo_RoomNumber       ; set restart demo room number
                            
DisplayThisDemoRoom         jsr CastleRoomDrawPrepare       ; set up for subroutine CastleRoomDrawHandler
                            jmp SwitchDemoScreenOn          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the Castles Of Dr Creep title screen
; --------------------------------------------------------------------------------------------------------------------- ;
ShowDemoTitleScreen         jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
; --------------------------------------------------------------------------------------------------------------------- ;
; treat the game start screen like a castle room
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabDemo_TitleRoomData     ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabDemo_TitleRoomData     ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; set room data address pointer to address of title screen data
                            
                            jsr CastleRoomDrawHandler       ; control drawing the castle room items
                            
SwitchDemoScreenOn          lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; handle demo music
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda WrkFlagDemoMusicActive      ; 
                            cmp #WrkFlagDemoMusicActive_Yes ; test with flag demo music is played
                            beq GetDemoTitleWaitTime        ; check: EQ - yes: bypass init demo song number
                            
                            lda TabWrkDemoRoom_Count        ; get demo room count
                            bne GetDemoTitleWaitTime        ; check: ZERO - no: bypass song number handling
                            
                            lda TabWrkDemo_SongNumber       ; 
                            bne IniDemoSongLoad             ; check: ZERO - no: set next demo music song
                            
                            inc TabWrkDemo_SongNumber       ; set next song number
                            
GetDemoTitleWaitTime        lda #$c8                        ; get inital value
                            sta TabWrkDemo_ShowWaitTime     ; set wait time
; --------------------------------------------------------------------------------------------------------------------- ;
; display demo room and check player input to end the demo and start the game
; --------------------------------------------------------------------------------------------------------------------- ;
ShowThisDemoRoom            lda TabWrkDemoRoom_Count        ; get demo room counter
                            beq WaitForIRQCountDown         ; check: start screen - yes: bypass action display
                            
                            jsr CastleRoomActionHandler     ; detect sprite collisions and handle all sprite/object actions
                            jmp CheckInputPlayer_P1         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; count down the IRQ wait counter to display the room
; --------------------------------------------------------------------------------------------------------------------- ;
WaitForIRQCountDown         lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne WaitForIRQCountDown         ; check: min - no: continue waiting
                            
                            lda #$02                        ; get initial value
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
; get and check player input
; --------------------------------------------------------------------------------------------------------------------- ;
CheckInputPlayer_P1         lda TabWrkDemo_PlayerNumber     ; get actual player number
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input
                            
                            lda TabWrkInput_Joy_Fire        ; get sttaus fire button for actual player
                            beq CheckInputPlayer_P2         ; check: pressed - no: check 2nd player
; --------------------------------------------------------------------------------------------------------------------- ;
; end of demo after a player pressed the fire btton
; --------------------------------------------------------------------------------------------------------------------- ;
GoDemo_Exit                 jmp Demo_Exit                   ; player input ended demo
; --------------------------------------------------------------------------------------------------------------------- ;
CheckInputPlayer_P2         lda TabWrkDemo_PlayerNumber     ; get actual player number
                            eor #$01                        ; flip player number
                            sta TabWrkDemo_PlayerNumber     ; set new player number
; --------------------------------------------------------------------------------------------------------------------- ;
; check the STOP key and eventually start the game menu
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkInput_Key_Stop        ; 
                            cmp #TabWrkInput_Key_Stop_Yes   ; test STOP key pressed
                            beq ShowGameSelectionMenu       ; check: TabWrkInput_Key_Stop_No - yes: show game selection menu
; --------------------------------------------------------------------------------------------------------------------- ;
; continue demo
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabWrkDemo_ShowWaitTime     ; dec wait time
                            bne ShowThisDemoRoom            ; check: wait time over - no: continue with actual room
                            
                            jmp ShowNextDemoRoom            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; show game and load castle data file menu
; --------------------------------------------------------------------------------------------------------------------- ;
ShowGameSelectionMenu       jsr MenuHandler                 ; control the game menu with castle data files selections
                            
                            lda TabWrkFlagGameResumed       ; get status of load a saved game
                            cmp #TabWrkFlagGameResumed_OK   ; test success
                            beq GoDemo_Exit                 ; check: EQ - yes: exit demo
                            
                            jmp DemoInit                    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare next music file load
; --------------------------------------------------------------------------------------------------------------------- ;
IniDemoSongLoad             inc TabDemoFileName_Song_Num    ; set next demo music song file number
                            
                            ldx #TabDemoFileName_Song_Len   ; get max length of music file name
                            stx TabWrkLoadFile_Len          ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get the demo music file name
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextDemoSongFileNameOff  dex                             ; dec music file name offset
                            bmi SetMusicFileLoadAdr         ; check: min - yes: done
                            
                            lda TabDemoFileName_Song,x      ; copy next music file name char
                            sta TabWrkLoadFile,x            ; 
                            
                            jmp SetNextDemoSongFileNameOff  ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
; load the demo music file to CC_GameDataBuf
; --------------------------------------------------------------------------------------------------------------------- ;
SetMusicFileLoadAdr         lda #TabFlagLoadMem_Game        ; get flag select memory CC_GameDataBuf
                            sta TabFlagLoadMem              ; set flag target memory area
                            
                            jsr CastleDataPrepareDiskIO     ; switch KERNAL back on
                            jsr CastleDataVerifyDisk        ; verify the master disk name of DUNGEONMASTER
                            cmp #$00                        ; test master disk found
                            bne DemoMusicNone               ; check: NE - yes: probably no valid demo music files on this disk
                            
LoadDemoMusicFile           jsr CastleDataFileLoad          ; load a file from disk
                            jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            cmp #$40                        ; test End Of File
                            beq WaitAndRestart              ; check: EoF - yes: load successful
; --------------------------------------------------------------------------------------------------------------------- ;
; reset music file number to min in case of a file not found error - song counter overflow (music9)
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabDemoFileName_Song_Num    ; get demo music piece file number
                            cmp #"0"                        ; test min 
                            beq DemoMusicNone               ; check: EQ - yes: no music files available on this disk
                            
                            lda #"0"                        ; get initial value
                            sta TabDemoFileName_Song_Num    ; reset demo music song file name number
                            sta TabWrkLoadFileMusicNum      ; 
                            
                            jmp LoadDemoMusicFile           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; no playable music file found on disk - nothing to play - quiesce
; --------------------------------------------------------------------------------------------------------------------- ;
; shift in SID voice numbers bits ......11 to prepare correct SID data portion type bit position ..1111..
; as it will be shifted out again in GetNextSoundDataByte_Type to isolate the SID data portion type
; --------------------------------------------------------------------------------------------------------------------- ;
; TabWrkSidDataType_End constantly resets the CCZ_SoundDataPtr at IniDemoMusicDataPtr - so no music play data is copied
; --------------------------------------------------------------------------------------------------------------------- ;
DemoMusicNone               lda #TabWrkSidDataType_End << $02 ; get flag no music
                            sta CC_DemoMusicData_Start      ; quiesce play of loaded demo music file
; --------------------------------------------------------------------------------------------------------------------- ;
; init SID for demo music
; --------------------------------------------------------------------------------------------------------------------- ;
WaitAndRestart              jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
                            
                            lda #<CC_DemoMusicData_Start    ; 
                            sta CCZ_SoundDataPtr_Lo         ; 
                            lda #>CC_DemoMusicData_Start    ; 
                            sta CCZ_SoundDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; start RELEASE for voice 1 voice 2 and voice 3 - every SID voice ctrl block is $07 bytes long
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #FREQLO3 - SID              ; start with offset voice 3 ($0e)
InitNextVoice_Demo          lda TabWrkSidVal_Cntrl_1,x      ; get voice 1-3 CNTRL value
                            and #CNTRL3_GATE_REL            ; #######. - 0=Start RELEASE cycle
                            sta TabWrkSidVal_Cntrl_1,x      ; set voice 1-3 CNTRL value
                            sta VCREG1,x                    ; SID($D404) Oscillator 1 Control
                            
                            sec                             ; 
                            txa                             ; 
                            sbc #FREQLO3 - FREQLO2          ; sub SID voice ctrl block length - set offset next voice ($07/$00)
                            tax                             ; 
                            bcs InitNextVoice_Demo          ; check: underflow - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init filter
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSidVal_RESFILT        ; Filter Resonance Control
                            and #~RESFILT_FILT_MASK         ; ####.... - switch filter off for all voices
                            sta RESFILT                     ; SID($D417) Filter Resonance Ctrl
                            sta TabWrkSidVal_RESFILT        ; Filter Resonance Control
; --------------------------------------------------------------------------------------------------------------------- ;
; init timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta TabWrkSfx_PlayTime_Lo       ; init timer
                            sta TabWrkSfx_PlayTime_Hi       ; 
                            
                            lda #$14                        ; get inital value
                            sta TabWrkSidVal_CUTLO_Save     ; 
                            
                            asl a                           ; *2
                            asl a                           ; *4
                            ora #$03                        ; ......##
                            sta TIMAHI                      ; CIA1($DC05) Timer A (high byte)
                            
                            lda #WrkFlagDemoMusicActive_Yes ; get flag play demo music
                            sta WrkFlagDemoMusicActive      ; init flag play demo music
; --------------------------------------------------------------------------------------------------------------------- ;
; start timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CIAICR_SC_SET | CIAICR_DATA_TA ; get interrupt underflow Timer A
                            sta CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            
                            lda #CIACRA_START               ; get start Timer A
                            sta CIACRA                      ; CIA1($DC0E) Control Register A
                            
                            jmp ShowNextDemoRoom            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init SID for game
; --------------------------------------------------------------------------------------------------------------------- ;
Demo_Exit                   lda #WrkFlagDemoMusicActive_No  ; get flag demo music off
                            sta WrkFlagDemoMusicActive      ; init flag demo music off
                            
                            lda #TabFlagDataBufAdr_Game     ; get flag castle data game work memory
                            sta TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            
                            lda #$00                        ; get initial value
                            sta CIACRA                      ; CIA1($DC0E) Control Register A
                            
                            lda #CIAICR_SC_CLR_ALL          ; .####### - Clear All Interrupt Sources
                            sta CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            lda CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            
                            ldx #FREQLO3 - SID              ; start with offset voice 3 ($0e)
InitNextVoice_Game          lda TabWrkSidVal_Cntrl_1,x      ; get voice 1-3 CNTRL value
                            and #CNTRL3_GATE_REL            ; #######. - start RELEASE cycle
                            sta TabWrkSidVal_Cntrl_1,x      ; set voice 1-3 CNTRL value
                            sta VCREG1,x                    ; SID($D404) Oscillator 1 Control
                            
                            sec                             ; 
                            txa                             ; 
                            sbc #FREQLO3 - FREQLO2          ; sub SID voice ctrl block length - set offset next voice ($07/$00)
                            tax                             ; 
                            bcs InitNextVoice_Game          ; check: check: underflow - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDemoRoom_Count        .byte $85 ; 
TabWrkDemoRoom_Count_Max        = $03 ; max number of consecutive demo display rooms
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagDataBufAdr           .byte $00 ; 
TabFlagDataBufAdr_Game          = $00 ; flag: $00=$7800 - actual castle data for play
TabFlagDataBufAdr_Load          = $01 ; flag: $01=$9800 - loaded castle data for restart
TabFlagDataBufAdr_Times         = $02 ; flag: $02=$b800 - loaded best times
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDemo_PlayerNumber     .byte $a0 ; 
TabWrkDemo_RoomNumber       .byte $b0 ; 
TabWrkDemo_ShowWaitTime     .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoFileName_Song        = *       ; 
                            .byte "m" ; 
                            .byte "u" ; 
                            .byte "s" ; 
                            .byte "i" ; 
                            .byte "c" ; 
TabDemoFileName_Song_Num    .byte "0" ; 
TabDemoFileName_Song_Len    = * - TabDemoFileName_Song ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDemo_SongNumber       .byte $ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; title screen is treated like a castle room
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemo_TitleRoomData       = * ; 
                            .word DrawRoomGraphic ; 
                            
                            .byte $08 ; number of objects
                            .byte ItemNum_DoorNormal ; 
                            .byte $10 ; StartPosX
                            .byte $58 ; StartPosY
                            .byte $14 ; NextPosX  : PosX + $14
                            .byte $00 ; NextPosY  : PosY + $00
                            .byte $00 ; EndOfData
                            
                            .word DrawText  ; 
                            
                            .byte $28       ; StartPosX
                            .byte $30       ; StartPosY
                            .byte ORANGE    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "t"       ; Text: the castles of 
                            .byte "h"       ; 
                            .byte "e"       ; 
                            .byte " "       ; <space>
                            .byte "c"       ; 
                            .byte "a"       ; 
                            .byte "s"       ; 
                            .byte "t"       ; 
                            .byte "l"       ; 
                            .byte "e"       ; 
                            .byte "s"       ; 
                            .byte " "       ; <space>
                            .byte "o"       ; 
                            .byte "f" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $30       ; StartPosX
                            .byte $40       ; StartPosY
                            .byte LT_GREEN  ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "d"       ; Text: doctor creep
                            .byte "o"       ; 
                            .byte "c"       ; 
                            .byte "t"       ; 
                            .byte "o"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte "c"       ; 
                            .byte "r"       ; 
                            .byte "e"       ; 
                            .byte "e"       ; 
                            .byte "p" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $34       ; StartPosX
                            .byte $80       ; StartPosY
                            .byte YELLOW    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "b"       ; Text: by ed hobby
                            .byte "y"       ; 
                            .byte " "       ; 
                            .byte "e"       ; 
                            .byte "d"       ; 
                            .byte " "       ; 
                            .byte "h"       ; 
                            .byte "o"       ; 
                            .byte "b"       ; 
                            .byte "b"       ; 
                            .byte "s" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $10       ; StartPosX
                            .byte $c0       ; StartPosY
                            .byte GREY      ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "b"       ; Text: br0derbund software
                            .byte "r"       ; 
                            .byte "0"       ; 
                            .byte "d"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte "b"       ; 
                            .byte "u"       ; 
                            .byte "n"       ; 
                            .byte "d"       ; 
                            .byte " "       ; 
                            .byte " "       ; 
                            .byte "s"       ; 
                            .byte "o"       ; 
                            .byte "f"       ; 
                            .byte "t"       ; 
                            .byte "w"       ; 
                            .byte "a"       ; 
                            .byte "r"       ; 
                            .byte "e" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText
                            
                            .word $0000     ; EndOfRoomData
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; Main_GameHandler          Does    : init castle work data and move the players towards the exit door
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
Main_GameHandler           .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; preapare for the game main loop
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkFlagGameResumed       ; get status of resume a saved game
                            cmp #TabWrkFlagGameResumed_OK   ; test success
                            bne CopyGameCastleData          ; check: NE - yes: unsuccessful - resume failed
; --------------------------------------------------------------------------------------------------------------------- ;
; init resume status
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkFlagGameResumed_Ini  ; get initial value
                            sta TabWrkFlagGameResumed       ; reset status of load a saved game
                            
                            lda CC_GameDataVar_Game         ; get game status flag from castle data variables
                            ora #CC_GameDataVar_Game_Resume ; mark game status as resumed
                            sta CC_GameDataVar_Game         ; set new game status flag in castle data variables
                            
                            jmp GameHandler_Loop            ; handle castle map and rooms until all players are dead
; --------------------------------------------------------------------------------------------------------------------- ;
; refresh castle work data from loaded castle data
; --------------------------------------------------------------------------------------------------------------------- ;
CopyGameCastleData          ldy #$00                        ; init page offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to loaded castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_LoadDataBuf            ; 
                            sta CCZ_DataCopySourcePtr_Lo    ; 
                            lda #>CC_LoadDataBuf            ; 
                            sta CCZ_DataCopySourcePtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to work castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_GameDataBuf            ; 
                            sta CCZ_DataCopyTargetPtr_Lo    ; 
                            lda #>CC_GameDataBuf            ; 
                            sta CCZ_DataCopyTargetPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set castle data counter
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_LoadDataBuf_CountLast    ; 
                            sta CCZ_LevelDataCountLast      ; 
                            lda CC_LoadDataBuf_CountPages   ; 
                            sta CCZ_LevelDataCountPage      ; 
                            beq GetNextCastleDataByte_Rest  ; copy the remaing bytes of the last page
; --------------------------------------------------------------------------------------------------------------------- ;
; copy full castle data pages
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextCastleDataByte_Page  lda (CCZ_DataCopySourcePtr),y   ; copy page data
                            sta (CCZ_DataCopyTargetPtr),y   ; 
                            
                            iny                             ; inc page offset
                            bne GetNextCastleDataByte_Page  ; check: page complete - no: continue
                            
                            inc CCZ_DataCopySourcePtr_Hi    ; set next page
                            inc CCZ_DataCopyTargetPtr_Hi    ; 
                            
                            dec CCZ_LevelDataCountPage      ; dec page count
                            bne GetNextCastleDataByte_Page  ; check: min - no continue
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the remaing castle data bytes of the last page
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextCastleDataByte_Rest  cpy CCZ_LevelDataCountLast      ; test last page byte count
                            beq IniCastleDataVars           ; check: EQ - yes: done
                            
                            lda (CCZ_DataCopySourcePtr),y   ; copy last page content
                            sta (CCZ_DataCopyTargetPtr),y   ; 
                            
                            iny                             ; inc last page data offset
                            jmp GetNextCastleDataByte_Rest  ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init castle data game variables
; --------------------------------------------------------------------------------------------------------------------- ;
IniCastleDataVars           lda TabWrkDemo_PlayerNumber     ; 
                            sta CC_GameDataVar_Active_P2    ; set player #2 active flag in castle data variables
; --------------------------------------------------------------------------------------------------------------------- ;
; init castle data escape time
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_GameDataVar_Times_Len   ; init offset castle time data in castle data variables
                            lda #$00                        ; get initial value
IniNextGameTimeByte         sta CC_GameDataVar_Times,y      ; clear castle time data in castle data variables
                            
                            dey                             ; dec offset
                            bpl IniNextGameTimeByte         ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init player escape status and start room and door numbers
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_GameDataVar_Exit_No     ; 
                            sta CC_GameDataVar_Exit_P1      ; init flag player #1 exit status in castle data variables
                            sta CC_GameDataVar_Exit_P2      ; init flag player #2 exit status in castle data variables
                            
                            lda CC_GameDataVar_StartRoom_P1 ; get start room number from castle data variables
                            sta CC_GameDataVar_TargRoom_P1  ; set player target room number in castle data variables
                            
                            lda CC_GameDataVar_StartRoom_P2 ; get start room number from castle data variables
                            sta CC_GameDataVar_TargRoom_P2  ; set player target room number in castle data variables
                            
                            lda CC_GameDataVar_StartDoor_P1 ; get player #1 start room number from castle data variables
                            sta CC_GameDataVar_TargDoor_P1  ; set player #1 target door number in castle data variables
                            
                            lda CC_GameDataVar_StartDoor_P2 ; get player #2 start door number from castle data variables
                            sta CC_GameDataVar_TargDoor_P2  ; set player #2 target door number in castle data variables
                            
                            lda #CC_GameDataVar_Active_No   ; 
                            sta CC_GameDataVar_Active_P1    ; set player #1 active flag in castle data variables
; --------------------------------------------------------------------------------------------------------------------- ;
; always join player #1
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_GameDataVar_Health_Alive; 
                            sta CC_GameDataVar_Health_P1    ; flag player #1 alive in castle data variables
; --------------------------------------------------------------------------------------------------------------------- ;
; check two players game
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_Active_P2    ; get player #2 active flag from castle data variables
                            cmp #CC_GameDataVar_Active_Yes  ; test player #2 active
                            beq JoinPlayer_P2               ; check: EQ - yes: join him
; --------------------------------------------------------------------------------------------------------------------- ;
; disable player #2
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_GameDataVar_Health_Dead ; 
                            sta CC_GameDataVar_Health_P2    ; flag player #2 dead in castle data variables
                            
                            lda #CC_GameDataVar_Flag_Inactive ; 
                            sta CC_GameDataVar_Flag_P2      ; flag player #2 inactive in castle data variables
                            
                            jmp GameHandler_Loop            ; handle castle map and rooms until all players are dead
; --------------------------------------------------------------------------------------------------------------------- ;
; join player #2
; --------------------------------------------------------------------------------------------------------------------- ;
JoinPlayer_P2               lda #CC_GameDataVar_Health_Alive; 
                            sta CC_GameDataVar_Health_P2    ; flag player #2 alive in castle data variables
; --------------------------------------------------------------------------------------------------------------------- ;
; enter the game handler loop - at least one player participates
; --------------------------------------------------------------------------------------------------------------------- ;
GameHandler_Loop            lda CC_GameDataVar_Health_P1    ; get player #1 health from castle data variables
                            cmp #CC_GameDataVar_Health_Alive; test player #1 alive
                            beq ChkHealth_P1_P2             ; check: alive - yes: continue the game
                            
                            lda CC_GameDataVar_Health_P2    ; get player #2 health from castle data variables
                            cmp #CC_GameDataVar_Health_Alive; test player #2 alive
                            beq ChkHealth_P1_P2             ; check: alive - yes: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; both players are dead - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp Main_GameHandlerX           ; both players are dead - end of game
; --------------------------------------------------------------------------------------------------------------------- ;
; at least one player is alive
; --------------------------------------------------------------------------------------------------------------------- ;
ChkHealth_P1_P2             lda CC_GameDataVar_Health_P1    ; get player #1 health from castle data variables
                            cmp #CC_GameDataVar_Health_Alive; test player #1 set alive
                            bne LetPlayerEnterTheRoom       ; check: NE - yes: let the living player enter the room
                            
                            lda CC_GameDataVar_Health_P2    ; get player #2 health from castle data variables
                            cmp #CC_GameDataVar_Health_Alive; test player #2 set alive
                            bne LetPlayerEnterTheRoom       ; check: NE - yes: let the living player enter the room
; --------------------------------------------------------------------------------------------------------------------- ;
; check player target room numbers
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_TargRoom_P1  ; get player #1 target room number from castle data variables
                            cmp CC_GameDataVar_TargRoom_P2  ; test with player #2 target room number from castle data variables
                            bne TargetRoomsDiffer           ; check: same room - no
; --------------------------------------------------------------------------------------------------------------------- ;
; both players enter the same room
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkPlayer_Room_Left_Yes ; 
                            sta TabWrkPlayer_Room_Left_P1   ; both players have left to map
                            sta TabWrkPlayer_Room_Left_P2   ; 
                            
                            jmp CastleMapAndRoomShow        ; display the current castle map progress / enter the room
; --------------------------------------------------------------------------------------------------------------------- ;
; both players enter different rooms
; --------------------------------------------------------------------------------------------------------------------- ;
TargetRoomsDiffer           ldx CC_GameDataVar_Active_P1    ; get player #1 active flag from castle data variables
                            lda #TabWrkPlayer_Room_Left_No  ; 
                            sta TabWrkPlayer_Room_Left,x    ; flag player has entered this room
                            
                            txa                             ; 
                            eor #$01                        ; flip to next player
                            tax                             ; 
                            
                            lda #TabWrkPlayer_Room_Left_Yes ; 
                            sta TabWrkPlayer_Room_Left,x    ; flag player has left this room
                            
                            jmp CastleMapAndRoomShow        ; display the current castle map progress / enter the room
; --------------------------------------------------------------------------------------------------------------------- ;
LetPlayerEnterTheRoom       lda CC_GameDataVar_Health_P1    ; get player #1 health from castle data variables
                            cmp #CC_GameDataVar_Health_Alive; test alive
                            beq Enter_P1                    ; check: EQ - yes: enter him
; --------------------------------------------------------------------------------------------------------------------- ;
; enter player #2
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkPlayer_Room_Left_Yes ; allow player #2
                            sta TabWrkPlayer_Room_Left_P2   ; player #2 has left to map
                            
                            lda #TabWrkPlayer_Room_Left_No  ; forbid player #1
                            sta TabWrkPlayer_Room_Left_P1   ; player #1 still in room
                            
                            jmp CastleMapAndRoomShow        ; display the current castle map / enter the room
; --------------------------------------------------------------------------------------------------------------------- ;
; enter player #1
; --------------------------------------------------------------------------------------------------------------------- ;
Enter_P1                    lda #TabWrkPlayer_Room_Left_Yes ; allow player #1
                            sta TabWrkPlayer_Room_Left_P1   ; 
                            
                            lda #TabWrkPlayer_Room_Left_No  ; forbid player #2
                            sta TabWrkPlayer_Room_Left_P2   ; player #2 still in room
; --------------------------------------------------------------------------------------------------------------------- ;
; show the castle map and the entered castle room after a play pressed fire
; --------------------------------------------------------------------------------------------------------------------- ;
CastleMapAndRoomShow        jsr CastleMapHandler            ; display the current castle map progress
                            jsr CastleRoomHandler           ; display room - get player input - handle room items
; --------------------------------------------------------------------------------------------------------------------- ;
; a player has left the room
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
                            
                            lda #TabFlagGameOverPlayer_No   ; get initial value
                            sta TabFlagGameOverPlayer       ; flag the actual player as active
; --------------------------------------------------------------------------------------------------------------------- ;
; check if this player had an accident
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; start with player #1
CheckNextPlayerExitStatus   lda TabWrkPlayer_Room_Left,x    ; 
                            cmp #TabWrkPlayer_Room_Left_Yes ; test player has left the room
                            bne SetPlayerNext               ; check: left the room - no: continue with next player
                            
                            lda CC_GameDataVar_Flag,x       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_Hit    ; test if something bad happened to the player
                            beq DecPlayerNumLives           ; check: accident - yes: discount a live
; --------------------------------------------------------------------------------------------------------------------- ;
; check if this player has left the castle
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_Exit,x       ; get flag player exit status from castle data variables
                            cmp #CC_GameDataVar_Exit_Yes    ; test exit
                            bne SetPlayerNext               ; check: not exiting - yes: continue with next player
; --------------------------------------------------------------------------------------------------------------------- ;
; this player has left the castle through the exit door
; --------------------------------------------------------------------------------------------------------------------- ;
                            stx TabWrkEscape_PlayerNum      ; save actual castle escape player number
                            
                            jsr CastleEscapeHandler         ; show a castle picture and let a player run down the castle escape path
; --------------------------------------------------------------------------------------------------------------------- ;
; check if he qualifies for castle escape time recording
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_Game         ; get game status flag from castle data variables
                            and #CC_GameDataVar_Game_Resume ; isolate flag resumed a saved game
                            bne SetPlayerGameOver           ; check: resumed - yes: bypass castle escape time handling
                            
                            lda TabWrkMenu_LivesUnlim       ; get flag unlimited lives set
                            cmp #TabWrkMenu_LivesUnlim_Yes  ; test with flag unlimited lives set
                            beq SetPlayerGameOver           ; check: EQ - yes: bypass castle escape time handling
                            
                            lda TabWrkMenuCtrlBlk_Off_Sel   ; get offset ctrl block of the cursor selected entry
                            cmp #$ff                        ; test still initial value
                            beq SetPlayerGameOver           ; check: EQ - yes: no castle data file loaded - bypass castle escape time handling
; --------------------------------------------------------------------------------------------------------------------- ;
; handle castle escape time
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; get player number
                            asl a                           ; *2
                            asl a                           ; *4 - length of times block in castle data variables
                            clc                             ; 
                            adc #<CC_GameDataVar_Times      ; add offset castle time data in castle data variables
                            sta CCZ_CastleTimePtr_Lo        ; 
                            lda #>CC_GameDataBuf            ; 
                            adc #$00                        ; add carry
                            sta CCZ_CastleTimePtr_Hi        ; set castle time pointer of castle data variables
                            
                            ldy #CC_GameDataVar_Times_Len / $02 ; init offset this time data in castle data variables
GetNextCastleTimeValue      lda (CCZ_CastleTimePtr),y       ; 
                            sta TabWrkEscapeTimePlayer,y    ; 
                            
                            dey                             ; dec time offset
                            bpl GetNextCastleTimeValue      ; check: min - no: continue
                            
                            stx TabWrkEscapeTime_Player_Num ; 
                            
                            jsr LeaderBoardInsertNew        ; probably find and insert a new best castle escape time
                            jmp SetPlayerGameOver           ; mark game over for this player
; --------------------------------------------------------------------------------------------------------------------- ;
; an accident of some sort has happened - try to discount a live
; --------------------------------------------------------------------------------------------------------------------- ;
DecPlayerNumLives           lda TabWrkMenu_LivesUnlim       ; 
                            cmp #TabWrkMenu_LivesUnlim_Yes  ; test with flag unlimited lives
                            beq IniPlayerStartRoom          ; check: EQ - bypass dec number of lives
                            
                            dec CC_GameDataVar_NumLives,x   ; discount player number of lives in castle data variables
                            
                            lda CC_GameDataVar_NumLives,x   ; get player number of lives from castle data variables
                            beq SetPlayerGameOver           ; check: out of lives - yes: mark game over for this player
; --------------------------------------------------------------------------------------------------------------------- ;
; push player back to this castle start room and door
; --------------------------------------------------------------------------------------------------------------------- ;
IniPlayerStartRoom          lda CC_GameDataVar_StartRoom,x  ; get players start room number from castle data variables
                            sta CC_GameDataVar_TargRoom,x   ; set player target room number from castle data variables
                            
                            lda CC_GameDataVar_StartDoor,x  ; get player start room number from castle data variables
                            sta CC_GameDataVar_TargDoor,x   ; set players start door number from castle data variables
                            
                            jmp SetPlayerNext               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark game over for this player
; --------------------------------------------------------------------------------------------------------------------- ;
SetPlayerGameOver           lda #CC_GameDataVar_Health_Dead ; 
                            sta CC_GameDataVar_Health,x     ; set players health in castle data variables
                            
                            lda #TabFlagGameOverPlayer_Yes  ; get flag actual player is alive
                            sta TabFlagGameOverPlayer       ; mark actual player alive
; --------------------------------------------------------------------------------------------------------------------- ;
; handle next player
; --------------------------------------------------------------------------------------------------------------------- ;
SetPlayerNext               inx                             ; select player #2
                            cpx #$02                        ; test max + $01
                            bcc CheckNextPlayerExitStatus   ; check: LT - yes: continue with next player
; --------------------------------------------------------------------------------------------------------------------- ;
; check a possible game over for this player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabFlagGameOverPlayer       ; get flag 
                            cmp #TabFlagGameOverPlayer_Yes  ; test flag game over actual player
                            bne GoGameHandler_Loop          ; check: player still in game - yes: continue loop
; --------------------------------------------------------------------------------------------------------------------- ;
; write out the game over message for this player
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
                            
                            lda #<TabText_GameOver          ; Text: game over
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_GameOver          ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawText                    ; write out game over ...
; --------------------------------------------------------------------------------------------------------------------- ;
; check if in two players game - if not write out game over only - do not write out the player number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_Active_P2    ; get player #2 active flag from castle data variables
                            cmp #CC_GameDataVar_Active_No   ; test player #2 active
                            beq SwitchDisplayOn             ; check: p2 active - no: only game over - bypass player number
; --------------------------------------------------------------------------------------------------------------------- ;
; two players game - check player #1 health
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_Health_P1    ; get player #1 health from castle data variables
                            cmp #CC_GameDataVar_Health_Alive; test still alive
                            beq ChkHealthPlayer_2           ; check: alive - yes: check health player #2
                            
                            lda #<TabText_ForPlayer_1       ; Text: for player 1
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_ForPlayer_1       ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawText                    ; ... for player #1
; --------------------------------------------------------------------------------------------------------------------- ;
; two players game - check player #2 health
; --------------------------------------------------------------------------------------------------------------------- ;
ChkHealthPlayer_2           lda CC_GameDataVar_Health_P2    ; get player #2 health from castle data variables
                            cmp #CC_GameDataVar_Health_Alive; test still alive
                            beq SwitchDisplayOn             ; check: alive - yes: make message visible
                            
                            lda #<TabText_ForPlayer_2       ; Text: for player 2
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_ForPlayer_2       ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawText                    ; ... for player #2
; --------------------------------------------------------------------------------------------------------------------- ;
; visualize the message
; --------------------------------------------------------------------------------------------------------------------- ;
SwitchDisplayOn             lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            
                            lda #$23                        ; get count of IRQs to wait
                            jsr WaitSomeIrqCycles           ; wait
; --------------------------------------------------------------------------------------------------------------------- ;
; at least one player is still alive - continue the game loop
; --------------------------------------------------------------------------------------------------------------------- ;
GoGameHandler_Loop          jmp GameHandler_Loop            ; handle castle map and rooms until all players are dead
; --------------------------------------------------------------------------------------------------------------------- ;
Main_GameHandlerX           pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $b4 ; 
TabFlagGameOverPlayer       .byte $a0 ; 
TabFlagGameOverPlayer_Yes       = $01 ; 
TabFlagGameOverPlayer_No        = $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlag_NotUsed             .byte $89 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_GameOver            = * ; 
                            .byte $3c       ; StartPosX
                            .byte $38       ; StartPosY
                            .byte LT_RED    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "g"       ; Text: game over
                            .byte "a"       ; 
                            .byte "m"       ; 
                            .byte "e"       ; 
                            .byte " "       ; 
                            .byte "o"       ; 
                            .byte "v"       ; 
                            .byte "e"       ; 
                            .byte "r" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00 ; EndOfText
                            
TabText_ForPlayer_1         = * ; 
                            .byte $30       ; StartPosX
                            .byte $68       ; StartPosY
                            .byte YELLOW    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "f"       ; Text: for player 1
                            .byte "o"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte "p"       ; 
                            .byte "l"       ; 
                            .byte "a"       ; 
                            .byte "y"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte "1" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00 ; EndOfText
                            
TabText_ForPlayer_2         = * ; 
                            .byte $30       ; StartPosX
                            .byte $80       ; StartPosY
                            .byte ORANGE    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "f"       ; Text: for player 2
                            .byte "o"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte "p"       ; 
                            .byte "l"       ; 
                            .byte "a"       ; 
                            .byte "y"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte "2" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleMapHandler          Does    : display the current castle map progress / blink the entry door arrow
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleMapHandler           .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
MapHandler_Start            jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
                            
                            lda #BLACK                      ; 
                            sta SP0COL                      ; VIC($D027) Color Sprite 0
                            sta SP1COL                      ; VIC($D028) Color Sprite 1
                            
                            lda #$00                        ; get initial value
                            sta TabWrkMap_Player_Num        ; set actual player number - start with player #1
; --------------------------------------------------------------------------------------------------------------------- ;
; init the castle map arrow sprites and draw the castle map header rows for the active players
; --------------------------------------------------------------------------------------------------------------------- ;
InitNextMapHeaderAndArrow   ldx TabWrkMap_Player_Num        ; get actual player number
                            lda TabWrkPlayer_Room_Left,x    ; get flag this player left the room
                            cmp #TabWrkPlayer_Room_Left_Yes ; test with player has left the room
                            beq SetTargetRoomDataPtr        ; check: EQ - yes: left the room
                            
                            jmp SetPlayerNext               ; set next player
; --------------------------------------------------------------------------------------------------------------------- ;
; set castle data pointer to selected room definition entry
; --------------------------------------------------------------------------------------------------------------------- ;
SetTargetRoomDataPtr        lda CC_GameDataVar_TargRoom,x   ; get player target room number from castle data variables
                            jsr CastleRoomDataPointerSet    ; set the room data pointer to the requested entry in the target data store
; --------------------------------------------------------------------------------------------------------------------- ;
; mark this room as visited
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Room_Map_Status         ; get offset room status
                            lda (CCZ_RoomListDataPtr),y     ; get room status
                            ora TabFlagRoom_Visited         ; insert flag room visited
                            sta (CCZ_RoomListDataPtr),y     ; set new room status
; --------------------------------------------------------------------------------------------------------------------- ;
; init castle door data pointer to target room
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_TargDoor,x   ; get this players start door number from castle data variables
                            jsr CastleDoorDataPointerSet    ; set the door address pointer to the requested door data area / set the door count
; --------------------------------------------------------------------------------------------------------------------- ;
; get wall of target door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_MapWall            ; get offset door wall location
                            lda (CCZ_DoorDataPtr),y         ; get door wall location
                            and #CC_Door_MapWall_Mask       ; isolate door wall location
                            sta TabWrkMap_Door_Wall         ; set actual map door wall location
; --------------------------------------------------------------------------------------------------------------------- ;
; get a free map arrow sprite work area block
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr SpriteGetFree_WA_Block      ; find and initialize the next free sprite work area block
                            txa                             ; get sprite WA block offset
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate map arrow sprite number from sprite work area block offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
                            lsr a                           ; /32 = sprite number
                            sta TabWrkMap_Sprite_Num        ; set actual map arrow sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; set map arrow PosX to the target map room door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Room_Map_PosX           ; get offset Room map PosX
                            lda (CCZ_RoomListDataPtr),y     ; get Room PosX from game work room data buffer start ($7900)
                            
                            ldy #CC_Door_MapOffX            ; get offset for offset map Door PosX 
                            clc                             ; 
                            adc (CCZ_DoorDataPtr),y         ; add Door PosY offset from pointer to start of castle room door data
                            
                            clc                             ; 
                            ldy TabWrkMap_Door_Wall         ; 
                            adc TabMap_Door_PosX_Off,y      ; add PosX offset for the selected wall
                            
                            sec                             ; 
                            sbc #$04                        ; correct sprite PosX
                            asl a                           ; *2
                            
                            ldy TabWrkMap_Sprite_Num        ; get actual map arrow sprite number for table offset
                            sta CCZ_VIC_SPnX_Long,y         ; set IRQ work register value - sprite PosX
                            
                            bcc GetSpriteMsbPosX            ; check: multiplication PosX overflow - no
; --------------------------------------------------------------------------------------------------------------------- ;
; set MSB for PosX of the selected map arrow sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSprt_VIC_BitNum,y        ; get this sprite bit posi in one of the VIC sprite registers
                            ora CCZ_VIC_MSIGX               ; set MSB X-Pos for selected sprite
                            jmp SetSpriteMsbPosX            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteMsbPosX            lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits for clear
                            and CCZ_VIC_MSIGX               ; MSB X-Pos Sprites 0-7
                            
SetSpriteMsbPosX            sta CCZ_VIC_MSIGX               ; set IRQ work register value - MSB X-Pos Sprites 0-7
; --------------------------------------------------------------------------------------------------------------------- ;
; set map arrow PosY to the target map room door
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldy #CC_Room_Map_PosY           ; get offset Room map PosY
                            lda (CCZ_RoomListDataPtr),y     ; get Room PosX from game work room data buffer start ($7900)
                            
                            ldy #CC_Door_MapOffY            ; get offset for offset map Door PosY
                            adc (CCZ_DoorDataPtr),y         ; add Door PosY offset from pointer to start of castle room door data
                            
                            clc                             ; 
                            ldy TabWrkMap_Door_Wall         ; 
                            adc TabMap_Door_PosY_Off,y      ; add PosY offset for the selected wall
                            
                            clc                             ; 
                            adc #$32                        ; correct sprite PosY
                            
                            ldy TabWrkMap_Sprite_Num        ; get actual map arrow sprite number for table offset
                            sta CCZ_VIC_SPnY_Long,y         ; set IRQ work register value - sprite PosY
                            
                            ldy TabWrkMap_Door_Wall         ; 
                            lda TabMap_Sprite_ArrowDir_Num,y; get arrow sprite number for the selected wall
                            sta CC_WA_Sprite_Num,x          ; update sprite WA with sprite num
                            
                            jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
                            
                            ldy TabWrkMap_Sprite_Num        ; get actual map arrow sprite number for table offset
                            lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            ora CCZ_VIC_SPENA               ; 
                            sta CCZ_VIC_SPENA               ; set IRQ work register value - enable sprite
; --------------------------------------------------------------------------------------------------------------------- ;
; color and output map text "ONE UP" or "TWO UP"
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkMap_Player_Num        ; get actual player number
                            ldx CC_GameDataVar_NumLives,y   ; get player number of lives from castle data variables
                            lda TabMap_Lives_Color_Num - $01,x ; get map text color according to number of lives left
                            sta TabText_OneUp_Color         ; set text color p1
                            sta TabText_TwoUp_Color         ; set text color p2
                            
                            tya                             ; 
                            asl a                           ; player number *2 for address word length
                            tax                             ; 
                            
                            lda TabMap_Text_GameType_Adr + $00,x ; get map text address
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda TabMap_Text_GameType_Adr + $01,x ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawText                    ; write out "ONE UP" or "TWO UP"
; --------------------------------------------------------------------------------------------------------------------- ;
; output actual castle process time for the selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; get player number
                            asl a                           ; *2
                            asl a                           ; *4 - length of time bytes per player
; --------------------------------------------------------------------------------------------------------------------- ;
; set game data pointer to the actual players castle process time
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #<CC_GameDataVar_Times - CC_GameDataBuf ; get offset Lo of castle time data in castle data variables
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>CC_GameDataVar_Times - CC_GameDataBuf ; get offset Hi of castle time data in castle data variables
                            adc #>CC_GameDataBuf            ; add game work data base address
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr CastleTimeItemFillHandler   ; fill the TabDataCastleTimeFrame item with time digit chars
                            
                            clc                             ; 
                            lda TabMapTimeFrame_PosX,y      ; 
                            adc #$04 * $02                  ; add room double draw grid width
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda #$10                        ; get room double draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_TimeFrame          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; continue with next player
; --------------------------------------------------------------------------------------------------------------------- ;
SetPlayerNext               inc TabWrkMap_Player_Num        ; select player #2
                            
                            lda TabWrkMap_Player_Num        ; get actual player number
                            cmp #$02                        ; test max + $01 
                            beq DrawMapRoom                 ; check: EQ - yes: done - draw the rooms
                            
                            jmp InitNextMapHeaderAndArrow   ; continue with next players header and target arrow init
; --------------------------------------------------------------------------------------------------------------------- ;
; draw only the already visited rooms of the castle map - hide all others
; --------------------------------------------------------------------------------------------------------------------- ;
DrawMapRoom                 jsr CastleMapRoomDraw           ; draw the visited rooms on the castle room map
; --------------------------------------------------------------------------------------------------------------------- ;
; init the map arrow blink phase
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabFlagArrow_Phase_Black   ; get initial value
                            sta TabFlagArrow_Phase          ; flag black map arrow phase
; --------------------------------------------------------------------------------------------------------------------- ;
; init room status for both players
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkPlayer_Room_Enter_Yes; get initial value
                            sta TabWrkPlayer_Room_Enter_P1  ; 
                            sta TabWrkPlayer_Room_Enter_P2  ; 
                            
                            lda TabWrkPlayer_Room_Left_P1   ; 
                            cmp #TabWrkPlayer_Room_Left_Yes ; test if player #1 has left the room
                            beq SetFlagNotEnter_P1          ; check: EQ - yes
                            
                            lda TabWrkPlayer_Room_Left_P2   ; 
                            cmp #TabWrkPlayer_Room_Left_Yes ; test if player #2 has left the room
                            bne SetMapArrowSprite_Black     ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag player #2 does not enter the room
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkPlayer_Room_Enter_No ; 
                            sta TabWrkPlayer_Room_Enter_P2  ; 
                            
                            jmp SetMapArrowSprite_Black     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag player #1 does not enter the room
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagNotEnter_P1          lda #TabWrkPlayer_Room_Enter_No ; 
                            sta TabWrkPlayer_Room_Enter_P1  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; care for the different player map arrow blink phases
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkPlayer_Room_Left_P2   ; 
                            cmp #TabWrkPlayer_Room_Left_Yes ; test if player #2 has left the room
                            bne SetMapArrowSprite_Black     ; check: EQ - no
                            
                            lda #TabWrkPlayer_Room_Enter_No ; 
                            sta TabWrkPlayer_Room_Enter_P2  ; 
                            
                            lda CC_GameDataVar_TargDoor_P1  ; get player #1 start door number from castle data vars
                            cmp CC_GameDataVar_TargDoor_P2  ; test with player #2 start door number
                            bne SetMapArrowSprite_Black     ; check: NE - yes: both players enter different rooms
; --------------------------------------------------------------------------------------------------------------------- ;
; flag next map arrow blink phase
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabFlagArrow_Phase_White   ; 
                            sta TabFlagArrow_Phase          ; flag colored map arrow phase
; --------------------------------------------------------------------------------------------------------------------- ;
; init map arrow blink phase #1 for both players
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #WHITE                      ; 
                            sta SP0COL                      ; VIC($D027) Color Sprite 0
                            sta SP1COL                      ; VIC($D028) Color Sprite 1
                            
                            jmp SetScreenDisplay_On         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init map arrow blink phase #2 for both players
; --------------------------------------------------------------------------------------------------------------------- ;
SetMapArrowSprite_Black     lda #BLACK                      ; 
                            sta SP0COL                      ; VIC($D027) Color Sprite 0
                            sta SP1COL                      ; VIC($D028) Color Sprite 1
; --------------------------------------------------------------------------------------------------------------------- ;
; redisplay the now prepared screen
; --------------------------------------------------------------------------------------------------------------------- ;
SetScreenDisplay_On         lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; init player map and input values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabFlagMap_Display_Yes     ; 
                            sta TabFlagMap_Display          ; set flag start of map display
                            
                            lda #TabWrkKey_Restore_No       ; 
                            sta TabWrkKey_Restore           ; init RESTORE key flag
; --------------------------------------------------------------------------------------------------------------------- ;
; blink time player #1 slightly differs from blink time player #2 - but arrow #2 nevertheless gets disturbed by arrow #1
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabMapArrow_Blink_Time_P1   ; get initial value
                            sta TabWrkArrow_Blink_Time_P1   ; init actual map arrow blink time for player #1
                            
                            lda TabMapArrow_Blink_Time_P2   ; get initial value
                            sta TabWrkArrow_Blink_Time_P2   ; init actual map arrow blink time for player #2
                            
                            lda #$00                        ; get initial value
                            sta TabWrkMap_Player_Num        ; start with player #1
; --------------------------------------------------------------------------------------------------------------------- ;
; start of input loop - wait for player input - meanwhile blink the map arrow
; --------------------------------------------------------------------------------------------------------------------- ;
BlinkNextMapArrowWaitInput  lda #$01                        ; get initial value
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            
                            ldx TabWrkMap_Player_Num        ; get actual player number
                            
                            lda TabFlagArrow_Phase          ; get flag actual map arrow phase
                            cmp #TabFlagArrow_Phase_White   ; test colored
                            beq CheckKey_Restore            ; check: EQ - yes
                            
                            dec TabWrkArrow_Blink_Time,x    ; dec actual map arrow blink time
                            bne CheckKey_Restore            ; check: min - no
; --------------------------------------------------------------------------------------------------------------------- ;
; reinitialze the map arrow blink time for the selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabMapArrow_Blink_Time,x    ; get initial value
                            sta TabWrkArrow_Blink_Time,x    ; init actual map arrow blink time
                            
                            cpx #$00                        ; test player number 
                            beq FlipArrowColor_P1           ; check: player #1 - yes
                            
                            lda TabWrkPlayer_Room_Left_P1   ; 
                            cmp #TabWrkPlayer_Room_Left_Yes ; test if player #1 has left the room
                            beq FlipArrowColor_P2           ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; flip map arrow phase color for sprite #1 - set for player #1 and #2 if only one will enter the room
; --------------------------------------------------------------------------------------------------------------------- ;
FlipArrowColor_P1           lda SP0COL                      ; VIC($D027) Color Sprite 0
                            eor #WHITE                      ; flip map arrow color player #1
                            sta SP0COL                      ; VIC($D027) Color Sprite 0
                            
                            jmp CheckKey_Restore            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; flip map arrow phase color for sprite #2 - set if both players will enter the room
; --------------------------------------------------------------------------------------------------------------------- ;
FlipArrowColor_P2           lda SP1COL                      ; VIC($D028) Color Sprite 1
                            eor #WHITE                      ; flip map arrow color player #2
                            sta SP1COL                      ; VIC($D028) Color Sprite 1
; --------------------------------------------------------------------------------------------------------------------- ;
; check RESTORE key for end of game 
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_Restore            lda TabWrkKey_Restore           ; 
                            cmp #TabWrkKey_Restore_Yes      ; test with restore key pressed
                            bne SetPlayerNum                ; check: NE - yes: bypass end of game
; --------------------------------------------------------------------------------------------------------------------- ;
; end the game
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkKey_Restore_No       ; get initial value
                            sta TabWrkKey_Restore           ; reset pressed key
                            
                            lda #TabFlagMap_Display_No      ; 
                            sta TabFlagMap_Display          ; set flag end of map display
                            
                            jmp MainLoop                    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check input for selected player
; --------------------------------------------------------------------------------------------------------------------- ;
SetPlayerNum                txa                             ; get actual player number
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input
; --------------------------------------------------------------------------------------------------------------------- ;
; eventually halt the game
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkFlag_Force_IRQ        ; get flag force an IRQ
                            cmp #TabWrkFlag_Force_IRQ_Yes   ; test with flag force an endless IRQs
                            bne CheckKey_Stop               ; always - TabWrkFlag_Force_IRQ_Yes never set (hopefully)
; --------------------------------------------------------------------------------------------------------------------- ;
; halt the game - code never reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrk_NeverCalled_Val_Yes ; 
                            sta TabWrk_NeverCalled_Val      ; flag never set
                            
                            jsr GameForceEndlessIRQ         ; endlessly execute BRK instructions
                            jmp MapHandler_Start            ; they never come back
; --------------------------------------------------------------------------------------------------------------------- ;
; check STOP key to resume a game
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_Stop               lda TabWrkInput_Key_Stop        ; 
                            cmp #TabWrkInput_Key_Stop_Yes   ; test STOP key pressed
                            bne CheckJoystick_Fire          ; check: pressed - yes
                            
                            jsr CastleDataSaveFileGame      ; save an ongoing game to a file on an user disk
                            jmp MapHandler_Start            ; restart map handler
; --------------------------------------------------------------------------------------------------------------------- ;
; check player interaction
; --------------------------------------------------------------------------------------------------------------------- ;
CheckJoystick_Fire          lda TabWrkInput_Joy_Fire        ; 
                            beq CheckFlagEnter_P1           ; check: pressed - no
                            
                            lda #TabWrkPlayer_Room_Enter_Yes; 
                            sta TabWrkPlayer_Room_Enter,x   ; set flag selected player wants to enter
                            
CheckFlagEnter_P1           lda TabWrkPlayer_Room_Enter_P1  ; 
                            cmp #TabWrkPlayer_Room_Enter_Yes; test player player #1 wants to enter the room
                            bne FlipPlayerNum               ; check: EQ - no
                            
                            lda TabWrkPlayer_Room_Enter_P2  ; 
                            cmp #TabWrkPlayer_Room_Enter_Yes; test player player #2 wants to enter the room
                            beq WaitPlayerInput             ; check: EQ - yes
                            
FlipPlayerNum               lda TabWrkMap_Player_Num        ; get actual player number
                            eor #$01                        ; flip actual player number
                            sta TabWrkMap_Player_Num        ; set new actual player number
; --------------------------------------------------------------------------------------------------------------------- ;
; wait a short while
; --------------------------------------------------------------------------------------------------------------------- ;
WaitSomeTime                lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne WaitSomeTime                ; check: 
                            
                            jmp BlinkNextMapArrowWaitInput  ; continue waiting for player
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for input of player #1 or player #2
; --------------------------------------------------------------------------------------------------------------------- ;
WaitPlayerInput             lda #$00                        ; get player number #1
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input
                            
                            lda TabWrkInput_Joy_Fire        ; 
                            bne WaitPlayerInput             ; check: pressed - no: continue waiting
                            
                            lda #$01                        ; get player number #2
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input
                            
                            lda TabWrkInput_Joy_Fire        ; 
                            bne WaitPlayerInput             ; check: pressed - no: continue waiting
; --------------------------------------------------------------------------------------------------------------------- ;
; a player got active - init enter room ping - end the map display and start the room
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #NumSfx_MapPing             ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
                            
                            lda #TabFlagMap_Display_No      ; 
                            sta TabFlagMap_Display          ; set flag end of map display
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkPlayer_Room_Left       = *      ; player has exited a room to map
TabWrkPlayer_Room_Left_P1   .byte $a0 ; 
TabWrkPlayer_Room_Left_P2   .byte $a0 ; 
TabWrkPlayer_Room_Left_Yes      = $01 ; 
TabWrkPlayer_Room_Left_No       = $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagArrow_Phase          .byte $ca ; actual castle map arrow phase
TabFlagArrow_Phase_Black        = $00 ; 
TabFlagArrow_Phase_White        = $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkPlayer_Room_Enter     = *       ; player enters a room
TabWrkPlayer_Room_Enter_P1  .byte $a0 ; 
TabWrkPlayer_Room_Enter_P2  .byte $af ; 
TabWrkPlayer_Room_Enter_Yes     = $01 ; 
TabWrkPlayer_Room_Enter_No      = $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkArrow_Blink_Time      = *       ; actual player castle map arrow blink time
TabWrkArrow_Blink_Time_P1   .byte $80 ; 
TabWrkArrow_Blink_Time_P2   .byte $cf ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagMap_Display          .byte $00 ; display the castle map
TabFlagMap_Display_Yes          = $01 ; 
TabFlagMap_Display_No           = $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; map arrows are separated by a different blink time - but the arrow of player #2 gets still disturbed
; --------------------------------------------------------------------------------------------------------------------- ;
TabMapArrow_Blink_Time      = *       ; player castle map arrow blink time
TabMapArrow_Blink_Time_P1   .byte $06 ; 
TabMapArrow_Blink_Time_P2   .byte $0f ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabMapTimeFrame_PosX        = *       ; 
                            .byte $10 ; 
                            .byte $74 ; 
                            .byte $17 ; 
                            .byte $18 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkMap_Player_Num        .byte $ff ; actual player number
TabWrkMap_Sprite_Num        .byte $a0 ; actual map arrow sprite number
TabWrkMap_Door_Wall         .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabMap_Door_PosX_Off        = *       ; sprite PosX offset for the selected wall
                            .byte $ff ; -01 - North
                            .byte $02 ;  02 - East 
                            .byte $ff ; -01 - South
                            .byte $fb ; -05 - West 
; --------------------------------------------------------------------------------------------------------------------- ;
TabMap_Door_PosY_Off        = *       ; sprite PosY offset for the selected wall
                            .byte $f6 ; -10 - North
                            .byte $fe ; -02 - East 
                            .byte $06 ;  06 - South
                            .byte $fe ; -02 - West 
; --------------------------------------------------------------------------------------------------------------------- ;
TabMap_Sprite_ArrowDir_Num  = * ; 
                            .byte SpriteNum_Arrow_Do ; point South
                            .byte SpriteNum_Arrow_Le ; point West
                            .byte SpriteNum_Arrow_Up ; point North
                            .byte SpriteNum_Arrow_Ri ; point East
; --------------------------------------------------------------------------------------------------------------------- ;
TabMap_Lives_Color_Num      = *            ; text color depending on the actual number of lives
                            .byte LT_RED   ; 
                            .byte YELLOW   ; 
                            .byte LT_GREEN ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabMap_Text_GameType_Adr    = * ; 
                            .word TabText_OneUp ; 
                            .word TabText_TwoUp ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_OneUp               = * ; 
                            .byte $10       ; StartPosX
                            .byte $00       ; StartPosY
TabText_OneUp_Color         .byte WHITE     ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "o"       ; Text: one up
                            .byte "n"       ; 
                            .byte "e"       ; 
                            .byte " "       ; 
                            .byte "u"       ; 
                            .byte "P" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOFText
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_TwoUp               = * ; 
                            .byte $74       ; StartPosX
                            .byte $00       ; StartPosY
TabText_TwoUp_Color         .byte WHITE     ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "t"       ; Text: two up
                            .byte "w"       ; 
                            .byte "o"       ; 
                            .byte " "       ; 
                            .byte "u"       ; 
                            .byte "p" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00 ; EndOFText
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleMapRoomDraw         Does    : draw the visited rooms on the castle room map
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleMapRoomDraw          .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set up room data pointer to the castle room definition list
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_GameData_Room          ; 
                            sta CCZ_RoomListDataPtr_Lo      ; 
                            lda #>CC_GameData_Room          ; 
                            sta CCZ_RoomListDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; loop through the room definition list and check if a room is visited
; --------------------------------------------------------------------------------------------------------------------- ;
TryNextMapRoomInList        ldy #CC_Room_Map_Status         ; get offset room status
                            lda (CCZ_RoomListDataPtr),y     ; get room status
                            bit TabFlagRoom_EndOfList       ; test with flag end of room definition list
                            beq CheckMapRoomFlag_Visit      ; check: EQ - no: check if visited already
                            
                            jmp CastleMapRoomDrawX          ; done - all castle rooms processed
; --------------------------------------------------------------------------------------------------------------------- ;
; check if map room has to be dislayed
; --------------------------------------------------------------------------------------------------------------------- ;
CheckMapRoomFlag_Visit      bit TabFlagRoom_Visited         ; test with flag room already visited
                            bne IniMapRoomDraw              ; check: visited - yes: paint this room on the map
                            
                            jmp AdvanceRoomDataPtr          ; do not paint this unvisited rooms - try next room definition list entry
; --------------------------------------------------------------------------------------------------------------------- ;
; get map rooms initial values
; --------------------------------------------------------------------------------------------------------------------- ;
IniMapRoomDraw              and #CC_Room_Map_Status_Color   ; isolate this room map color
                            sta TabDataMapRoomFillColor     ; set this map filler item color
                            
                            ldy #CC_Room_Map_PosX           ; get offset room map PosX
                            lda (CCZ_RoomListDataPtr),y     ; get this room map PosX
                            sta TabWrkMap_PosX              ; set map PosX
                            
                            ldy #CC_Room_Map_PosY           ; get offset room map PosY
                            lda (CCZ_RoomListDataPtr),y     ; get this room map PosY
                            sta TabWrkMap_PosY              ; set map PosY
                            
                            ldy #CC_Room_Map_Size           ; get offset room map size
                            lda (CCZ_RoomListDataPtr),y     ; get this room map size  ..xxxyyy
                            and #CC_Room_Map_Size_Height_Mask ; isolate height
                            sta TabWrkMap_Size_Height_Sav   ; save original room height
                            
                            lda (CCZ_RoomListDataPtr),y     ; get this room map size  ..xxxyyy
                            lsr a                           ; ...xxxyy - shift width part to height
                            lsr a                           ; ....xxxy
                            lsr a                           ; .....xxx
                            and #CC_Room_Map_Size_Height_Mask ; isolate width
                            sta TabWrkMap_Size_Width_Sav    ; save original room width
; --------------------------------------------------------------------------------------------------------------------- ;
; set up parms for the RoomItemDraw routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda TabWrkMap_PosY              ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_MapRoomFill        ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda TabWrkMap_Size_Height_Sav   ; get original room height
                            sta TabWrkMap_Size_Height       ; set actual room heigth
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st step - draw the full map room filler for the given room width and height - do not care for surrounding walls
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextMapRoomWidth         lda TabWrkMap_Size_Width_Sav    ; get original room width
                            sta TabWrkMap_Size_Width        ; init actual room width
                            
                            lda TabWrkMap_PosX              ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
DrawNextMapRoomFiller       jsr RoomItemDraw                ; draw the selected room item
                            
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item type_0 parm: PosX
                            adc #$04                        ; add room draw grid width - advance room filler item
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item type_0 parm: PosX
                            
                            dec TabWrkMap_Size_Width        ; dec actual room width
                            bne DrawNextMapRoomFiller       ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; advance draw row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item type_0 parm: PosY - top of item
                            adc #$08                        ; add room draw grid height - advance room filler item PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set new draw item type_0 parm: PosY
                            
                            dec TabWrkMap_Size_Height       ; dec actual room heigth
                            bne GetNextMapRoomWidth         ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd step - draw the WHITE map room wall frame for the given room width and height - frame the map room filler of 1st step
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare draw northern wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMap_PosX              ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX - northern wall
                            
                            lda TabWrkMap_PosY              ; 
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY - northern wall
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda TabWrkMap_Size_Width_Sav    ; get original room width
                            sta TabWrkMap_Size_Width        ; set actual northern wall width
                            
                            lda #ItemNum_MapRoomWall_NS     ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number - wall North/South
; --------------------------------------------------------------------------------------------------------------------- ;
; draw northern wall frame tile
; --------------------------------------------------------------------------------------------------------------------- ;
PaintNextRoomWall_North     jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance draw northern wall column
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            adc #$04                        ; add room draw grid width - advance northern wall item PosX
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set new draw item type_1 parm: PosX
                            
                            dec TabWrkMap_Size_Width        ; dec actual room width
                            bne PaintNextRoomWall_North     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare draw southern wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMap_PosX              ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX - southern wall
                            
                            lda TabWrkMap_Size_Height_Sav   ; get original room height
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - draw item height
                            clc                             ; 
                            adc TabWrkMap_PosY              ; calc bottom PosY
                            
                            sec                             ; 
                            sbc #TabDataMapRoomWall_NS_Len  ; step draw PosX up in southern wall
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set new draw item type_1 parm: PosY
                            
                            lda TabWrkMap_Size_Width_Sav    ; get original room width
                            sta TabWrkMap_Size_Width        ; init actual southern wall width
; --------------------------------------------------------------------------------------------------------------------- ;
; draw southern wall frame tile
; --------------------------------------------------------------------------------------------------------------------- ;
PaintNextRoomWall_South     jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance draw southern wall column
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            adc #$04                        ; add room draw grid width - advance southern wall one position right
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            dec TabWrkMap_Size_Width        ; dec actual room width
                            bne PaintNextRoomWall_South     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare draw western wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMap_PosX              ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX - western wall
                            
                            lda TabWrkMap_PosY              ; 
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY - western wall
                            
                            lda #ItemNum_MapRoomWall_W      ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number - western wall
                            
                            lda TabWrkMap_Size_Height_Sav   ; get original room height
                            sta TabWrkMap_Size_Width        ; set actual western wall height
; --------------------------------------------------------------------------------------------------------------------- ;
; draw western wall frame tile
; --------------------------------------------------------------------------------------------------------------------- ;
PaintNextRoomWall_West      jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance draw western wall row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosY ; get draw item type_1 parm: PosY
                            adc #$08                        ; add room draw grid height - advance western wall item PosY
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set new draw item type_1 parm: PosY
                            
                            dec TabWrkMap_Size_Width        ; dec actual room width
                            bne PaintNextRoomWall_West      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare draw eastern wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMap_Size_Width_Sav    ; get original room width
                            asl a                           ; *2
                            asl a                           ; *4 - room draw grid width
                            clc                             ; 
                            adc TabWrkMap_PosX              ; calc max PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; step eastern wall PosX one position back from the end of the filler area
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc #$04                        ; overlay the eastern end of painted room filler item
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set new draw item type_1 parm: PosX - eastern wall
                            
                            lda TabWrkMap_PosY              ; 
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY - eastern wall
                            
                            lda #ItemNum_MapRoomWall_E      ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number - eastern wall
                            
                            lda TabWrkMap_Size_Height_Sav   ; get original room height
                            sta TabWrkMap_Size_Width        ; set actual eastern wall height
; --------------------------------------------------------------------------------------------------------------------- ;
; draw eastern wall tile
; --------------------------------------------------------------------------------------------------------------------- ;
PaintNextRoomWall_East      jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance draw eastern wall row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosY ; get draw item type_1 parm: PosY
                            adc #$08                        ; add room draw grid height - advance eastern wall item PosY
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            dec TabWrkMap_Size_Width        ; dec actual room width
                            bne PaintNextRoomWall_East      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init draw of the room doors
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get the 1st room number
                            jsr CastleDoorDataPointerSet    ; set the door address pointer to the requested door data area / set the door count
                            
                            lda TabWrkCastleRoomDoorCount   ; set in CastleDoorDataPointerSet
                            sta TabWrkMap_DoorCount         ; set room door count
; --------------------------------------------------------------------------------------------------------------------- ;
; 3rd step - draw the room doors into their wall position by deleting the wall door tile
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextRoomMapDoorCount     lda TabWrkMap_DoorCount         ; 
                            bne DrawThisRoomsDoors          ; check: min - no: paint doors into wall
; --------------------------------------------------------------------------------------------------------------------- ;
; end of this room - advance pointer to next room in list - try next room
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceRoomDataPtr          clc                             ; 
                            lda CCZ_RoomListDataPtr_Lo      ; 
                            adc #CC_Room_Item_Len           ; add length of room item data
                            sta CCZ_RoomListDataPtr_Lo      ; 
                            bcc TryNextRoom                 ; check: overflow - no
                            inc CCZ_RoomListDataPtr_Hi      ; 
                            
TryNextRoom                 jmp TryNextMapRoomInList        ; continue with the next room entry
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the map room wall doors
; --------------------------------------------------------------------------------------------------------------------- ;
DrawThisRoomsDoors          ldy #CC_Door_MapWall            ; get offset room door wall
                            lda (CCZ_DoorDataPtr),y         ; get room door wall
                            and #CC_Door_MapWall_Mask       ; isolate wall number
                            bne ChkDoorWall_South           ; check: northern wall - no: check southern
; --------------------------------------------------------------------------------------------------------------------- ;
; init door PosY in northern wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMap_PosY              ; 
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY - northern wall
                            
                            jmp IniDoorWallPosX_NS          ; set door PosX left or right version
; --------------------------------------------------------------------------------------------------------------------- ;
; check door in southern wall
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDoorWall_South           cmp #CC_Door_MapWall_South      ; test southern wall
                            bne IniDoorWallPosY_EW          ; check: southern - no: care for western and eastern doors
; --------------------------------------------------------------------------------------------------------------------- ;
; init door PosY in southern wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMap_Size_Height_Sav   ; get original room height
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - item height
                            clc                             ; 
                            adc TabWrkMap_PosY              ; calc bottom PosY
                            
                            sec                             ; 
                            sbc #TabDataMapRoomWall_NS_Len  ; step draw PosX up in southern wall
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY - southern wall
; --------------------------------------------------------------------------------------------------------------------- ;
; init northern/southern door PosX
; --------------------------------------------------------------------------------------------------------------------- ;
IniDoorWallPosX_NS          lda TabWrkMap_PosX              ; 
                            
                            ldy #CC_Door_MapOffX            ; 
                            clc                             ; 
                            adc (CCZ_DoorDataPtr),y         ; pointer to start of castle room door data
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; care for a left or right version
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$02                        ; isolate half of item width
                            beq GetDoorWallVersion_Left     ; check: left half - yes: get wall door version left
                            
                            eor TabWrkDraw_T1_Parm_ItemPosX ; flip draw item type_1 parm: PosX - clear bit0 and bit1
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX - set right PosX
                            
                            lda #ItemNum_MapRoomDoorRi_NS   ; get item number: door in northern/southern wall right version
                            jmp SetWallDoorItemNum          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetDoorWallVersion_Left     lda #ItemNum_MapRoomDoorLe_NS   ; get item number: door in northern/southern wall left version
                            jmp SetWallDoorItemNum          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init eastern/western door PosY
; --------------------------------------------------------------------------------------------------------------------- ;
IniDoorWallPosY_EW          pha                             ; save wall number
                            
                            lda TabWrkMap_PosY              ; 
                            clc                             ; 
                            ldy #CC_Door_MapOffY            ; 
                            adc (CCZ_DoorDataPtr),y         ; pointer to start of castle room door data
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            pla                             ; restore wall number
; --------------------------------------------------------------------------------------------------------------------- ;
; check door in western wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CC_Door_MapWall_West       ; test western door
                            beq SetWesternDoorPosX          ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; init eastern door PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMap_Size_Width_Sav    ; get original room width
                            asl a                           ; *2
                            asl a                           ; *4 - room draw grid width
                            clc                             ; 
                            adc TabWrkMap_PosX              ; calc max PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; step eastern wall PosX one position back from the end of the filler area
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc #$04                        ; prepare to overwrite eastern end of painted room filler
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX - eastern wall
                            
                            lda #ItemNum_MapRoomDoor_W      ; get item number: door in western wall
                            jmp SetWallDoorItemNum          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init western door PosX
; --------------------------------------------------------------------------------------------------------------------- ;
SetWesternDoorPosX          lda TabWrkMap_PosX              ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            lda #ItemNum_MapRoomDoor_E      ; get item number: door in eastern wall
; --------------------------------------------------------------------------------------------------------------------- ;
; set selected door wall item number
; --------------------------------------------------------------------------------------------------------------------- ;
SetWallDoorItemNum          sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number - selected wall door
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the door into the prepared wall position
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer to next door in list
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DoorDataPtr_Lo          ; pointer to start of castle room door data
                            adc #CC_Room_Item_Len           ; 
                            sta CCZ_DoorDataPtr_Lo          ; pointer to start of castle room door data
                            bcc DecRoomMapDoorCount         ; check: overflow - no
                            inc CCZ_DoorDataPtr_Hi          ; pointer to start of castle room door data
                            
DecRoomMapDoorCount         dec TabWrkMap_DoorCount         ; dec wall door counter
                            jmp GetNextRoomMapDoorCount     ; continue painting wall doors
; --------------------------------------------------------------------------------------------------------------------- ;
CastleMapRoomDrawX          pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkMap_DoorCount         = *       ; 
TabWrkMap_Size              = *       ; 
TabWrkMap_Size_Width        .byte $a0 ; actual room width
TabWrkMap_Size_Height       .byte $b1 ; actual room heigth
TabWrkMap_PosX              .byte $a0 ; 
TabWrkMap_PosY              .byte $8c ; 
TabWrkMap_Size_Width_Sav    .byte $a0 ; original room width
TabWrkMap_Size_Height_Sav   .byte $a0 ; original room height
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleRoomDrawPrepare     Does    : set up for subroutine CastleRoomDrawHandler
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleRoomDrawPrepare      .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
; --------------------------------------------------------------------------------------------------------------------- ;
; init move control memory
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_MoveCtrl               ; set move control memory pointer
                            sta CCZ_IniMoveCtrlPtr_Lo       ; 
                            lda #>CC_MoveCtrl               ; 
                            sta CCZ_IniMoveCtrlPtr_Hi       ; 
                            
                            ldy #$00                        ; init page offset
GetNextIniVal               lda #$00                        ; 
SetNextIniVal               sta (CCZ_IniMoveCtrlPtr),y      ; init next memory page
                            
                            iny                             ; inc page offset
                            bne SetNextIniVal               ; check: max - no: continue
                            
                            inc CCZ_IniMoveCtrlPtr_Hi       ; inc page number
                            
                            lda CCZ_IniMoveCtrlPtr_Hi       ; 
                            cmp #>CC_MoveCtrl + CC_MoveCtrl_Len ; test max hires pixel rows
                            bcc GetNextIniVal               ; check: LT - yes: continue with next page
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkPlayer_Room_Left_P1   ; 
                            cmp #TabWrkPlayer_Room_Left_Yes ; test if player #1 has left the room to map
                            beq GetPlayer_P1                ; check: EQ - yes: select player #1
                            
                            ldx #$01                        ; get player #2
                            jmp CheckGameMode               ; 
                            
GetPlayer_P1                ldx #$00                        ; get player #1
; --------------------------------------------------------------------------------------------------------------------- ;
; check game mode for the correct target room
; --------------------------------------------------------------------------------------------------------------------- ;
CheckGameMode               lda TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            cmp #TabFlagDataBufAdr_Load     ; test flag castle data load game memory
                            bne GetGameTargetRoomNumber     ; check: NE - yes: game ongoing
                            
                            lda TabWrkDemo_RoomNumber       ; demo ongoing - get demo target room number
                            jmp SetTargetRoomDataPointer    ; 
                            
GetGameTargetRoomNumber     lda CC_GameDataVar_TargRoom,x   ; get player target room number from castle data variables
                            
SetTargetRoomDataPointer    jsr CastleRoomDataPointerSet    ; set the room data pointer to the requested entry in the target data store
; --------------------------------------------------------------------------------------------------------------------- ;
; set floor item color
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Room_Map_Status         ; get offset room status
                            lda (CCZ_RoomListDataPtr),y     ; get room status
                            and #CC_Room_Map_Status_Color   ; isolate room color
                            sta TabDataFloorStart_Color     ; preset room floor start tile color
; --------------------------------------------------------------------------------------------------------------------- ;
; create hires color
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl a                           ; shift color to left nibble
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
                            ora TabDataFloorStart_Color     ; insert preset color to right nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; set the hires color of the different room floor items
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta TabDataFloorStart_Color     ; set the different floor tile colors
                            sta TabDataFloorColor           ; 
                            sta TabDataFloorEndColor        ; 
                            sta TabDataLadderFloorColor_0   ; 
                            sta TabDataLadderFloorColor_2   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set the hires color of the different room trap items
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta TabDataTrapMove_01_Color_0  ; trap part #1a - 1st bottom part
                            sta TabDataTrapMove_01_Color_1  ; 
                            sta TabDataTrapMove_01_Color_2  ; 
                            
                            sta TabDataTrapMove_02_Color_0  ; trap part #1b - 2nd bottom part
                            sta TabDataTrapMove_02_Color_1  ; 
                            sta TabDataTrapMove_02_Color_2  ; 
                            
                            sta TabDataTrapMove_03_Color_0  ; trap part #2a - 1st middle part
                            sta TabDataTrapMove_03_Color_1  ; 
                            sta TabDataTrapMove_03_Color_2  ; 
                            
                            sta TabDataTrapMove_04_Color_0  ; trap part #2b - 2nd middle part
                            sta TabDataTrapMove_04_Color_1  ; 
                            sta TabDataTrapMove_04_Color_2  ; 
                            
                            sta TabDataTrapMove_05_Color_0  ; trap part #3a - 2nd top part
                            sta TabDataTrapMove_05_Color_1  ; 
                            sta TabDataTrapMove_05_Color_2  ; 
                            
                            sta TabDataTrapMove_06_Color_0  ; trap part #3b - 2nd top part
                            sta TabDataTrapMove_06_Color_1  ; 
                            sta TabDataTrapMove_06_Color_2  ; 
                            
                            ldy #TabDataWalkMoveColor_Len   ; init walk length
SetNextWalkColor            sta TabDataWalkMove_01_Color,y  ; set the different moving sidewalk colors
                            sta TabDataWalkMove_02_Color,y  ; 
                            sta TabDataWalkMove_03_Color,y  ; 
                            sta TabDataWalkMove_04_Color,y  ; 
                            
                            dey                             ; dec walk length
                            bpl SetNextWalkColor            ; check: min - no: continue
                            
                            and #CC_Room_Map_Status_Color   ; isolate left color nibble
                            ora #HR_WHITE_BLACK             ; 
                            sta TabDataPoleCoverColor       ; set pole cover color
                            
                            lda TabDataFloorEndColor        ; 
                            and #CC_Room_Map_Status_Color << $04 ; isolate right color nibble
                            ora #HR_BLACK_WHITE             ; 
                            sta TabDataLadderEndColor       ; set the different ladder touching floor colors
                            sta TabDataLadderFloorColor_1   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set this room data door address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Room_Ptr_DoorID_Lo      ; get offset door ID address pointer Lo
                            lda (CCZ_RoomListDataPtr),y     ; get door ID address Lo
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            
                            iny                             ; get offset door ID address pointer Hi
                            lda (CCZ_RoomListDataPtr),y     ; get door ID address Hi
                            sta CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if in demo mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            cmp #TabFlagDataBufAdr_Load     ; test flag castle data game memory
                            bne GoCastleRoomDrawHandler     ; check: demo - no: draw the game room
; --------------------------------------------------------------------------------------------------------------------- ;
; point to demo data in castle load memory
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            adc #>CC_LoadDataBuf - CC_GameDataBuf ; add castle data memory max length 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
GoCastleRoomDrawHandler     jsr CastleRoomDrawHandler       ; control drawing the castle room items
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleRoomHandler         Does    : display room - get player input - handle room items
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleRoomHandler          .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr CastleRoomDrawPrepare       ; set up for subroutine CastleRoomDrawHandler
                            
                            ldx #$00                        ; init player number #1
SearchNextPlayerToEnter     lda TabWrkPlayer_Room_Left,x    ; 
                            cmp #TabWrkPlayer_Room_Left_Yes ; test if the selected player has left the room
                            bne SetNextPlayerNum            ; check: left - yes: try next player
                            
                            stx TabWrkPlayer_InRoom_Num     ; set number of this player in this room
                            jsr PlayerRoomEnter             ; get this player into a room
                            
SetNextPlayerNum            inx                             ; set next player number
                            cpx #$02                        ; test max player number passed
                            bcc SearchNextPlayerToEnter     ; check: LT - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; switch screen on again
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; 
                            sta TabWrkRoom_NoUse            ; <obslete>
                            
                            lda #TabWrkKey_Restore_No       ; 
                            sta TabWrkKey_Restore           ; 
                            
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; care for sprite sprite and sprite item inteaction
; --------------------------------------------------------------------------------------------------------------------- ;
GoCastleRoomActionHandler   jsr CastleRoomActionHandler     ; detect sprite collisions and handle all sprite/object actions
                            
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; weird code to halt the machine - never executed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkFlag_Force_IRQ        ; get flag force an IRQ
                            cmp #TabWrkFlag_Force_IRQ_Yes   ; test force an endless IRQs
                            bne CheckKey_Stop               ; always - TabWrkFlag_Force_IRQ_Yes never set
; --------------------------------------------------------------------------------------------------------------------- ;
; halt the game - code (hopefully) never reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrk_NeverCalled_Val_No  ; 
                            sta TabWrk_NeverCalled_Val      ; 
                            
                            jsr GameForceEndlessIRQ         ; endlessly execute BRK instructions
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check the <STOP> pause game key
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_Stop               lda TabWrkInput_Key_Stop        ; get status STOP key
                            cmp #TabWrkInput_Key_Stop_Yes   ; test with STOP key pressed
                            bne CheckKey_Restore            ; check: EQ - no: check <RESTORE> key
; --------------------------------------------------------------------------------------------------------------------- ;
; pause the game after STOP was pressed
; --------------------------------------------------------------------------------------------------------------------- ;
IniIRQ_Pause                lda #$03                        ; 
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            
WaitIRQ_Pause               lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne WaitIRQ_Pause               ; check: 
                            
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input for playse #1
                            
                            lda TabWrkInput_Key_Stop        ; 
                            cmp #TabWrkInput_Key_Stop_Yes   ; test STOP key pressed
                            beq IniIRQ_Pause                ; check: EQ - yes: continue pause
; --------------------------------------------------------------------------------------------------------------------- ;
; save to freeze the castle play time
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #TabWrkRoom_PauseTime_Len - $01 ; 
SaveNextPlayerTimeVal       lda TODTEN,x                    ; CIA1($DC08) Time of Day Clock Tenths
                            sta TabWrkRoom_PauseTime_P1,x   ; 
                            
                            lda TO2TEN,x                    ; CIA2($DD08) Time of Day Clock Tenths
                            sta TabWrkRoom_PauseTime_P2,x   ; 
                            
                            dex                             ; dec time length
                            bpl SaveNextPlayerTimeVal       ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; pause the game after STOP was pressed
; --------------------------------------------------------------------------------------------------------------------- ;
PauseTheGame                lda #$00                        ; set parm player number #1
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input
                            
                            lda TabWrkInput_Key_Stop        ; 
                            cmp #TabWrkInput_Key_Stop_Yes   ; test STOP key pressed
                            bne PauseTheGame                ; check: pressed - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; pause until STOP key is pressed a 2nd time
; --------------------------------------------------------------------------------------------------------------------- ;
IniIRQ_Count                lda #$03                        ; 
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            
WaitIRQ_Count               lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne WaitIRQ_Count               ; check: 
                            
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input for player #1
                            
                            lda TabWrkInput_Key_Stop        ; get status STOP key
                            cmp #TabWrkInput_Key_Stop_Yes   ; test with STOP key pressed
                            beq IniIRQ_Count                ; check: EQ - no: continue wait
; --------------------------------------------------------------------------------------------------------------------- ;
; restore to continue the castle play time
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #TabWrkRoom_PauseTime_Len - $01 ; 
RestoreNextPlayerTimeVal    lda TabWrkRoom_PauseTime_P1,x   ; 
                            sta TODTEN,x                    ; CIA1($DC08) Time of Day Clock Tenths
                            
                            lda TabWrkRoom_PauseTime_P2,x   ; 
                            sta TO2TEN,x                    ; CIA2($DD08) Time of Day Clock Tenths
                            
                            dex                             ; dec time length
                            bpl RestoreNextPlayerTimeVal    ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; check the <RESTORE> key to kill a player
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKey_Restore            lda TabWrkKey_Restore           ; 
                            cmp #TabWrkKey_Restore_Yes      ; test kill key pressed
                            bne CheckKillPlayer_P1          ; check: kill - yes: try to kill player #1
                            
                            lda #TabWrkKey_Restore_No       ; 
                            sta TabWrkKey_Restore           ; 
                            
                            ldx #$01                        ; start with player #2
CheckKillNextPlayer         lda CC_GameDataVar_Flag,x       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test with flag this player has arrived in room
                            bne TryKill_P1                  ; check: in room - no: try next player
                            
                            lda #CC_GameDataVar_Flag_Hit    ; get flag this player had an accident
                            sta CC_GameDataVar_Flag,x       ; set this player status flag in castle data variables
                            
                            ldy TabWrkPlayer_Sprite_WA,x    ; 
                            lda CC_WA_Sprite_Flag,y         ; 
                            ora TabFlagSprt_Dead            ; insert flag this player is dead
                            sta CC_WA_Sprite_Flag,y         ; 
                            
TryKill_P1                  dex                             ; continue with player #1
                            bpl CheckKillNextPlayer         ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; player kill
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKillPlayer_P1          lda CC_GameDataVar_Flag_P1      ; 
                            cmp #CC_GameDataVar_Flag_InRoom ; test with flag player has arrived in room
                            bne CheckKillPlayer_P2          ; check: in room - no: try player #2
                            
                            lda #CC_GameDataVar_Active_No   ; 
                            sta CC_GameDataVar_Active_P1    ; set player #1 active flag in castle data variables
                            
                            jmp GoCastleRoomActionHandler   ; detect sprite collisions and handle all sprite/object actions
; --------------------------------------------------------------------------------------------------------------------- ;
CheckKillPlayer_P2          lda CC_GameDataVar_Flag_P2      ; 
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne IniCheckPlayerRoomIO        ; check: in room - no: get him in
                            
                            lda #CC_GameDataVar_Active_Yes  ; 
                            sta CC_GameDataVar_Active_P1    ; set player #1 active flag in castle data variables
                            
HandleRoomActions           jmp GoCastleRoomActionHandler   ; detect sprite collisions and handle all sprite/object actions
; --------------------------------------------------------------------------------------------------------------------- ;
; player room in/out
; --------------------------------------------------------------------------------------------------------------------- ;
IniCheckPlayerRoomIO        ldx #$00                        ; init player #1
CheckNextPlayerRoomIO       lda CC_GameDataVar_Flag,x       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_IO_Room; test ongoing room In/Out
                            beq HandleRoomActions           ; check: ongoing - no: care for room actions
                            
                            cmp #CC_GameDataVar_Flag_IO_Start ; test room In/Out start
                            beq HandleRoomActions           ; check: start - no: care for room actions
                            
                            inx                             ; inc player number
                            cpx #$02                        ; test max player number
                            bcc CheckNextPlayerRoomIO       ; check: LT - yes: cintinue
                            
                            lda #$00                        ; <obslete>
                            sta TabWrkRoom_NoUse            ; <obslete>
; --------------------------------------------------------------------------------------------------------------------- ;
; wait until the player death animation or room exit has finished
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$1e                        ; init counter to wait 30 rounds
WaitPlayerDead              jsr CastleRoomActionHandler     ; detect sprite collisions and handle all sprite/object actions
                            
                            dex                             ; dec counter
                            bne WaitPlayerDead              ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkRoom_NoUse            .byte $00 ; <obslete>
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkRoom_PauseTime         = *      ; 
TabWrkRoom_PauseTime_P1      = *      ; 
                            .byte $a8 ; 10th
                            .byte $a0 ; sec
                            .byte $a0 ; min
                            .byte $a0 ; hrs
TabWrkRoom_PauseTime_Len    = * - TabWrkRoom_PauseTime ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkRoom_PauseTime_P2     = *      ; 
                            .byte $a0 ; 10th
                            .byte $a0 ; sec
                            .byte $c5 ; min
                            .byte $a2 ; hrs
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleRoomDrawHandler     Does    : control drawing the castle room items from the castle room data
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleRoomDrawHandler      .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set up the room draw item handler address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextRoomItemAdr          ldy #CC_Room_ItemAdr_Lo         ; get offset room item adr Lo
                            lda (CCZ_DrawItemDataPtr),y     ; get room item address Lo
                            sta smRoomDrawItemAdr_Lo        ; set address draw item routine Lo
                            
                            iny                             ; set offset room item adr Hi
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta smRoomDrawItemAdr_Hi        ; set address draw item routine Hi
; --------------------------------------------------------------------------------------------------------------------- ;
; advance castle room item data pointer behind room item address header
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_Room_ItemAdr_Len        ; add item address length
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc ChkEndOfRoomData            ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
ChkEndOfRoomData            lda smRoomDrawItemAdr_Hi        ; get address draw item routine Hi
                            beq CastleRoomDrawHandlerX      ; check: EoD - yes: done
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch the selected room draw item handler
; --------------------------------------------------------------------------------------------------------------------- ;
smRoomDrawItemAdr           = * + $01                       ; 
smRoomDrawItemAdr_Lo          = smRoomDrawItemAdr + $00     ; 
smRoomDrawItemAdr_Hi          = smRoomDrawItemAdr + $01     ; 
                            jsr smRoomDrawItemAdr           ; call room item display routine
                            
                            jmp GetNextRoomItemAdr          ; get next room item address
; --------------------------------------------------------------------------------------------------------------------- ;
CastleRoomDrawHandlerX      pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawRoomGraphic           Does    : draw the castle room user defined graphic items
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawRoomGraphic            .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this special graphic item
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextGraphic             ldy #CC_Graphic                 ; get offset graphic data status
                            lda (CCZ_DrawItemDataPtr),y     ; get graphic status
                            beq DrawRoomGraphic_Exit        ; check: CC_Graphic_EoD - yes: done
; --------------------------------------------------------------------------------------------------------------------- ;
; draw graphic items until the counter runs out
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta TabWrkGraphic_Item_Count    ; set actual graphic item count
                            
                            ldy #CC_Graphic_ItemNum         ; get offset graphic item number
                            lda (CCZ_DrawItemDataPtr),y     ; get graphic item number
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            ldy #CC_Graphic_PosX            ; get offset graphic item PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get graphic item PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Graphic_PosY            ; get offset graphic item PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get graphic item PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the graphic item
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextGraphic_Item        jsr RoomItemDraw                ; draw the selected room item
                            
                            dec TabWrkGraphic_Item_Count    ; dec actual graphic item count
                            beq AdvanceGraphicItemDataPtr   ; check: min - yes: done
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the graphic item to the next position offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldy #CC_Graphic_Next_OffX       ; get offset for next graphic item PosX
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc (CCZ_DrawItemDataPtr),y     ; add offset for next graphic item PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Graphic_Next_OffY       ; get offset for next graphic item PosY
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc (CCZ_DrawItemDataPtr),y     ; add offset for next graphic item PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            jmp DrawNextGraphic_Item        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next graphic item data entry
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceGraphicItemDataPtr   clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_GraphicItem_Len         ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc DrawNextGraphic             ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jmp DrawNextGraphic             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer behind EndOfGraphicData and exit
; --------------------------------------------------------------------------------------------------------------------- ;
DrawRoomGraphic_Exit        inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne DrawRoomGraphicX            ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawRoomGraphicX            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkGraphic_Item_Count    .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawFloor                 Does    : draw the castle room floors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawFloor                  .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextFloorLength          ldy #CC_Floor_Len               ; get offset floor data status
                            lda (CCZ_DrawItemDataPtr),y     ; get floor data status
                            sta TabWrkFloor_Len             ; save original floor length
                            bne RoomFloor                   ; check: CC_Floor_EoD - no: handle pole
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte CC_Floor_EoD and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawFloorX                  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this floor
; --------------------------------------------------------------------------------------------------------------------- ;
RoomFloor                   ldy #CC_Floor_PosX              ; get offset floor PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get floor PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Floor_PosY              ; get offset floor PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get floor PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #$01                        ; get initial length
                            sta TabWrkFloor_Draw_Len        ; init actual floor length
                            
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                                                              
                            sec                             ; 
                            sbc #$04                        ; subtract global room row start of $10 ($04*$04 grids)
                            sta TabWrkDrawGrid_Col_Num      ; set floor draw grid column number
                            
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw draw grid height
                            sta TabWrkDrawGrid_Row_Num      ; set floor draw grid row number
                            
                            jsr GameSetMoveCtrlDataPtr      ; set the room move control data pointer 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw floor from left to right
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextFloorByte           lda TabWrkFloor_Draw_Len        ; get actual floor length
                            cmp #$01                        ; test floor start
                            beq GetFloorItemNum_Start       ; check: EQ - yes
                            
                            cmp TabWrkFloor_Len             ; test original floor length
                            beq GetFloorItemNum_End         ; check: min - yes: get item number end of floor
; --------------------------------------------------------------------------------------------------------------------- ;
; get desired floor item number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_Floor              ; 
                            jmp SetFloorItemNum             ; 
                            
GetFloorItemNum_Start       lda #ItemNum_FloorStart         ; 
                            jmp SetFloorItemNum             ; 
                            
GetFloorItemNum_End         lda #ItemNum_FloorEnd           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set the desired floor item number and type - draw item
; --------------------------------------------------------------------------------------------------------------------- ;
SetFloorItemNum             sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; update the room control data with floor item
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get initial length
                            sta TabWrkFloor_Ctrl_Len        ; init actual move control floor length
; --------------------------------------------------------------------------------------------------------------------- ;
; process floor ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
ChkNextFloorCtrlLen         lda TabWrkFloor_Draw_Len        ; get actual floor length
                            cmp #$01                        ; test floor start
                            beq ChkCtrlCount_Min            ; check: min - yes: check ctrl count min
                            
                            cmp TabWrkFloor_Len             ; test original floor length
                            beq ChkCtrlCount_Max            ; check: max - yes: check ctrl count max
; --------------------------------------------------------------------------------------------------------------------- ;
; get item floor ctrl middle marker
; --------------------------------------------------------------------------------------------------------------------- ;
GetFloorCtrlNum_Mid         lda #CC_MoveCtrl_Le_Ri          ; get mid of floor move control marker
                            jmp InsFloorItemCtrlByte        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; try item floor ctrl start marker
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCtrlCount_Min            lda TabWrkFloor_Ctrl_Len        ; get actual move control floor length
                            cmp #$01                        ; test min
                            bne GetFloorCtrlNum_Mid         ; check: EQ - no
                            
                            lda #CC_MoveCtrl_Right          ; get a possible move right marker
                            jmp InsFloorItemCtrlByte        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; try to set item floor ctrl end marker
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCtrlCount_Max            lda TabWrkFloor_Ctrl_Len        ; get actual move control floor length
                            cmp TabWrkDraw_T0_Hdr_Cols      ; test number of item col bytes from item header
                            bne GetFloorCtrlNum_Mid         ; check: EQ - no
                            
                            lda #CC_MoveCtrl_Left           ; get a possible move left marker
; --------------------------------------------------------------------------------------------------------------------- ;
; insert required item floor ctrl marker
; --------------------------------------------------------------------------------------------------------------------- ;
InsFloorItemCtrlByte        ldy #$00                        ; 
                            ora (CCZ_MoveCtrlDataPtr),y     ; insert the desired marker
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            inc TabWrkFloor_Ctrl_Len        ; inc actual move control floor length
; --------------------------------------------------------------------------------------------------------------------- ;
; advance item ctrl screen pointer to next col
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            adc #CC_MoveCtrl_Entry_Len      ; each move control entry has $02 bytes
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcc ChkFloorHdrColMax           ; check: overflow - no
                            inc CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if this ladder row is compete
; --------------------------------------------------------------------------------------------------------------------- ;
ChkFloorHdrColMax           lda TabWrkFloor_Ctrl_Len        ; get actual move control floor length
                            cmp TabWrkDraw_T0_Hdr_Cols      ; test number of item col bytes from item header
                            bcc ChkNextFloorCtrlLen         ; check: LT - yes: continue
                            beq ChkNextFloorCtrlLen         ; check: EQ - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; ladder row compete - set next floor draw PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T0_Hdr_Cols      ; get number of item col bytes from item header
                            asl a                           ; *2
                            asl a                           ; *4 - room draw grid width
                            
                            clc                             ; 
                            adc TabWrkDraw_T0_Parm_ItemPosX ; add draw item parm: PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item parm: new PosX
                            
                            inc TabWrkFloor_Draw_Len        ; inc actual floor length
; --------------------------------------------------------------------------------------------------------------------- ;
; ceck if this ladder is complete
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkFloor_Draw_Len        ; get actual floor length
                            cmp TabWrkFloor_Len             ; test original floor length
                            beq TryNextFloorByte            ; check: EQ max len - yes: continue
                            bcs SetNextFloorEntry           ; check: GT max len - yes: done with this floor - try next
                            
TryNextFloorByte            jmp DrawNextFloorByte           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next floor data entry
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextFloorEntry           lda CCZ_DrawItemDataPtr_Lo      ; 
                            clc                             ; 
                            adc #CC_Floor_Item_Len          ; advance to next floor item data
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc TryNextFloor                ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
TryNextFloor                jmp GetNextFloorLength          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawFloorX                  pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkFloor_Draw_Len        .byte $a0 ; actual floor length
TabWrkFloor_Ctrl_Len        .byte $a0 ; actual floor move control length
TabWrkFloor_Len             .byte $a9 ; original floor length
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawPole                  Does    : draw the castle room poles
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawPole                   .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextPoleLength           ldy #CC_Pole_Len                ; get offset pole length
                            lda (CCZ_DrawItemDataPtr),y     ; get pole length
                            bne RoomPole                    ; check: flag CC_Pole_EoD - no: handle pole
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte CC_Pole_EoD and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawPoleX                   ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this pole
; --------------------------------------------------------------------------------------------------------------------- ;
RoomPole                    sta TabWkrPole_Len              ; init actual length of pole
                            
                            ldy #CC_Pole_PosX               ; get offset pole PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get pole PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Pole_PosY               ; get offset pole PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get pole PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                            
                            sec                             ; 
                            sbc #$04                        ; subtract global room row start of $10 ($04*$04 grids)
                            sta TabWrkDrawGrid_Col_Num      ; set pole draw grid column number
                            
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw draw grid height
                            sta TabWrkDrawGrid_Row_Num      ; set pole draw grid row number
                            
                            jsr GameSetMoveCtrlDataPtr      ; set the room move control data pointer 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the pole top down
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextPoleByte            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #CC_MoveCtrl_Le_Ri          ; isolate mid of floor move control marker
                            beq InsertPole                  ; check: crossing a floor - no: simply insert
; --------------------------------------------------------------------------------------------------------------------- ;
; pole passes a floor - overlay the pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            sbc #$04                        ; sub room draw grid width - step one room grid position left
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set new draw item type_1 parm: PosX
                            
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item type_0 parm: PosY - get top of item type_0
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY - set top of item type_1
                            
                            lda #ItemNum_PoleEnd            ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #ItemNum_PoleFront          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_2 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jmp DrawPole                    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; standard pole - simply draw the pole
; --------------------------------------------------------------------------------------------------------------------- ;
InsertPole                  lda #ItemNum_Pole               ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the desired pole item
; --------------------------------------------------------------------------------------------------------------------- ;
DrawPole                    jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; insert this pole into move control data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            ora #CC_MoveCtrl_Down           ; insert a possible move down
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            dec TabWkrPole_Len              ; dec actual lenght of pole
                            bne SetNextPoleDrawGridRow      ; check: min - no: continue painting this pole
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next pole data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_Pole_Item_Len           ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc TryNextPole                 ; check: overflow
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
TryNextPole                 jmp GetNextPoleLength           ; continue with next pole
; --------------------------------------------------------------------------------------------------------------------- ;
; set next draw item row
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextPoleDrawGridRow      clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
; --------------------------------------------------------------------------------------------------------------------- ;
; advance item ctrl screen pointer to next row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            adc #LLEN2                      ; add double row of $50 cols - each ctrl screen entry has $02 bytes
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcc TryNextPoleByte             ; check: overflow - no
                            inc CCZ_MoveCtrlDataPtr_Hi      ; 
                            
TryNextPoleByte             jmp DrawNextPoleByte            ; continue drawing pole
; --------------------------------------------------------------------------------------------------------------------- ;
DrawPoleX                   pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWkrPole_Len              .byte $80 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawLadder                Does    : draw the castle room ladders
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawLadder                 .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextLadderLength         ldy #CC_Ladder_Len              ; get offset ladder length
                            lda (CCZ_DrawItemDataPtr),y     ; get ladder length
                            bne DrawLadder                  ; check: flag CC_Ladder_EoD - no: handle ladder
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte EndOfLadderData and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawLadderX                 ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this pole
; --------------------------------------------------------------------------------------------------------------------- ;
DrawLadder                  sta TabWkrLadder_Len            ; init actual length of ladder
                            
                            ldy #CC_Ladder_PosX             ; get offset ladder PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get ladder PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Ladder_PosY             ; get offset ladder PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get ladder PosX
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                                                              
                            sec                             ; 
                            sbc #$04                        ; subtract global room row start of $10 ($04*$04 grids)
                            sta TabWrkDrawGrid_Col_Num      ; set ladder draw grid column number
                            
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw grid height
                            sta TabWrkDrawGrid_Row_Num      ; set ladder draw grid row number
                            
                            jsr GameSetMoveCtrlDataPtr      ; set the room move control data pointer 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the ladder top down
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextLadderByte          ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #CC_MoveCtrl_Le_Ri          ; isolate mid of floor move control marker
                            bne LadderFloor                 ; check: pass a floor - yes: delete and insert
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda TabWkrLadder_Len            ; get actual length of ladder
                            cmp #$01                        ; test end of ladder
                            beq GetLadderItemTop            ; check: EQ - yes: get item top of ladder
; --------------------------------------------------------------------------------------------------------------------- ;
; standard ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_Ladder             ; get item ladder
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jmp DrawThisLadderPart          ; draw it
; --------------------------------------------------------------------------------------------------------------------- ;
; top of ladder
; --------------------------------------------------------------------------------------------------------------------- ;
GetLadderItemTop            lda #ItemNum_LadderTop          ; get item top of ladder
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jmp DrawThisLadderPart          ; draw it
; --------------------------------------------------------------------------------------------------------------------- ;
; ladder ends on or passes a floor - overlay
; --------------------------------------------------------------------------------------------------------------------- ;
LadderFloor                 lda #TabWrkDraw_Parm_ItemType_2 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda TabWkrLadder_Len            ; get actual length of ladder
                            cmp #$01                        ; test end of ladder
                            bne LadderPassFloor             ; check: EQ - no: ladder passes the floor
; --------------------------------------------------------------------------------------------------------------------- ;
; ladder ends on a floor - overlay
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_LadderEnd          ; get item end of ladder
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #ItemNum_LadderEndCover     ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX item type_0
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item parm: PosX item type_1
                            
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item type_0 parm: PosY - top of item type_0
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY - top of item type_1
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the desired ladder item
; --------------------------------------------------------------------------------------------------------------------- ;
DrawThisLadderPart          jsr RoomItemDraw                ; draw the selected room item
                            
                            jmp LadderMoveCtrl              ; update move ctrl data with this piece of ladder
; --------------------------------------------------------------------------------------------------------------------- ;
; ladder passes a floor
; --------------------------------------------------------------------------------------------------------------------- ;
LadderPassFloor             lda #ItemNum_LadderFloor        ; get item number ladder passes a floor
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #ItemNum_LadderFloorCover   ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            sec                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            sbc #$04                        ; sub room draw grid width - step one room grid position left
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item parm: PosY - top of item type_0
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set new draw item parm: PosY - top of item type_1
                            
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item type_0 parm: PosY - top of item type_0
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY - top of item type_1
; --------------------------------------------------------------------------------------------------------------------- ;
; overlay the desired ladder item
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDraw                ; draw the selected room item
                            
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc #$04                        ; sub room draw grid width - step one room grid position left
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item type_0 parm: PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; insert this ladder into move control data
; --------------------------------------------------------------------------------------------------------------------- ;
LadderMoveCtrl              lda TabWkrLadder_Len            ; get actual length of ladder
                            ldy #CC_Ladder_Len              ; get offset ladder length in castle data
                            cmp (CCZ_DrawItemDataPtr),y     ; test with top of ladder
                            beq DecActualLadderLen          ; check: EQ - yes: top of ladder - has a std ladder marker only
; --------------------------------------------------------------------------------------------------------------------- ;
; insert a standard ladder marker
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            ora #CC_MoveCtrl_Up             ; preset a possible move up
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
DecActualLadderLen          dec TabWkrLadder_Len            ; dec actual length of ladder
                            bne LadderMoveCtrlCombine       ; check: min - no: bypass set next ladder data entry
; --------------------------------------------------------------------------------------------------------------------- ;
; end of this ladder - try next castle data ladder entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; advance castle data pointer
                            adc #CC_Ladder_Item_Len         ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc TryNextLadder               ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
TryNextLadder               jmp GetNextLadderLength         ; continue with next ladder
; --------------------------------------------------------------------------------------------------------------------- ;
; mid of ladder is a combination of CC_MoveCtrl_Down and CC_MoveCtrl_Up
; --------------------------------------------------------------------------------------------------------------------- ;
LadderMoveCtrlCombine       ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            ora #CC_MoveCtrl_Down           ; insert a possible move down - complete the ladder marker
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set next draw item row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
; --------------------------------------------------------------------------------------------------------------------- ;
; set next ctrl row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            adc #LLEN2                      ; add double row of $50 cols - each ctrl screen entry has $02 bytes
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcc TryDrawNextLadderByte       ; check: overflow - no
                            inc CCZ_MoveCtrlDataPtr_Hi      ; 
                            
TryDrawNextLadderByte       jmp DrawNextLadderByte          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawLadderX                 pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWkrLadder_Len            .byte $d2 ; actual length of ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; InitHiResMemAndSpriteWA   Does    : init the hires screen and mark the sprite work areas as free
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
InitHiResMemAndSpriteWA    .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabFlagMusicDataCopy        ; 
                            cmp #TabFlagMusicDataCopy_Yes   ; test flag SFX off
                            beq SwitchSpritesOff            ; check: EQ - yes: bypass switch screen off
; --------------------------------------------------------------------------------------------------------------------- ;
; switch off the screen first to hide the screen setup
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            and #SCROLY_DEN_OFF             ; insert display enable off
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            
SwitchSpritesOff            lda #SPENA_ALL_OFF              ; 
                            sta CCZ_VIC_SPENA               ; set IRQ work register value
; --------------------------------------------------------------------------------------------------------------------- ;
; init hires data pointer to end - init memory top-down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_ScreenGfxDisplay + $2000 - $100 ; 
                            sta CCZ_IniHiResScreenPtr_Lo    ; 
                            lda #>CC_ScreenGfxDisplay + $2000 - $100 ; 
                            sta CCZ_IniHiResScreenPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; do not clears system harware vectors of last page
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #<SHV - $01                 ; get offset last HiRes screen page
GetNextHiResScreenPtrIniVal lda #$00                        ; get initial value
IniNextHiResScreenPtr       sta (CCZ_IniHiResScreenPtr),y   ; 
                            
                            dey                             ; dec offset HiRes screen page
                            cpy #$ff                        ; test min
                            bne IniNextHiResScreenPtr       ; check: NE - yes: continue
                            
                            dec CCZ_IniHiResScreenPtr_Hi    ; set next page
                            
                            lda CCZ_IniHiResScreenPtr_Hi    ; 
                            cmp #>CC_ScreenGfxDisplay       ; test start of HiRes screen
                            bcs GetNextHiResScreenPtrIniVal ; check: GE - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init the sprite work areas by simply mar the whole area as free
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get sprite WA blockoffset
GetNextIniVal               lda TabFlagSprt_WA_Free         ; get flag sprite work area is free again
                            sta CC_WA_Sprite_Flag,y         ; mark sprite WA as free
; --------------------------------------------------------------------------------------------------------------------- ;
; point to next sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; get sprite WA offset
                            clc                             ; 
                            adc #CC_WA_Sprite_Len           ; point offset to next sprite WA block
                            tay                             ; set sprite WA offset
                            bne GetNextIniVal               ; check: max of $08 * $20 reached - no: continue
                            
                            lda #$00                        ; 
                            sta TabItem_WA_UseCount         ; init use count
                            sta TabWrkExitScrnValues_Max    ; init max offset castle escape screen value table
                            sta TabExitScrnValues_Color     ; init color to BLACK
                            
                            sta CCZ_VIC_EXTCOL              ; set IRQ work register value to BLACK for border
; --------------------------------------------------------------------------------------------------------------------- ;
; done
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; WaitSomeIrqCycles         Does    : wait for the given number of IRQs to be counted down
;                           Expects : .A=count of IRQs to wait
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
WaitSomeIrqCycles          .block                           ; 
                            sta TabWrkIRQ_WaitCount         ; init the wait time count
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$06                        ; get fix number of wait rounds
                            
GetNextIrqWaitCount         lda TabWrkIRQ_WaitCount         ; get reinit value
                            sta TabWrkIRQ_Count             ; init wait counter
                            
WaitIRQs                    lda TabWrkIRQ_Count             ; counted down with every IRQ
                            bne WaitIRQs                    ; check: min - no: continue
                            
                            dex                             ; dec number of wait rounds
                            bne GetNextIrqWaitCount         ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkIRQ_WaitCount         .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleEscapeHandler       Does    : eventually show a castle picture and let a player run down the castle escape path
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleEscapeHandler        .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
                            
                            lda #TabExitScrnValues_Len      ; 
                            sta TabWrkExitScrnValues_Max    ; init max offset castle escape screen value table
                            
                            lda CC_GameDataVar_Game         ; get game status flag from castle data variables
                            and #CC_GameDataVar_Game_ExitPic; isolate flag: show exit picture
                            beq DrawExitText                ; check: show - no: skip draw castle exit picture
; --------------------------------------------------------------------------------------------------------------------- ;
; show the castle exit picture
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_ExitPicPtr_Lo; get exit pictue ID pointer Lo from castle data variables
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda CC_GameDataVar_ExitPicPtr_Hi; get exit pictue ID pointer Hi from castle data variables
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr CastleRoomDrawHandler       ; control drawing the castle room items
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the castle escape message for this player
; --------------------------------------------------------------------------------------------------------------------- ;
DrawExitText                clc                             ; 
                            lda TabWrkEscape_PlayerNum      ; get actual castle escape player number
                            adc #"1"                        ; convert to char - make it displayable
                            sta TabText_PlayerEscapes_Num   ; 
                            
                            lda #<TabText_PlayerEscapes     ; set escape text address pointer
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_PlayerEscapes     ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawText                    ; Text: player # escapes
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to time values in game data variables
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkEscape_PlayerNum      ; get actual castle escape player number
                            asl a                           ; *2
                            asl a                           ; *4
                            clc                             ; 
                            adc #<CC_GameDataVar_Times      ; offset times in game data vaiables part
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #$00                        ; 
                            adc #>CC_GameDataVar            ; add carry
                            sta CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; fill and draw the exit time item
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr CastleTimeItemFillHandler   ; control the setup of the TabDataCastleTimeFrame item
                            
                            lda #ItemNum_TimeFrame          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #$68                        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda #$18                        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; switch screen on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            and #~SCROLY_RST8               ; clear RASTER MSB bit8
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; init this players castle escape sprite pos
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkEscape_PlayerNum      ; get actual castle escape player number
                            ldx TabWrkPlayer_Sprite_WA,y    ; 
                            lda #$87                        ; 
                            sta CC_WA_Sprite_PosY,x         ; 
                            
                            lda #$08                        ; 
                            sta CC_WA_Sprite_PosX,x         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; choose between two castle escape behaviours
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GetNextRandomValue          ; get a random value
                            and #$0e                        ; limit - ....###.
                            beq GetCastleExitType_2         ; check: ZERO - yes: sometimes init the 2nd exit type 
; --------------------------------------------------------------------------------------------------------------------- ;
; exit type #1:  enter/wave/leave completely
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabEscape_Step_Data_Off_T1 ;  get offset player castle exit type 1
                            jmp SetCastleExitType           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; exit type #2:  enter/leave completely/reenter/wave/leave
; --------------------------------------------------------------------------------------------------------------------- ;
GetCastleExitType_2         lda #TabEscape_Step_Data_Off_T2 ; get offset player castle exit type 2
                            
SetCastleExitType           sta TabWrkEscapeStep_Data_Off   ; init offset actual player castle exit type
                            
                            lda #$00                        ; 
                            sta TabWrkEscapeStep_Type_Time  ; init time of the actual castle exit action step
; --------------------------------------------------------------------------------------------------------------------- ;
; loop through the different castle exit steps of the chosen exit type
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextCastleExitStepTime   lda TabWrkEscapeStep_Type_Time  ; get time of the actual castle exit action step
                            bne GetCastleExitStepType       ; check: ZERO - no: continue the actual step
; --------------------------------------------------------------------------------------------------------------------- ;
; advance offset to next castle exit data block - check EndOfExitData
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkEscapeStep_Data_Off   ; get offset actual player castle exit type
                            lda TabEscape_Step_Time,y       ; get next castle exit step time
                            bne SetCastleExitStepTime       ; check: ZERO - no: continue
                            
                            jmp CastleEscapeHandler_Exit    ; all steps executed - done - wait a while - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; init next castle exit step
; --------------------------------------------------------------------------------------------------------------------- ;
SetCastleExitStepTime       sta TabWrkEscapeStep_Type_Time  ; set next time of the actual castle exit action step
                            
                            lda TabEscape_Step_Type,y       ; 
                            sta TabWrkEscapeStep_Type       ; set next type of the actual castle exit action step
; --------------------------------------------------------------------------------------------------------------------- ;
; advance offset to next castle exit step data block
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkEscapeStep_Data_Off   ; get offset actual player castle exit type
                            adc #TabEscape_Step_DataStep_Len; add length of castle exit step data
                            sta TabWrkEscapeStep_Data_Off   ; set new offset actual player castle exit type
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetCastleExitStepType       lda TabWrkEscapeStep_Type       ; get type of the actual castle exit action step
                            cmp #TabWrkEscapeStep_Type_Le   ; test with castle exit type run left
                            bcc CastleExit_Run_Right        ; check: LT - yes: run right
                            beq CastleExit_Run_Left         ; check: EQ - yes: run left
; --------------------------------------------------------------------------------------------------------------------- ;
; player waves goodbye
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CC_WA_Sprite_Num,x          ; set next wave sprite number
                            
                            lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_PlayerWave_Max + $01 ; test wave step beyond max
                            bcs GetCastleExit_Wave_Min      ; check: GE - yes: reset to min
                            
                            cmp #SpriteNum_PlayerWave_Min   ; test wave step #1 - hand mid 1st
                            bcs SetCastleExitSprtNum        ; check: GE - yes: bypass reset
                            
GetCastleExit_Wave_Min      lda #SpriteNum_PlayerWave_Min   ; get min step number wave - start all over
                            jmp SetCastleExitSprtNum        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; player runs right down the castle exit path
; --------------------------------------------------------------------------------------------------------------------- ;
CastleExit_Run_Right        inc CC_WA_Sprite_PosX,x         ; step right a bit
                            
                            inc CC_WA_Sprite_Num,x          ; set next run right sprite number
                            
                            lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_PlayerMoveRi_Max + $01 ; test run right step beyond max
                            bcs GetCastleExit_Right_Min     ; check: GT - yes: set to min
                            
                            cmp #SpriteNum_PlayerMoveRi_Min ; test min
                            bcs SetCastleExitSprtNum        ; check: GE - yes
                            
GetCastleExit_Right_Min     lda #SpriteNum_PlayerMoveRi_Min ; get min step number run right - start all over
                            jmp SetCastleExitSprtNum        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; player runs left down the castle exit path
; --------------------------------------------------------------------------------------------------------------------- ;
CastleExit_Run_Left         dec CC_WA_Sprite_PosX,x         ; step left a bit
                            
                            inc CC_WA_Sprite_Num,x          ; set next run left sprite number
                            
                            lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_PlayerMoveLe_Max + $01 ; test run lrft step beyond max
                            bcc SetCastleExitSprtNum        ; check: LT - yes: bypass reset
                            
                            lda #SpriteNum_PlayerMoveLe_Min ; get min step number run left - start all over
; --------------------------------------------------------------------------------------------------------------------- ;
; handle player sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
SetCastleExitSprtNum        sta CC_WA_Sprite_Num,x          ; set new player escape step sprite number
                            
                            txa                             ; get player sprite work area offset
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
                            lsr a                           ; /32 - sprite bit position
                            tay                             ; save as offset
                            
                            sei                             ; 
                            
                            lda CC_WA_Sprite_PosX,x         ; 
                            sec                             ; 
                            sbc #$10                        ; subtract global room row start of $10 ($04*$04 grids)
                            
                            asl a                           ; *2
                            
                            clc                             ; 
                            adc #$18                        ; 
                            sta CCZ_VIC_SPnX_Long,y         ; set IRQ work register value - sprite PosX
                            
                            lda CC_WA_Sprite_PosX,x         ; 
                            cmp #$84                        ; test max PosX
                            bcs GetSprtMSB_PosX             ; check: GE - yes: set MSB for PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; clear sprite MSB for PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits for clear
                            and CCZ_VIC_MSIGX               ; MSB X-Pos Sprites 0-7
                            jmp SetSprtMSB_PosX             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear sprite MSB for PosX
; --------------------------------------------------------------------------------------------------------------------- ;
GetSprtMSB_PosX             lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            ora CCZ_VIC_MSIGX               ; MSB X-Pos Sprites 0-7
                            
SetSprtMSB_PosX             sta CCZ_VIC_MSIGX               ; set IRQ work register value - MSB X-Pos Sprites 0-7
                            
                            cli                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; handle player sprite PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PosY,x         ; 
                            clc                             ; 
                            adc #$32                        ; 
                            sta CCZ_VIC_SPnY_Long,y         ; set IRQ work register value - sprite PosY
                            
                            jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
                            
                            lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            ora CCZ_VIC_SPENA               ; 
                            sta CCZ_VIC_SPENA               ; set IRQ work register value
                            
                            lda TabWrkEscape_PlayerNum      ; get actual castle escape player number
                            beq GetColorPlayerSprt_P1       ; get color for player #1
                            
                            lda TabPlayer_Color_P2          ; get color for player #2
                            jmp SetColorPlayerSprt          ; 
                            
GetColorPlayerSprt_P1       lda TabPlayer_Color_P1          ; get color for player #1
                            
SetColorPlayerSprt          sta SP0COL,y                    ; VIC($D027) Color Sprite 0
; --------------------------------------------------------------------------------------------------------------------- ;
; handle the escape step time
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabWrkEscapeStep_Type_Time  ; dec time of the actual castle exit action step
                            
                            lda #$02                        ; get initial value
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            
PlayerExitStepWait          lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne PlayerExitStepWait          ; check: 
                            
                            jmp GetNextCastleExitStepTime   ; contine the escape
; --------------------------------------------------------------------------------------------------------------------- ;
CastleEscapeHandler_Exit    lda #$0a                        ; get count of IRQs to wait
                            jsr WaitSomeIrqCycles           ; wait
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkEscape_PlayerNum      .byte $b5 ; actual castle escape player number
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_PlayerEscapes       = * ; 
                            .byte $20       ; StartPosX
                            .byte $00       ; StartPosY
                            .byte LT_GREEN  ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "p"       ; Text: player 1 escapes
                            .byte "l"       ; 
                            .byte "a"       ; 
                            .byte "y"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
TabText_PlayerEscapes_Num   .byte " "       ; 
                            .byte " "       ; 
                            .byte "e"       ; 
                            .byte "s"       ; 
                            .byte "c"       ; 
                            .byte "a"       ; 
                            .byte "p"       ; 
                            .byte "e"       ; 
                            .byte "s" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $38       ; StartPosX
                            .byte $18       ; StartPosY
                            .byte YELLOW    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "t"       ; Text: time:
                            .byte "i"       ; 
                            .byte "m"       ; 
                            .byte "e"       ; 
                            .byte ":" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText = 00
; --------------------------------------------------------------------------------------------------------------------- ;
; exit action type 1: player enters/stops/waves/leaves
; --------------------------------------------------------------------------------------------------------------------- ;
TabEscape_Step              = *       ; 
TabEscape_Step_Time         = * + $00 ; 
TabEscape_Step_Type         = * + $01 ; 
TabEscape_Step_Data_Off_T1  = * - TabEscape_Step_Type + $01 ; data length of each player castle exits
; --------------------------------------------------------------------------------------------------------------------- ;
; exit action type 1: player enters/waves/leaves
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $80 ; time: 
                            .byte TabWrkEscapeStep_Type_Ri ; run right
TabEscape_Step_DataStep_Len = * - TabEscape_Step ; length of castle exit step data
                            
                            .byte $19 ; time: 
                            .byte TabWrkEscapeStep_Type_Wave ; wave goodbye
                            
                            .byte $2d ; time: 
                            .byte TabWrkEscapeStep_Type_Ri ; run right
                            
                            .byte $00 ; time: 00 - EndOfType 1
                            .byte $00 ; 
TabEscape_Step_Data_Off_T2  = * - TabEscape_Step ; data length of each player castle exits
; --------------------------------------------------------------------------------------------------------------------- ;
; exit action type 2: player enters/leaves/reenters/waves/leaves
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ac ; time: 
                            .byte TabWrkEscapeStep_Type_Ri ; run right
                            
                            .byte $2c ; time: 
                            .byte $01 ; flag: run left
                            
                            .byte $19 ; time: 
                            .byte TabWrkEscapeStep_Type_Wave ; wave goodbye
                            
                            .byte $2d ; time: 
                            .byte TabWrkEscapeStep_Type_Ri ; run right
                            
                            .byte $00 ; time: 00 - EndOfType 2
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkEscapeStep_Type       .byte $a5 ; type of the actual castle exit action step
TabWrkEscapeStep_Type_Ri        = $00 ; run right
TabWrkEscapeStep_Type_Le        = $01 ; run left
TabWrkEscapeStep_Type_Wave      = $02 ; wave
TabWrkEscapeStep_Type_Time  .byte $a0 ; time of the actual castle exit action step
TabWrkEscapeStep_Data_Off   .byte $a0 ; offset actual player castle exit type data blocks
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawExitGraphic           Does    : draw the castle exit graphics
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawExitGraphic            .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; store address of exit graphic memory
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabItemAdr_Graphic + $00    ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabItemAdr_Graphic + $01    ; 
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_Graphic            ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; calc number of rows from header
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_ExitGfx_Hdr_Rows        ; get offset exit graphic number of rows
                            lda (CCZ_DrawItemDataPtr),y     ; get exit graphic number of rows
                            sec                             ; 
                            sbc #$01                        ; correction
                            
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw grid height
                            sta CCZ_ExitGfxNumRows          ; set item number of rows
                            inc CCZ_ExitGfxNumRows          ; correct item number of rows
; --------------------------------------------------------------------------------------------------------------------- ;
; get number of cols from header as counter
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_ExitGfx_Hdr_Cols        ; get offset exit graphic number of cols
                            lda (CCZ_DrawItemDataPtr),y     ; get exit graphic number of cols
                            tax                             ; set as column count
; --------------------------------------------------------------------------------------------------------------------- ;
; init the resulting pointer to the graphic item position list following the gfx data/gfx color sections
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta CCZ_ExitGfxPosDataPtr_Lo    ; 
                            sta CCZ_ExitGfxPosDataPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; calc number of hires color bytes = (((CC_ExitGfx_Hdr_Rows - $01) / $08) + $01) * CC_ExitGfx_Hdr_Cols
; --------------------------------------------------------------------------------------------------------------------- ;
AddNextNumberOfRows         cpx #$00                        ; test exit graphic column count
                            beq MultColorDataPtrByTwo       ; 
                            
                            clc                             ; 
                            lda CCZ_ExitGfxPosDataPtr_Lo    ; 
                            adc CCZ_ExitGfxNumRows          ; add item number of rows - always same for each gfx item row
                            sta CCZ_ExitGfxPosDataPtr_Lo    ; 
                            
                            lda CCZ_ExitGfxPosDataPtr_Hi    ; 
                            adc #$00                        ; add carry
                            sta CCZ_ExitGfxPosDataPtr_Hi    ; 
                            
                            dex                             ; dec exit graphic column count
                            jmp AddNextNumberOfRows         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; calc number of color bytes = number of hires color bytes + number of coloram bytes (same for each color section)
; --------------------------------------------------------------------------------------------------------------------- ;
MultColorDataPtrByTwo       asl CCZ_ExitGfxPosDataPtr_Lo    ; 
                            rol CCZ_ExitGfxPosDataPtr_Hi    ; *2
; --------------------------------------------------------------------------------------------------------------------- ;
; add the number of col bytes for each graphic data item row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_ExitGfx_Hdr_Rows        ; get offset header number of rows
                            lda (CCZ_DrawItemDataPtr),y     ; get header number of rows
                            tax                             ; set as graphic item row count
                            
                            ldy #CC_ExitGfx_Hdr_Cols        ; init offset header number of cols
AddNextNumberOfCols         cpx #$00                        ; test graphic item row count
                            beq AddHeaderLen                ; check: min - yes
                            
                            clc                             ; 
                            lda CCZ_ExitGfxPosDataPtr_Lo    ; 
                            adc (CCZ_DrawItemDataPtr),y     ; add CC_ExitGfx_Hdr_Cols - same for each row
                            sta CCZ_ExitGfxPosDataPtr_Lo    ; 
                            
                            lda CCZ_ExitGfxPosDataPtr_Hi    ; 
                            adc #$00                        ; add carry
                            sta CCZ_ExitGfxPosDataPtr_Hi    ; 
                            
                            dex                             ; dec graphic item row count
                            jmp AddNextNumberOfCols         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; add number of header bytes - gives offset to graphic item position list
; --------------------------------------------------------------------------------------------------------------------- ;
AddHeaderLen                clc                             ; 
                            lda #CC_ExitGfx_Hdr_Len         ; 
                            adc CCZ_ExitGfxPosDataPtr_Lo    ; 
                            sta CCZ_ExitGfxPosDataPtr_Lo    ; 
                            
                            lda #$00                        ; 
                            adc CCZ_ExitGfxPosDataPtr_Hi    ; add carry
                            sta CCZ_ExitGfxPosDataPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to first entry of the graphic item position list
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc CCZ_ExitGfxPosDataPtr_Lo    ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            adc CCZ_ExitGfxPosDataPtr_Hi    ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw all graphic items from the graphic item position list
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextGfxItem             ldy #CC_ExitGfx_Ptr_PosX        ; get offset graphic item PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get graphic item PosX
                            bne DrawGfxItemPart             ; check: CC_ExitGfx_Ptr_PosX_EoD - no
; --------------------------------------------------------------------------------------------------------------------- ;
; done with this graphic item - advance graphic item data pointer behind EndOfGraphicPos data
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #$01                        ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jmp DrawExitGraphicX            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawGfxItemPart             sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            iny                             ; get offset graphic item PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get graphic item PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next graphic item position data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_Exit_Gfx_Ptr_Len        ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jmp DrawNextGfxItem             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawExitGraphicX            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LeaderBoardInsertNew      Does    : probably find and insert a new best castle escape time
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LeaderBoardInsertNew       .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set time data buffer pointer for this player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_Active_P2    ; get player #2 active flag from castle data variables
                            cmp #CC_GameDataVar_Active_No   ; test with flag not active
                            beq SetTimeDataBufPtr_One       ; check: not active - yes: set time data pointer for a ONE player game
                            
                            lda #<CC_TimeData_Two_Time - $01; set time data pointer for TWO player time values
                            sta CCZ_CastleTimePtr_Lo        ; 
                            lda #>CC_TimeData_Two_Time - $01; 
                            sta CCZ_CastleTimePtr_Hi        ; 
                            jmp IniTimeEntryDataSearch      ; start the best escape time table lookup
                            
SetTimeDataBufPtr_One       lda #<CC_TimeData_One_Time - $01; set time data pointer for ONE player time values
                            sta CCZ_CastleTimePtr_Lo        ; 
                            lda #>CC_TimeData_One_Time - $01; 
                            sta CCZ_CastleTimePtr_Hi        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; lookup the achieved best castle exit times for a possible new entry
; --------------------------------------------------------------------------------------------------------------------- ;
IniTimeEntryDataSearch      lda #CC_TimeData_Entry_Max      ; get initial value
                            sta TabWrkEscapeTime_Entry_Num  ; init actual best time entry number
                            
GetNextTimeEntryDataLen     ldy #CC_TimeData_Entry_Len_Time ; init offset time data for this entry
GetNextTimeEntryDataVal     lda (CCZ_CastleTimePtr),y       ; get time value (hms)
                            cmp TabWrkEscapeTimePlayer,y    ; test with this players exit time  (hms)
                            bcc SetNextEntryAdr             ; check: LT - yes: step entry pointer forward
                            bne NewEscapeRecordFound        ; check: NE - yes: a new exit record found
                            
                            jmp DecTimeEntryDataLen         ; EQ - point to next time entry value (hms)
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer to next time entry
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEntryAdr             clc                             ; 
                            lda CCZ_CastleTimePtr_Lo        ; 
                            adc #CC_TimeData_Entry_Len      ; 
                            sta CCZ_CastleTimePtr_Lo        ; 
                            bcc DecTimeEntryNum             ; check: overflow - no
                            inc CCZ_CastleTimePtr_Hi        ; 
                            
DecTimeEntryNum             dec TabWrkEscapeTime_Entry_Num  ; dec actual best time entry number
                            bne GetNextTimeEntryDataLen     ; check: min - no: continue
                            
                            jmp LeaderBoardInsertNewX       ; all entries processed - exit
; --------------------------------------------------------------------------------------------------------------------- ;
DecTimeEntryDataLen         dey                             ; dec offset time data for this entry
                            bne GetNextTimeEntryDataVal     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare the insertion of a new castle escape time record
; --------------------------------------------------------------------------------------------------------------------- ;
NewEscapeRecordFound        lda CC_GameDataVar_Active_P2    ; get player #2 active flag from castle data variables
                            cmp #CC_GameDataVar_Active_No   ; test with flag not active
                            beq IniOnePlayerBestTime        ; check: no active - yes: address player #1
                            
                            ldy #CC_TimeData_WA_Block_Off - CC_TimeData_Entry_Len + $01 ; get max offset times block for TWO player game
                            
                            lda #$68                        ; 
                            sta TabWrkTextInput_PosX        ; get cursor PosX for input of a new TWO players game best time
                            jmp IniOnePlayerBestTime_PosY   ; 
                            
IniOnePlayerBestTime        ldy #CC_TimeData_P2_Block_Off - CC_TimeData_Entry_Len + $01 ; get max offset times block for ONE player game
                            
                            lda #$18                        ; get cursor PosX for input of a new ONE player game best time
                            sta TabWrkTextInput_PosX        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set input cursor PosY for this best time entry
; --------------------------------------------------------------------------------------------------------------------- ;
IniOnePlayerBestTime_PosY   sec                             ; 
                            lda #CC_TimeData_Entry_Max      ; 
                            sbc TabWrkEscapeTime_Entry_Num  ; sub actual best time entry number
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - paint grid height
                            clc                             ; 
                            adc #$08 * $07                  ; add leaderboard header rows
                            sta TabWrkTextInput_PosY        ; set cursor PosY for input of a new players game best time
; --------------------------------------------------------------------------------------------------------------------- ;
; set input text color for this best time entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda #CC_TimeData_Entry_Max      ; 
                            sbc TabWrkEscapeTime_Entry_Num  ; sub actual best time entry number
                            tax                             ; set as offset
                            
                            lda TabText_LeaderBoard_Color,x ; get color value for thie best time entry
                            sta TabWrkTextInput_Color       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; retreat the time data pointer from this players time values to this players ID - start of time entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CCZ_CastleTimePtr_Lo        ; 
                            sbc #CC_TimeData_Entry_Len_ID - $01 ; sub time ID length
                            sta TabWrkEscapeTime_Row_Ptr_Lo ; 
                            lda CCZ_CastleTimePtr_Hi        ; 
                            sbc #$00                        ; sub carry
                            sta TabWrkEscapeTime_Row_Ptr_Hi ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; create empty space for insertion of a new time entry by moving the whole field one time entry up
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextMoveTimeEntryNum     dec TabWrkEscapeTime_Entry_Num  ; dec actual best time entry number
                            beq IniInsertNewEntry           ; check: min - yes: exit 
                            
                            lda #CC_TimeData_Entry_Len      ; get max length of time data in castle data variables
                            sta TabWrkEscapeTime_Entry_Len  ; set actual length of time data in castle data variables
                            
MoveNextTimeEntryUp         lda CC_TimeDataBuf,y            ; get buffer value from ONE/TWO players game escape times
                            sta CC_TimeDataBuf + CC_TimeData_Entry_Len,y ; set buffer value from ONE/TWO players game escape times
                            
                            dey                             ; dec get buffer offset of ONE/TWO players game escape times
                            
                            dec TabWrkEscapeTime_Entry_Len  ; dec entry len
                            bne MoveNextTimeEntryUp         ; check: min - no: continue with this entry
                            
                            jmp SetNextMoveTimeEntryNum     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; insert the new entry ID
; --------------------------------------------------------------------------------------------------------------------- ;
IniInsertNewEntry           ldy #CC_TimeData_Entry_Len_ID   ; get ID length
InsertNextNewEntry_ID       lda TabWrkEscapeTimePlayer,y    ; 
                            sta (CCZ_CastleTimePtr),y       ; 
                            
                            dey                             ; dec ID length
                            bne InsertNextNewEntry_ID       ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set the time data pointer this players ID - start of time entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkEscapeTime_Row_Ptr_Lo ; 
                            sta CCZ_CastleTimePtr_Lo        ; 
                            lda TabWrkEscapeTime_Row_Ptr_Hi ; 
                            sta CCZ_CastleTimePtr_Hi        ; 
                            
                            lda #$00                        ; get initial value
                            ldy #$00                        ; 
                            sta (CCZ_CastleTimePtr),y       ; mark this entry as empty
                            
                            jsr LeaderBoardShow             ; show the castles escape time leader board
; --------------------------------------------------------------------------------------------------------------------- ;
; address and prepare the info msg to enter this players id for a new best time
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabText_EscapePlayerID    ; set message text pointer
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_EscapePlayerID    ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            ldx TabWrkEscapeTime_Player_Num ; get actual best time player number
                            lda TabEscapeTime_PlayerNum_Txt,x ; get actual best time player number as text
                            sta TabText_EscapePlayerID_Num  ; set id in enter player initials header text line
                            
                            jsr DrawText                    ; draw header text to enter player initials
; --------------------------------------------------------------------------------------------------------------------- ;
; input this players new ID
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_TimeData_Entry_Len_ID   ; get time ID length
                            sta TabWrkTextInput_Len_Max     ; set to max input line length
                            
                            lda #CC_TextLine_Style_Height_Sng ; 
                            sta TabWrkTextInput_Style       ; set single height msg text
; --------------------------------------------------------------------------------------------------------------------- ;
; switch display on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            
                            jsr TextLineInputHandler        ; get an input text line
; --------------------------------------------------------------------------------------------------------------------- ;
; copy this players id to the castle escape time buffer position
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; init text line ID offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set the time data pointer this players ID - start of time entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkEscapeTime_Row_Ptr_Lo ; 
                            sta CCZ_CastleTimePtr_Lo        ; 
                            lda TabWrkEscapeTime_Row_Ptr_Hi ; 
                            sta CCZ_CastleTimePtr_Hi        ; 
                            
CheckNextInputMax           cpy TabWrkTextInputBuf_Max      ; test with the actual input buffer high water mark
                            bcc GetExitIdCharFromInBuf      ; check: LT - yes: get next ID char
                            
                            lda #" "                        ; new ID not three chars long - blank out the rest
                            jmp SetExitIdChar               ; 
                            
GetExitIdCharFromInBuf      lda TabWrkTextInputBuf,y        ; get next input ID char
                            
SetExitIdChar               sta (CCZ_CastleTimePtr),y       ; store the new castle escape ID
                            
                            iny                             ; inc ini text line ID offset
                            cpy #CC_TimeData_Entry_Len_ID   ; test with max time ID length
                            bcc CheckNextInputMax           ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; save the updated castle escape time buffer to disk
; --------------------------------------------------------------------------------------------------------------------- ;
; set game menu row address pointer to cursor row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkMenuCtrlBlk_Off_Sel   ; get offset ctrl block of the cursor selected entry
                            
                            ldy CC_WA_GameMenu_Row,x        ; get cursor row number from the requested menu ctrl block
                            clc                             ; 
                            lda TabTextScreenRowAdr_Lo,y    ; get the screen row address Lo
                            adc CC_WA_GameMenu_Col,x        ; add the column number from the requested menu ctrl block
                            sta CCZ_CastleTimePtr_Lo        ; 
                            
                            lda TabTextScreenRowAdr_Hi,y    ; get the screen row address Hi
                            adc #$00                        ; add carry
                            ora #>CC_ScreenMenu             ; insert menu screen base address Hi
                            sta CCZ_CastleTimePtr_Hi        ; 
                            
                            lda #TabWrkLoadFile_ID_Time     ; get castle escape time file ID
                            sta TabWrkSaveFile_Name_Id      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the remaining file name part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_WA_GameMenu_File_Len_Max - $01 ; directory file max length minus save file ID char
CopyNextFileNameChar        lda (CCZ_CastleTimePtr),y       ; 
                            and #$7f                        ; clear upper case bit7
                            cmp #" "                        ; test with blank
                            bcs SetFilenameChar             ; check: GE - yes: is char already
                            
                            ora #$40                        ; make it a char
                            
SetFilenameChar             sta TabWrkSaveFile_Name,y       ; write the file name to buffer
                            
                            dey                             ; dec directory file max length
                            bpl CopyNextFileNameChar        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; prapare the save of the the updated castle escape times file
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_GameMenu_File_Len,x   ; 
                            sta TabWrkSaveFile_Name_Len     ; 
                            
                            lda #TabWrkFlagSaveDataAdr_Times; 
                            sta TabWrkFlagSaveDataAdr       ; 
                            
                            jsr CastleDataPrepareDiskIO     ; switch KERNAL back on
                            jsr CastleDataVerifyDisk        ; verify the master disk name of DUNGEONMASTER
                            cmp #$00                        ; test master disk found
                            bne GoGameRestart               ; check: NE - yes: no master disk or disk error - bypass save
; --------------------------------------------------------------------------------------------------------------------- ;
; saves are allowed only on an error free master disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr CastleDataFileSave          ; replace the best times file
                            
GoGameRestart               jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
; --------------------------------------------------------------------------------------------------------------------- ;
LeaderBoardInsertNewX       pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkEscapeTimePlayer       = *      ; 
                            .byte $cd ; 
                            .byte $a5 ; 
                            .byte $aa ; 
                            .byte $d0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkEscapeTime_Player_Num .byte $b6 ; actual best time player number
TabWrkEscapeTime_Entry_Num  .byte $a0 ; actual best time entry number
TabWrkEscapeTime_Entry_Len  .byte $a5 ; 
                            
                            .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEscapeTime_PlayerNum_Txt = *       ; actual best time player number as text
                            .byte "1" | $80 ; 
                            .byte "2" | $80 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkEscapeTime_Row_Ptr_Lo .byte $a0 ; 
TabWrkEscapeTime_Row_Ptr_Hi .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; header text to enter player initials for a new castle escape best time
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_EscapePlayerID      = * ; 
                            .byte $40       ; StartPosX
                            .byte $a0       ; StartPosY
                            .byte LT_BLUE   ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "p"       ; Text: PLayer 1
                            .byte "l"       ; 
                            .byte "a"       ; 
                            .byte "y"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
TabText_EscapePlayerID_Num  .byte " " | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $14       ; StartPosX
                            .byte $b8       ; StartPosY
                            .byte GREY      ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "e"       ; Text: enter your initials
                            .byte "n"       ; 
                            .byte "t"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte "y"       ; 
                            .byte "o"       ; 
                            .byte "u"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte "i"       ; 
                            .byte "n"       ; 
                            .byte "i"       ; 
                            .byte "t"       ; 
                            .byte "i"       ; 
                            .byte "a"       ; 
                            .byte "l"       ; 
                            .byte "s" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $18       ; StartPosX
                            .byte $c0       ; StartPosY
                            .byte GREY      ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "f"       ; Text: followed by
                            .byte "o"       ; 
                            .byte "l"       ; 
                            .byte "l"       ; 
                            .byte "o"       ; 
                            .byte "w"       ; 
                            .byte "e"       ; 
                            .byte "d"       ; 
                            .byte " "       ; 
                            .byte "b"       ; 
                            .byte "y" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $78       ; StartPosX
                            .byte $c0       ; StartPosY
                            .byte GREY      ; Color
                            .byte CC_TextLine_Style_Set_Revrs | CC_TextLine_Style_Height_Sng ; Format = reverse/normal size
                            .byte "r"       ; Text: Return
                            .byte "e"       ; 
                            .byte "t"       ; 
                            .byte "u"       ; 
                            .byte "r"       ; 
                            .byte "n" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LeaderBoardShow           Does    : show the castles escape time leader board
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LeaderBoardShow            .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
; --------------------------------------------------------------------------------------------------------------------- ;
; set game menu row address pointer to cursor row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkMenuCtrlBlk_Off_Sel   ; get offset ctrl block of the cursor selected menu entry
                            ldy CC_WA_GameMenu_Row,x        ; get cursor row number from the requested menu ctrl block
                            clc                             ; 
                            lda TabTextScreenRowAdr_Lo,y    ; get the screen row address Lo
                            adc CC_WA_GameMenu_Col,x        ; add the column number from the requested menu ctrl block
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            
                            lda TabTextScreenRowAdr_Hi,y    ; get the screen row address Hi
                            adc #$00                        ; add carry
                            ora #>CC_ScreenMenu             ; insert menu screen base address Hi
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the selected file name to the work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_GameMenu_File_Len,x   ; get cursor selected menu file length
                            
                            dey                             ; 
                            dey                             ; adjust length
                            
                            lda (CCZ_MenuScrnEntryPtr),y    ; get last file name char - has reverse bit7 set
                            sta CC_TimeData_WA,y            ; set last file name char with bit7 set as EndOfName marker
                            
SetNextActiveFileNameOff    dey                             ; 
                            bmi DrawHdrCastleName           ; check: min - yes: end of copy - draw the castle name
                            
                            lda (CCZ_MenuScrnEntryPtr),y    ; get next file name char
                            and #$7f                        ; normalize a possibly reversed file name
                            sta CC_TimeData_WA,y            ; set next file name char
                            
                            jmp SetNextActiveFileNameOff    ; continue copy
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the loaded castle file name of the work area in double size and white
; --------------------------------------------------------------------------------------------------------------------- ;
DrawHdrCastleName           lda #<CC_TimeData_WA            ; get address WA with the loaded castle data file name
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>CC_TimeData_WA            ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; set loaded castle data file name address pointer
                            
                            sec                             ; 
                            lda #CC_TextLine_Len_Max + $01  ; get max text line length 
                            sbc CC_WA_GameMenu_File_Len,x   ; sub selected file name length
                            asl a                           ; *2
                            asl a                           ; *4 - room draw grid width
                            clc                             ; 
                            adc #$10                        ; add global room row start of $10 ($04*$04 grids)
                            sta TabWrkTextLine_PosX         ; 
                            
                            lda #$10                        ; 
                            sta TabWrkTextLine_PosY         ; 
                            
                            lda #WHITE                      ; 
                            sta TabWrkTextLine_Color        ; 
                            
                            lda #CC_TextLine_Style_Height_Dbl ; 
                            sta TabWrkTextLine_Style        ; 
                            
                            jsr DrawTextLine                ; draw a single text line of the selected height and style
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the complete left ONE players escape times 1st - continue with the right TWO players escape times
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$18                        ; 
                            sta TabWrkTextLine_PosX         ; init left column start PosX
                            
                            ldx #$00                        ; init escape time data buffer offset
                            
                            lda #CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; 
                            sta TabWrkTextLine_Style        ; set normal single sized text
; --------------------------------------------------------------------------------------------------------------------- ;
; (re)init the top leaderboard row
; --------------------------------------------------------------------------------------------------------------------- ;
IniNextEscapeTimeTopRow     lda #$00                        ; get initial value
                            sta CC_TimeData_WA_ColorsOff    ; init escape color table offset
                            
                            lda #$38                        ; get initial value
                            sta TabWrkTextLine_PosY         ; init top PosY for player id and time
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the complete left/right leaderboard columns
; --------------------------------------------------------------------------------------------------------------------- ;
OutNextEscapeTimeRow        ldy CC_TimeData_WA_ColorsOff    ; get actual offset escape time colors
                            lda TabText_LeaderBoard_Color,y ; get actual escape time color
                            sta TabWrkTextLine_Color        ; set escape time color
                            
                            lda CC_TimeData_One_ID_Chr_1,x  ; get 1st player id char
                            cmp #$ff                        ; test with initial value
                            beq GetPlaceHolderChar          ; check: EQ - yes: fill in the place holder char
                            
                            sta CC_TimeData_WA_Id_Chr_1     ; set 1st player id char
                            
                            lda CC_TimeData_One_ID_Chr_2,x  ; get 2nd player id char
                            sta CC_TimeData_WA_Id_Chr_2     ; set 2nd player id char
                            
                            lda CC_TimeData_One_ID_Chr_3,x  ; get 3rd player id char
                            jmp MarkEndOfText               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set 1st/2nd place holder chars
; --------------------------------------------------------------------------------------------------------------------- ;
GetPlaceHolderChar          lda #"."                        ; 
                            sta CC_TimeData_WA_Id_Chr_1     ; 
                            sta CC_TimeData_WA_Id_Chr_2     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set 3rd player ID char with EoL flag
; --------------------------------------------------------------------------------------------------------------------- ;
MarkEndOfText               ora #CC_TextLine_EoL            ; insert flag EndOfLine
                            sta CC_TimeData_WA_Id_Chr_3     ; set 3rd player id char
; --------------------------------------------------------------------------------------------------------------------- ;
; set draw text pointer and draw the ID
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_TimeData_WA_Id_Chr_1   ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>CC_TimeData_WA_Id_Chr_1   ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawTextLine                ; draw a single text line of the selected height and style
                            
                            lda CC_TimeData_One_ID,x        ; get player ID
                            cmp #$ff                        ; test with initial value
                            beq AdvanceDrawRow              ; check: EQ - yes: bypass escape time output
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the players castle escape time
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            txa                             ; get escape time data buffer offset
                            adc #<CC_TimeDataBuf + CC_TimeData_One_Time - $01 ; add escape time data offset
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>CC_TimeDataBuf            ; 
                            adc #$00                        ; add carry
                            sta CCZ_DrawItemDataPtr_Hi      ; set pointer to escape time data
                            
                            jsr CastleTimeItemFillHandler   ; control the setup of the TabDataCastleTimeFrame item
                            
                            lda TabWrkTextLine_PosX         ; 
                            clc                             ; 
                            adc #$08 * $04                  ; add eight room draw grid width - step eight room grid positions right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda TabWrkTextLine_PosY         ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_TimeFrame          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; set next draw grid row
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceDrawRow              clc                             ; 
                            lda TabWrkTextLine_PosY         ; 
                            adc #$08                        ; add room draw grid height
                            sta TabWrkTextLine_PosY         ; 
                            
                            clc                             ; 
                            txa                             ; 
                            adc #CC_TimeData_Entry_Len      ; advance the ime data buffer offset to the next entry
                            tax                             ; 
                            
                            inc CC_TimeData_WA_ColorsOff    ; inc color table offset for next castle escape time row
                            
                            lda CC_TimeData_WA_ColorsOff    ; get color table offset
                            cmp #CC_TimeData_Entry_Max      ; test max
                            bcs CheckDrawColumn             ; check: GE - yes: check if the TWO players column has to be drawn
                            
                            jmp OutNextEscapeTimeRow        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check for ONE or TWO player draw column
; --------------------------------------------------------------------------------------------------------------------- ;
CheckDrawColumn             lda TabWrkTextLine_PosX         ; get leaderboard draw grid column
                            cmp #$18                        ; test with ONE players game PosX
                            bne DrawLeaderBoardHdr          ; check: NE - yes: was TWO players PosX - done - write header
                            
                            lda #$68                        ; init TWO players draw grid column
                            sta TabWrkTextLine_PosX         ; set TWO players draw grid column
                            
                            jmp IniNextEscapeTimeTopRow     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; finalize the castle escape time output with the header lines
; --------------------------------------------------------------------------------------------------------------------- ;
DrawLeaderBoardHdr          lda #<TabText_LeaderBoard_Header; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_LeaderBoard_Header; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawText                    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_LeaderBoard_Header  = * ; 
                            .byte $28       ; StartPosX
                            .byte $00       ; StartPosY
                            .byte YELLOW    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "b"       ; Text: best times for
                            .byte "e"       ; 
                            .byte "s"       ; 
                            .byte "t"       ; 
                            .byte " "       ; 
                            .byte "t"       ; 
                            .byte "i"       ; 
                            .byte "m"       ; 
                            .byte "e"       ; 
                            .byte "s"       ; 
                            .byte " "       ; 
                            .byte "f"       ; 
                            .byte "o"       ; 
                            .byte "r" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $18       ; StartPosX
                            .byte $28       ; StartPosY
                            .byte LT_GREEN  ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "1"       ; 1 player  2 players
                            .byte " "       ; 
                            .byte "p"       ; 
                            .byte "l"       ; 
                            .byte "a"       ; 
                            .byte "y"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte " "       ; 
                            .byte "2"       ; 
                            .byte " "       ; 
                            .byte "p"       ; 
                            .byte "l"       ; 
                            .byte "a"       ; 
                            .byte "y"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte "s" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_LeaderBoard_Color   = * ; 
                            .byte WHITE  ;  1st
                            .byte YELLOW ;  2nd
                            .byte YELLOW ;  3rd
                            .byte ORANGE ;  4th
                            .byte ORANGE ;  5th
                            .byte ORANGE ;  6th
                            .byte LT_RED ;  7th
                            .byte LT_RED ;  8th
                            .byte LT_RED ;  9th
                            .byte LT_RED ; 10th
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDataVerifyDisk      Does    : verify the master disk name of DUNGEONMASTER
;                           Expects : 
;                           Returns : .A=Disk Verify Result
;                                   :    $00=Master Disk Name Found
;                                   :    $01=Master Disk Name Not Found
;                                   :    $02=Disk Error
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataVerifyDisk       .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; open 15,8,15,"i"
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #SA_CHANNEL_CMD             ; get command channel file number
                            ldx #FA_DISK                    ; get device number #8
                            ldy #$0f                        ; get secondary address
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            
                            lda #$01                        ; get length of file name
                            ldx #<TabDiskVerify_Init        ; "I" - initialize disk
                            ldy #>TabDiskVerify_Init        ; 
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            
                            lda #$0f                        ; get command channel file number
                            jsr CLOSE                       ; Kernal($FFC3) Close a logical file (via $31C to $F291)
; --------------------------------------------------------------------------------------------------------------------- ;
; open 2,8,0,"$"
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$02                        ; get logical file number
                            ldx #FA_DISK                    ; get device number #8
                            ldy #$00                        ; get secondary address - LOAD file to address in .X.Y
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            
                            lda #$01                        ; get length of file name
                            ldx #<TabDiskVerify_Dir         ; "$"
                            ldy #>TabDiskVerify_Dir         ; 
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            
                            jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            cmp #$00                        ; test OK
                            bne GetFlag_DiskError           ; check: NE - yes: failure
; --------------------------------------------------------------------------------------------------------------------- ;
; define channel #2 for input
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$02                        ; get logical file number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            
                            jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            cmp #$00                        ; test OK
                            bne GetFlag_DiskError           ; check: NE - yes: failure 
; --------------------------------------------------------------------------------------------------------------------- ;
; over-read the $08 disk name header chars from DIR channel #2
; --------------------------------------------------------------------------------------------------------------------- ;
; 01 04 01 01 00 00 12 22   44 55 4e 47 45 4f 4e 4d 41 53 54 45 52 20 20 20 22   20 41 58 20 32 41 00  ......."DUNGEONMASTER   " AX 2A...
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$08                        ; init disk name byte count
GetNextChar_Hdr             jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            dey                             ; dec count disk name bytes
                            bne GetNextChar_Hdr             ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; read the disk name chars from DIR channel #2
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; init count disk name bytes
GetNextChar_DiskName        jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
; --------------------------------------------------------------------------------------------------------------------- ;
; compare with dir name table chars
; --------------------------------------------------------------------------------------------------------------------- ;
                            eor TabDiskVerify_Name_Master,y ; dungeonmasteR - flip master name char bits
                            and #$7f                        ; .####### - clear EndOfLine bit7
                            bne ChkDiskStatus               ; check: ZERO - yes: disk name char differs - fail
; --------------------------------------------------------------------------------------------------------------------- ;
; handle end of master disk name
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabDiskVerify_Name_Master,y ; dungeonmasteR
                            and #$80                        ; #....... - isolate EndOfLine bit7
                            bne GetFlag_MasterDisk          ; check: EndOfLine - yes: success
                            
                            iny                             ; inc disk name byte count
                            jmp GetNextChar_DiskName        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; disk name not found
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDiskStatus               jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            cmp #$00                        ; test OK
                            bne GetFlag_DiskError           ; check: NE - yes: failure 
                            
                            lda #$01                        ; get flag user disk
                            jmp SetFlag_Result              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetFlag_DiskError           lda #$02                        ; get flag disk error
                            jmp SetFlag_Result              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; dungeonmasteR disk name found
; --------------------------------------------------------------------------------------------------------------------- ;
GetFlag_MasterDisk          lda #$00                        ; get flag master disk
; --------------------------------------------------------------------------------------------------------------------- ;
; store teh result flag
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlag_Result              sta TabWrkDiskVerify_Result     ; 
                            
                            lda #$02                        ; get channel number
                            jsr CLOSE                       ; Kernal($FFC3) Close a logical file (via $31C to $F291)
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            lda TabWrkDiskVerify_Result     ; restore result
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskVerify_Dir           .byte TabWrkLoadFile_ID_Dir     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskVerify_Name_Master   = *       ; 
                            .byte "d" ; disk name: dungeonmasteR
                            .byte "u" ; 
                            .byte "n" ; 
                            .byte "g" ; 
                            .byte "e" ; 
                            .byte "o" ; 
                            .byte "n" ; 
                            .byte "m" ; 
                            .byte "a" ; 
                            .byte "s" ; 
                            .byte "t" ; 
                            .byte "e" ; 
                            .byte "r" | $80 ; EndOfLine = Bit 7 set
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDiskVerify_Result     .byte " " | $80 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskVerify_Init          .byte "i" ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_SFX_Handler           Does    : handle the game sound effects
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_SFX_Handler            .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; handle tune play timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSfx_PlayTime_Lo       ; 
                            bne DecSfxWaitTime_Lo           ; check: min - no: count further down
                            
                            lda TabWrkSfx_PlayTime_Hi       ; 
                            beq GetNextSoundDataByte_Type   ; check: min - yes: done - get next sound type byte
                            
                            dec TabWrkSfx_PlayTime_Hi       ; 
                            
DecSfxWaitTime_Lo           dec TabWrkSfx_PlayTime_Lo       ; 
                            
                            lda TabWrkSfx_PlayTime_Lo       ; combine sfx time HI/LO
                            ora TabWrkSfx_PlayTime_Hi       ; 
                            beq GetNextSoundDataByte_Type   ; check: all counted down - yes: get next sound type byte
                            
                            jmp IRQ_SFXX                    ; exit - previous tone has not ended
; --------------------------------------------------------------------------------------------------------------------- ;
; at end of waittime copy next sfx effect data byte block according to the sound type
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSoundDataByte_Type   ldy #$00                        ; init sound data offset to type byte
                            lda (CCZ_SoundDataPtr),y        ; ..ttttvv - shift out SID voive number - isolate type
                            lsr a                           ; ...ttttv
                            lsr a                           ; ....tttt - sid sound data type
                            tax                             ; set as offset for copy length table entry
                            
                            lda TabSidDataType_Len,x        ; get copy amount for the reqested type
                            tax                             ; save advance sfx data ptr amount
                            tay                             ; set copy amount
; --------------------------------------------------------------------------------------------------------------------- ;
; get SID voice control register values from loaded data
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSfxDataBlock         dey                             ; dec copy amount
                            bmi IncSfxDataBlockPtr          ; check: min - yes: done - advance pointe
                            
                            lda (CCZ_SoundDataPtr),y        ; get data from sound file storage
                            sta TabWrkSidData,y             ; set new SID control work table byte
                            
                            jmp GetNextSfxDataBlock         ; continue copy
; --------------------------------------------------------------------------------------------------------------------- ;
; advance sfx data pointer to next sfx data block
; --------------------------------------------------------------------------------------------------------------------- ;
IncSfxDataBlockPtr          clc                             ; 
                            txa                             ; get advance data ptr amount
                            adc CCZ_SoundDataPtr_Lo         ; add sfx data pointer
                            sta CCZ_SoundDataPtr_Lo         ; 
                            bcc GetCopiedType               ; check: overflow - no
                            inc CCZ_SoundDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; shift out SID voice numbers in bits %00000011 -  isolate SID data type in bits %00111100
; --------------------------------------------------------------------------------------------------------------------- ;
GetCopiedType               lda TabWrkSidDataType           ; ..ttttvv
                            lsr a                           ; ...ttttv
                            lsr a                           ; ....tttt - sid sound data type
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $00
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #TabWrkSidDataType_ADS      ; test type: start ATTACK/DECAY/SUSTAIN
                            bne TestType_SetRelease         ; check: NE - yes: test type: start RELEASE
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $00 - voice 1: init freq and set start ATTACK/DECAY/SUSTAIN
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr IRQ_SetSidBaseAndValuePtr   ; set base and value pointers for the selected SID voice 
                            
                            lda TabWrkSidDataType           ; get SID data type
                            and #TabWrkSidDataType_MaskVoice; mask out SID Voice Number $00-$02
                            tax                             ; set as offset
                            
                            lda TabWrkSidData_Freq          ; get FREQ for the selected voice
                            clc                             ; 
                            adc TabWrkSidFreqOff_Voice,x    ; add freq offset for the selected voice 1-3
                            tax                             ; set as voice frequency table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set voice 1 freq lo
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #FREQLO1 - SID              ; set offset FREQLO1
                            lda TabSidVal_FREQLO,x          ; get value frequency Lo
                            sta (CCZ_SidVoiceRegsBasePtr),y ; set SID FREQLO1
                            sta (CCZ_SidValVoicePtr),y      ; set SID work values for the selected voice
; --------------------------------------------------------------------------------------------------------------------- ;
; set voice 1 freq hi
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; set offset FREQHI1
                            lda TabSidVal_FREQHI,x          ; get value frequency Hi
                            sta (CCZ_SidVoiceRegsBasePtr),y ; set SID FREQHI1
                            sta (CCZ_SidValVoicePtr),y      ; set SID work values for the selected voice
; --------------------------------------------------------------------------------------------------------------------- ;
; set voice 1 freq ctrl
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CNTRL1 - SID               ; set offset CNTRL1
                            lda (CCZ_SidValVoicePtr),y      ; get actual SID work CNTRL1 value
                            ora #CNTRL1_GATE_ADS            ; insert start ATTACK/DECAY/SUSTAIN cycle
                            sta (CCZ_SidVoiceRegsBasePtr),y ; set SID CNTRL1
                            sta (CCZ_SidValVoicePtr),y      ; set actual SID work CNTRL1 value
                            
                            jmp GetNextSoundDataByte_Type   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $01
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_SetRelease         cmp #TabWrkSidDataType_REL      ; test type: start RELEASE
                            bne TestType_SetTimerLo         ; check: NE - yes: test type: set timer lo
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $01 - voice 1: set start RELEASE 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr IRQ_SetSidBaseAndValuePtr   ; set base and value pointers for the selected SID voice 
                            
                            ldy #CNTRL1 - SID               ; set offset CNTRL1
                            lda (CCZ_SidValVoicePtr),y      ; get actual SID work CNTRL1 value
                            and #CNTRL1_GATE_REL            ; start RELEASE cycle
                            sta (CCZ_SidValVoicePtr),y      ; set actual SID work CNTRL1 value
                            sta (CCZ_SidVoiceRegsBasePtr),y ; set SID CNTRL1
                            
                            jmp GetNextSoundDataByte_Type   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $02
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_SetTimerLo         cmp #TabWrkSidDataType_Timer_Lo ; test type: set timer Lo
                            bne TestType_SetTimerHi         ; check: NE - yes: test type: set timer hi
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $02: init sfx work timer Lo
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSidCtrl_Time          ; init play timer value Lo
                            sta TabWrkSfx_PlayTime_Lo       ; 
                            
                            jmp IRQ_SFXX                    ; done
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $03
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_SetTimerHi         cmp #TabWrkSidDataType_Timer_Hi ; test type: set timer Hi
                            bne TestType_SetCopyWorkVals    ; check: NE - yes: test type: copy SID work values
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $03: init sfx timer Hi
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSidCtrl_Time          ; init play timer value Hi
                            sta TabWrkSfx_PlayTime_Hi       ; 
                            
                            jmp IRQ_SFXX                    ; done
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $04
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_SetCopyWorkVals    cmp #TabWrkSidDataType_CpyWrk   ; test type: copy SID work values
                            bne TestType_SetFilters         ; check: NE - yes: test type: update filters
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $04: copy SID work data values
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr IRQ_SetSidBaseAndValuePtr   ; set base and value pointers for the selected SID voice 
                            
                            ldy #PWLO1 - SID                ; get SID work data offset
CopyNextSidWorkDataValue    cpy #CNTRL1 - SID               ; test cntrl
                            beq IniSid_CNTRL1               ; check: EQ - yes: update CNTRL1 register
                            
                            lda TabWrkSidCtrl - $02,y       ; 
                            sta (CCZ_SidVoiceRegsBasePtr),y ; set SID values for the selected voice
                            sta (CCZ_SidValVoicePtr),y      ; set SID work values for the selected voice
                            jmp IncSidWorkDataOff           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; update cntrl register
; --------------------------------------------------------------------------------------------------------------------- ;
IniSid_CNTRL1               lda (CCZ_SidValVoicePtr),y      ; get SID work values for the selected voice
                            and #CNTRL1_GATE_ADS            ; clear except ATTACK/DECAY/SUSTAIN flag
                            ora TabWrkSidCtrl - $02,y       ; insert new control values
                            sta (CCZ_SidVoiceRegsBasePtr),y ; set SID values for the selected voice
                            sta (CCZ_SidValVoicePtr),y      ; set SID work values for the selected voice
                            
IncSidWorkDataOff           iny                             ; 
                            cpy #STNRIS1 - SID + $01        ; test end of registers
                            bcc CopyNextSidWorkDataValue    ; check: LT - yes: continue
                            
                            jmp GetNextSoundDataByte_Type   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $05: update filters
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_SetFilters         cmp #TabWrkSidDataType_Filters  ; test type: uppdate filters
                            bne TestType_SetFreqOff         ; check: NE - yes: test type: set new frequency offset
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $05: set filter values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSidData_Cutlo         ; get filter cutoff frequency
                            sta CUTLO                       ; SID($D415) Filter Cutoff Frequency (low byte)
                            sta TabWrkSidVal_CUTLO          ; set Filter cutoff Frequency Lo
                            
                            lda TabWrkSidData_CUTHI         ; 
                            sta CUTHI                       ; SID($D416) Filter Cutoff Frequency (high byte)
                            sta TabWrkSidVal_CUTHI          ; set Filter cutoff Frequency Hi
                            
                            lda TabWrkSidDataType           ; get SID data type
                            and #TabWrkSidDataType_MaskVoice; mask out SID Voice Number $00-$02
                            tax                             ; 
                            
                            lda TabSprt_VIC_BitNum,x        ; address sprite in one of the VIC sprite registers
                            ora TabWrkSidData_RESFILT       ; 
                            sta RESFILT                     ; SID($D417) Filter Resonance Ctrl
                            sta TabWrkSidVal_RESFILT        ; set Filter Resonance Control
                            
                            lda TabWrkSidVal_MODEVOL        ; Volume and Filter Select
                            and #MODEVOL_VOL_MASK           ; ....#### - isolate volume
                            ora TabWrkSidData_MODEVOL       ; 
                            sta TabWrkSidVal_MODEVOL        ; set Volume and Filter Select
                            sta SIGVOL                      ; SID($D418) Volume/Filter Select
                            
                            jmp GetNextSoundDataByte_Type   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $06
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_SetFreqOff         cmp #TabWrkSidDataType_FreqOff  ; test type: set new frequency offset
                            bne TestType_SetSIGVOL          ; check: NE - yes: test type: set SIGVOL
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $06: set TabWrkSidFreqOff for selected voice
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSidDataType           ; get SID data type
                            and #TabWrkSidDataType_MaskVoice; mask out SID Voice Number $00-$02
                            tax                             ; set as offset
                            
                            lda TabWrkSidData_Freq          ; get new freq offset
                            sta TabWrkSidFreqOff_Voice,x    ; set new limit table freqency offset for voice 1-3
                            
                            jmp GetNextSoundDataByte_Type   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $07
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_SetSIGVOL          cmp #TabWrkSidDataType_SIGVOL   ; test type: set SIGVOL
                            bne TestType_SetCUTLO           ; check: NE - yes: test type: set CUTLO
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $07: set SID SIGVOL
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSidVal_MODEVOL        ; Volume and Filter Select
                            and #MODEVOL_MODE_MASK          ; isolate mode
                            ora TabWrkSidData_Freq          ; insert FREQ for the selected voice
                            sta TabWrkSidVal_MODEVOL        ; set Volume and Filter Select
                            sta SIGVOL                      ; SID($D418) Volume/Filter Select
                            
                            jmp GetNextSoundDataByte_Type   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test type $08
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_SetCUTLO           cmp #TabWrkSidDataType_CUTLO    ; test type: set CUTLO
                            bne TestType_Others             ; check: 
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $08: set work CUTLO and CA1 TIMAHI
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSidData_Cutlo         ; get filter cutoff frequency
                            sta TabWrkSidVal_CUTLO_Save     ; 
                            
                            asl a                           ; .....##.
                            asl a                           ; ....##..
                            ora #$03                        ; ....####
                            sta TIMAHI                      ; CIA1($DC05) Timer A (high byte)
                            
                            jmp GetNextSoundDataByte_Type   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $09: TabWrkSidDataType_End - nothing to do - just reinit the 
; --------------------------------------------------------------------------------------------------------------------- ;
; get flag castle data load memory
; --------------------------------------------------------------------------------------------------------------------- ;
TestType_Others             lda TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            cmp #TabFlagDataBufAdr_Load     ; test flag castle data game memory
                            beq IniDemoMusicDataPtr         ; check: EQ - yes: demo - init music pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; init room item sound effects
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkItemSfx_Ini          ; 
                            sta TabWrkItemSfx               ; 
                            
                            lda #$00                        ; 
                            sta CIACRA                      ; CIA1($DC0E) Control Register A
                            
                            lda #CIAICR_SC_CLR_ALL          ; .####### - prepare clear All Interrupt Sources
                            sta CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            
                            lda CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            jmp IRQ_SFXX                    ; done
; --------------------------------------------------------------------------------------------------------------------- ;
; reinit sound data pointer to demo music memory start
; --------------------------------------------------------------------------------------------------------------------- ;
IniDemoMusicDataPtr         lda #<CC_DemoMusicData_Start    ; 
                            sta CCZ_SoundDataPtr_Lo         ; 
                            lda #>CC_DemoMusicData_Start    ; 
                            sta CCZ_SoundDataPtr_Hi         ; 
                            
                            lda #$02                        ; 
                            sta TabWrkSfx_PlayTime_Hi       ; init sfx play time
                            
                            lda TabWrkSidVal_RESFILT        ; Filter Resonance Control
                            and #RESFILT_RES_MASK           ; 
                            sta RESFILT                     ; SID($D417) Filter Resonance Ctrl
                            sta TabWrkSidVal_RESFILT        ; Filter Resonance Control
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_SFXX                    pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_SetSidBaseAndValuePtr Does    : set base and value pointers for the selected SID voice 
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_SetSidBaseAndValuePtr  .block                           ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSidDataType           ; get SID data type
                            and #TabWrkSidDataType_MaskVoice; mask out SID Voice Number $00-$02
                            asl a                           ; *2 - care for address length
                            tax                             ; set as voice address table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to start of SID registers for the selected voice
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSidVoiceRegsOff + $00,x  ; SID voice register base address Lo
                            sta CCZ_SidVoiceRegsBasePtr_Lo  ; 
                            lda TabSidVoiceRegsOff + $01,x  ; SID voice register base address Hi
                            sta CCZ_SidVoiceRegsBasePtr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to SID register work values for the selected voice
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSidVoiceValueAdr + $00,x ; SID voice register values address Lo
                            sta CCZ_SidValVoicePtr_Lo       ; 
                            lda TabSidVoiceValueAdr + $01,x ; SID voice register values address Hi
                            sta CCZ_SidValVoicePtr_Hi       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSidData               = *       ; 
TabWrkSidDataType           .byte $99 ; $00 - type $00-$09
TabWrkSidDataType_MaskNoUse     = %11000000 ; Bit6-7: <unused>
TabWrkSidDataType_MaskType      = %00111100 ; Bit2-5: Data Type Number $00-$09
TabWrkSidDataType_MaskVoice     = %00000011 ; Bit0-1: SID Voice Number $00-$02
TabWrkSidDataType_ADS           = $00 ; voice 1: init freq and set start ATTACK/DECAY/SUSTAIN
TabWrkSidDataType_REL           = $01 ; voice 1: set start RELEASE
TabWrkSidDataType_Timer_Lo      = $02 ; init sfx work timer lo
TabWrkSidDataType_Timer_Hi      = $03 ; init sfx work timer hi
TabWrkSidDataType_CpyWrk        = $04 ; copy SID work data values
TabWrkSidDataType_Filters       = $05 ; update filters
TabWrkSidDataType_FreqOff       = $06 ; set FreqOff for selected voice
TabWrkSidDataType_SIGVOL        = $07 ; set SID SIGVOL
TabWrkSidDataType_CUTLO         = $08 ; set work CUTLO and CA1 TIMAHI
TabWrkSidDataType_End           = $09 ; end of music data
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSidCtrl               = *       ; 
TabWrkSidCtrl_Time          = *       ;     - type $02/$03
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSidData_Cutlo         = *       ;     - type $05
TabWrkSidData_Freq          .byte $a0 ; $01 - type $00/$06/$07
TabWrkSidData_CUTHI         .byte $c1 ; $02 - type $05
TabWrkSidData_RESFILT       .byte $c6 ; $03 - type $05
TabWrkSidData_MODEVOL       .byte $ce ; $04 - type $05
                            .byte $a2 ; $05
                            .byte $aa ; $06
; --------------------------------------------------------------------------------------------------------------------- ;
TabSidDataType_Len          = *       ; 
                            .byte $02 ; $00 - voice 1: init freq and set start ATTACK/DECAY/SUSTAIN
                            .byte $01 ; $01 - voice 1: set start RELEASE
                            .byte $02 ; $02 - init sfx work timer lo
                            .byte $02 ; $03 - init sfx work timer hi
                            .byte $06 ; $04 - copy SID work data values
                            .byte $05 ; $05 - update filters
                            .byte $02 ; $06 - set TabWrkSidFreqOff for selected voice
                            .byte $02 ; $07 - set SID SIGVOL
                            .byte $02 ; $08 - set work CUTLO and CA1 TIMAHI
                            .byte $01 ; $09 - others - be quiet
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSfx_PlayTime_Lo       .byte $00 ; 
TabWrkSfx_PlayTime_Hi       .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
WrkFlagDemoMusicActive      .byte WrkFlagDemoMusicActive_No ; 
WrkFlagDemoMusicActive_Yes        = $01 ; 
WrkFlagDemoMusicActive_No         = $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSidVoiceRegsOff          = * ; 
                            .word FREQLO1 ; voice 1 register start address
                            .word FREQLO2 ; voice 2 register start address
                            .word FREQLO3 ; voice 3 register start address
; --------------------------------------------------------------------------------------------------------------------- ;
TabSidVoiceValueAdr         = * ; 
                            .word TabWrkSidVal_Voice_1 ; 
                            .word TabWrkSidVal_Voice_2 ; 
                            .word TabWrkSidVal_Voice_3 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSidVal                = *  ; 
TabWrkSidVal_Voice_1        .byte $a0 ; $00 - FREQLO1 - 16 Bit Frequency Control Lo
                            .byte $a9 ; $01 - FREQHI1 - 16 Bit Frequency Control Hi
                            .byte $b5 ; $02 - PWLO1   - 12 Bit Pulse Waveform Width Lo
                            .byte $a0 ; $03 - PWHI1   - 12 Bit Pulse Waveform Width Hi
TabWrkSidVal_Cntrl_1        .byte $e5 ; $04 - CNTRL1  - Control Register
                            .byte $a0 ; $05 - ATKDCY1 - ATTACK/DECAY Control Register
                            .byte $86 ; $06 - STNRIS1 - SUSTAIN/RELEASE Control Register
                            
TabWrkSidVal_Voice_2        .byte $a0 ; $07 - FREQLO2 - 16 Bit Frequency Control Lo
                            .byte $80 ; $08 - FREQHI2 - 16 Bit Frequency Control Hi
                            .byte $ba ; $09 - PWLO2   - 12 Bit Pulse Waveform Width Lo
                            .byte $ce ; $0a - PWHI2   - 12 Bit Pulse Waveform Width Hi
TabWrkSidVal_Cntrl_2        .byte $8d ; $0b - CNTRL2  - Control Register
                            .byte $a0 ; $0c - ATKDCY2 - ATTACK/DECAY Control Register
                            .byte $82 ; $0d - STNRIS2 - SUSTAIN/RELEASE Control Register
                            
TabWrkSidVal_Voice_3        .byte $a0 ; $0e - FREQLO3 - 16 Bit Frequency Control Lo
                            .byte $b8 ; $0f - FREQHI3 - 16 Bit Frequency Control Hi
                            .byte $bc ; $10 - PWLO3   - 12 Bit Pulse Waveform Width Lo
                            .byte $a0 ; $11 - PWHI3   - 12 Bit Pulse Waveform Width Hi
TabWrkSidVal_Cntrl_3        .byte $b0 ; $12 - CNTRL3  - Control Register
                            .byte $a0 ; $13 - ATKDCY3 - ATTACK/DECAY Control Register
                            .byte $cc ; $14 - STNRIS3 - SUSTAIN/RELEASE Control Register
                            
TabWrkSidVal_CUTLO          .byte $a0 ; $15 - CUTLO   - Filter cutoff Frequency Lo
TabWrkSidVal_CUTHI          .byte $b0 ; $16 - CUTHI   - Filter cutoff Frequency Hi
TabWrkSidVal_RESFILT        .byte $84 ; $17 - RESFILT - Filter Resonance Control
TabWrkSidVal_MODEVOL        .byte $0f ; $18 - MODEVOL - Volume and Filter Select
                            
TabWrkSidVal_Len            = * - TabWrkSidVal - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSidFreqOff_Voice      = *       ; freqency offsets for voice 1-3
TabWrkSidFreqOff_Voice_1    .byte $0c ; 
TabWrkSidFreqOff_Voice_2    .byte $0c ; 
TabWrkSidFreqOff_Voice_3    .byte $0c ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSidVal_CUTLO_Save     .byte $14 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSidVal_FREQLO            = * ;  C    C#   D    D#   E    F    F#   G    G#   A    A#   B
                            .byte $0c, $1c, $2d, $3e, $51, $66, $7b, $91, $a9, $c3, $dd, $fa ; 0
                            .byte $18, $38, $5a, $7d, $a3, $cc, $f6, $23, $53, $86, $bb, $f4 ; 1
TabSidVal_FREQ_C2           = * - TabSidVal_FREQLO ;
                            .byte $30, $70, $b4, $fb, $47, $98, $ed, $47, $a7, $0c, $77, $e9 ; 2
                            .byte $61, $e1, $68, $f7, $8f, $30, $da, $8f, $4e, $18, $ef, $d2 ; 3
                            .byte $c3, $c3, $d1, $ef, $1f, $60, $b5, $1e, $9c, $31, $df, $a5 ; 4
                            .byte $87, $86, $a2, $df, $3e, $c1, $6b, $3c, $39, $63, $be, $4b ; 5
                            .byte $0f, $0c, $45, $bf, $7d, $83, $d6, $79, $73, $c7, $7c, $97 ; 6
                            .byte $1e, $18, $8b, $7e, $fa, $06, $ac, $f3, $e6, $8f, $f8, $2e ; 7
; --------------------------------------------------------------------------------------------------------------------- ;
TabSidVal_FREQHI             = * ; C    C#   D    D#   E    F    F#   G    G#   A    A#   B
                            .byte $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 0
                            .byte $02, $02, $02, $02, $02, $02, $02, $03, $03, $03, $03, $03 ; 1
                            .byte $04, $04, $04, $04, $05, $05, $05, $06, $06, $07, $07, $07 ; 2
                            .byte $08, $08, $09, $09, $0a, $0b, $0b, $0c, $0d, $0e, $0e, $0f ; 3
                            .byte $10, $11, $12, $13, $15, $16, $17, $19, $1a, $1c, $1d, $1f ; 4
                            .byte $21, $23, $25, $27, $2a, $2c, $2f, $32, $35, $38, $3b, $3f ; 5
                            .byte $43, $47, $4b, $4f, $54, $59, $5e, $64, $6a, $70, $77, $7e ; 6
                            .byte $86, $8e, $96, $9f, $a8, $b3, $bd, $c8, $d4, $e1, $ee, $fd ; 7
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemSfxInit               Does    : init the selected room item sound effect
;                           Expects : .A=room item sfx number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemSfxInit                .block                           ; 
                            pha                             ; 
                            sta TabWrkItemSfx_Num           ; save requested item sfx number
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a sound effect needs to be initialized
; --------------------------------------------------------------------------------------------------------------------- ;
; get flag castle data load memory
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            cmp #TabFlagDataBufAdr_Load     ; test already at end of game data - castle load mem reached
                            beq ItemSfxInitX                ; check: EQ - yes: done
                            
                            lda TabFlagMusicDataCopy        ; get flag sfx
                            cmp #TabFlagMusicDataCopy_Yes   ; test flag sfx switched off
                            beq ItemSfxInitX                ; check: EQ - yes: done - be quiet
                            
                            lda TabWrkItemSfx               ; 
                            bpl ItemSfxInitX                ; check: EQ TabWrkItemSfx_Ini - no: done
; --------------------------------------------------------------------------------------------------------------------- ;
; init sfx data pointer to the requested sfx data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkItemSfx_Num           ; restore requested item sfx number
                            sta TabWrkItemSfx               ; 
                            
                            asl a                           ; *2
                            tay                             ; set as offset
                            lda TabGameSfxAdr + $00,y       ; get sfx data address LO
                            sta CCZ_SoundDataPtr_Lo         ; 
                            lda TabGameSfxAdr + $01,y       ; get sfx data address HI
                            sta CCZ_SoundDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init SID
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; 
                            sta VCREG1                      ; SID($D404) Oscillator 1 Control
                            sta VCREG2                      ; SID($D40B) Oscillator 2 Control
                            sta VCREG3                      ; SID($D412) Oscillator 3 Control
                            sta RESFILT                     ; SID($D417) Filter Resonance Ctrl
                            
                            sta TabWrkSfx_PlayTime_Lo       ; init timer
                            sta TabWrkSfx_PlayTime_Hi       ; 
                            
                            lda #$0f                        ; get max volume
                            sta SIGVOL                      ; SID($D418) Volume/Filter Select
                            
                            lda #TabSidVal_FREQ_C2          ; get inital value (c major)
                            sta TabWrkSidFreqOff_Voice_1    ; 
                            sta TabWrkSidFreqOff_Voice_2    ; 
                            sta TabWrkSidFreqOff_Voice_3    ; 
                            
                            lda #$14                        ; get inital value
                            sta TabWrkSidVal_CUTLO_Save     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl a                           ; ..#.#...
                            asl a                           ; .#.#....
                            ora #$03                        ; ......##
                            sta TIMAHI                      ; CIA1($DC05) Timer A (high byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; init timer interrupt
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CIAICR_SC_SET | CIAICR_DATA_TA ; get interrupt underflow Timer A
                            sta CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            
                            lda #CIACRA_START               ; get start Timer A
                            sta CIACRA                      ; CIA1($DC0E) Control Register A
; --------------------------------------------------------------------------------------------------------------------- ;
ItemSfxInitX                pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkItemSfx_Num           .byte $a0 ; 
TabWrkItemSfx               .byte TabWrkItemSfx_Ini         ; 
TabWrkItemSfx_Ini               = $ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MenuHandler               Does    : control the game menu with castle data files selections
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MenuHandler                .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; switch to 25*40 text mode with standard text screen base address
; --------------------------------------------------------------------------------------------------------------------- ;
MenuReStart                 lda #SCROLY_RSEL_25 | SCROLY_YSCROLL_INIT_25 ; 
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            
                            lda #CI2PRA_VIC_BANK_0          ; select bank 0 - $0000-$3fff
                            sta CI2DDRA                     ; CIA2($DD02) Data Dir A - ......## - set bank selection bits to output
                            sta CI2PRA                      ; CIA2($DD00) Data Port A - Bits 0-1 = VIC mem bank
                            
                            lda #SPENA_ALL_OFF              ; 
                            sta CCZ_VIC_SPENA               ; set IRQ work register value
                            
                            lda #VMCSB_VM_0400 | VMCSB_CB_1000 ; Screen base: $0400-$07e7  Char base: $1000-$17ff
                            sta CCZ_VIC_VMCSB               ; set IRQ work register value
; --------------------------------------------------------------------------------------------------------------------- ;
; init coloram to white
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<COLORAM                   ; init coloram pointer
                            sta CCZ_IniColorRamPtr_Lo       ; 
                            lda #>COLORAM                   ; 
                            sta CCZ_IniColorRamPtr_Hi       ; 
                            
                            ldy #$00                        ; init page offset
GetNextColoRamColor         lda #WHITE                      ; 
SetNextColoRamColor         sta (CCZ_IniColorRamPtr),y      ; 
                            
                            iny                             ; inc page offset
                            bne SetNextColoRamColor         ; check: page complete - no: continue
                            
                            inc CCZ_IniColorRamPtr_Hi       ; 
                            lda CCZ_IniColorRamPtr_Hi       ; 
                            cmp #>COLORAM + $0400           ; test max of 4 pages reached
                            bcc GetNextColoRamColor         ; check: LT max - yes: continue
                            
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for player interaction
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextPlayerInput          lda #$00                        ; set parm player number #1
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input
                            
                            lda TabWrkInput_Joy_Fire        ; get fire button
                            bne MenuItemSelected            ; check: fire button pressed - yes: handle menu selection
                            
                            lda TabWrkInput_Joy_Move_Subst  ; get move substitition value from TabJoy_Move_Subst
                            and #~TabJoy_Move_Subst_D       ; #####.## - isolate joystick move down
                            bne GetNextPlayerInput          ; check: move up/down - no: wait for next input
; --------------------------------------------------------------------------------------------------------------------- ;
; handle player up/down menu item selection
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkMenuCtrlBlk_Off       ; selected ctrl block offset
                            
                            clc                             ; 
                            ldy CC_WA_GameMenu_Row,x        ; get cursor row number from the requested menu ctrl block
                            lda TabTextScreenRowAdr_Lo,y    ; get the screen row address Lo
                            adc #<CC_ScreenMenu             ; add menu screen base address Lo
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            
                            lda TabTextScreenRowAdr_Hi,y    ; get the screen row address Hi
                            adc #>CC_ScreenMenu             ; add menu screen base address Hi
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear actual menu entry marker ">"
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_GameMenu_Col,x        ; get offset screen row
                            dey                             ; point to screen row marker column
                            dey                             ; 
                            lda #" "                        ; get marker clear value
                            sta (CCZ_MenuScrnEntryPtr),y    ; clear actual menu entry marker
; --------------------------------------------------------------------------------------------------------------------- ;
; get actual joystick move up/down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkInput_Joy_Move_Subst  ; get move substitition value from TabJoy_Move_Subst
                            beq SetOptsCtrlBlockOffPrev     ; check: UP - yes: select previous screen opts ctrl block
; --------------------------------------------------------------------------------------------------------------------- ;
; move control block offset to next entry - restart on top if past bottom
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMenuCtrlBlk_Off       ; selected ctrl block offset
                            cmp TabWrkMenuCtrlBlk_Off_Max   ; test maximum available ctrl block offset
                            bne SetOptsCtrlBlockOffNext     ; check: EQ - no: step down
                            
                            lda #$00                        ; get min menu ctrl block offset
                            jmp SetOptsCtrlBlockOffNew      ; store selected menu ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetOptsCtrlBlockOffNext     clc                             ; 
                            adc #CC_WA_GameMenu_Len         ; add length of menu ctrl block
                            jmp SetOptsCtrlBlockOffNew      ; store selected menu ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
; move control block offset to previous entry - restart on bottom if past top
; --------------------------------------------------------------------------------------------------------------------- ;
SetOptsCtrlBlockOffPrev     lda TabWrkMenuCtrlBlk_Off       ; selected ctrl block offset
                            bne StepOptsCtrlBlockOffUp      ; check: min - no: step up
                            
                            lda TabWrkMenuCtrlBlk_Off_Max   ; get maximum available ctrl block offset
                            jmp SetOptsCtrlBlockOffNew      ; store selected menu ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
StepOptsCtrlBlockOffUp      sec                             ; 
                            sbc #CC_WA_GameMenu_Len         ; sub length of menu ctrl block
; --------------------------------------------------------------------------------------------------------------------- ;
; set new contol block offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetOptsCtrlBlockOffNew      sta TabWrkMenuCtrlBlk_Off       ; store selected menu ctrl block offset
                            
                            tax                             ; set menu ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set new ">" active menu item marker
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_GameMenu_Row,x        ; get cursor row number from the requested menu ctrl block
                            clc                             ; 
                            lda TabTextScreenRowAdr_Lo,y    ; get the screen row address Lo
                            adc #<CC_ScreenMenu             ; 
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            
                            lda TabTextScreenRowAdr_Hi,y    ; get the screen row address Hi
                            adc #>CC_ScreenMenu             ; add menu screen base address Hi
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
                            
                            ldy CC_WA_GameMenu_Col,x        ; 
                            dey                             ; set offset screen row marker 2 columns back
                            dey                             ; 
                            lda #">"                        ; get entry marker char
                            sta (CCZ_MenuScrnEntryPtr),y    ; 
                            
                            jmp IniPlayerInput              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; handle the selected menu item
; --------------------------------------------------------------------------------------------------------------------- ;
MenuItemSelected            ldx TabWrkMenuCtrlBlk_Off       ; get selected ctrl block offset
                            lda CC_WA_GameMenu_Type,x       ; get action type
                            bne ChkScrnOptsCtrlType_File    ; check: Type_Lives - no: check castle data file entries
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $00: flip unlimited lives entry ON/OFF
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkMenu_LivesUnlim       ; get actual status unlimited lives
                            eor #TabWrkMenu_LivesUnlim_Yes  ; flip flag unlimited lives on/off
                            sta TabWrkMenu_LivesUnlim       ; set new status unlimited lives
; --------------------------------------------------------------------------------------------------------------------- ;
; set menu screen pointer to ON/OFF part of unlimited lives selection
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldy CC_WA_GameMenu_Row,x        ; get cursor row number from the requested menu ctrl block
                            lda TabTextScreenRowAdr_Lo,y    ; get screen row address Lo
                            adc #<CC_ScreenMenu             ; add menu screen base address Lo
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            
                            lda TabTextScreenRowAdr_Hi,y    ; get screen row address Hi
                            adc #>CC_ScreenMenu             ; add menu screen base address Hi
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
                            
                            lda CC_WA_GameMenu_Col,x        ; add the screen column number from the requested menu ctrl block
                            clc                             ; 
                            adc #TabTextOpts_Lives_On_Off   ; add offset start column for "ON/OFF"
; --------------------------------------------------------------------------------------------------------------------- ;
; reverse the whole ON/OFF entry except "/"
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; set as screen offset
                            ldx #$00                        ; init min lenght ON/OFF
CheckNextSeperatorPos       cpx #$02                        ; test offset "/"
                            beq IncOnOffOff                 ; check: EQ - yes: do not reverse it
                            
                            lda (CCZ_MenuScrnEntryPtr),y    ; 
                            eor #$80                        ; reverse the next ON OFF char
                            sta (CCZ_MenuScrnEntryPtr),y    ; 
                            
IncOnOffOff                 inx                             ; inc lenght ON/OFF 
                            
                            iny                             ; inc screen offset
                            cpx #TabTextOpts_Lives_OnOff_Len; test max length ON/OFF
                            bcc CheckNextSeperatorPos       ; check: LT - yes: continue
                            
IniPlayerInput              jsr GameMenuJoystickRelease     ; wait for joystick button release
                            jmp GetNextPlayerInput          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $02: load a castle data file from disk
; --------------------------------------------------------------------------------------------------------------------- ;
ChkScrnOptsCtrlType_File    cmp #CC_WA_GameMenu_Type_File   ; test Type_File
                            bne ChkScrnOptsCtrlType_Resume  ; check: NE - yes: check Type_Resume
                            
                            ldx TabWrkMenuCtrlBlk_Off       ; get selected menu ctrl block offset
                            jsr CastleDataMenuDirLoad       ; try to load a cursor selected castle data file
; --------------------------------------------------------------------------------------------------------------------- ;
; restart the game menu after a load/resume/show castle exit times
; --------------------------------------------------------------------------------------------------------------------- ;
GoMenuReStart               jmp MenuReStart                 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $03: resume a saved game in progress from a user disk
; --------------------------------------------------------------------------------------------------------------------- ;
ChkScrnOptsCtrlType_Resume  cmp #CC_WA_GameMenu_Type_Resume ; test Type_Resume
                            bne ChkScrnOptsCtrlType_Times   ; check: NE - yes: check Type_Times
                            
                            jsr CastleDataResumeFileLoad    ; load a saved game from a disk other than master
                            
                            lda TabWrkFlagGameResumed       ; get status of load a saved game
                            cmp #TabWrkFlagGameResumed_OK   ; test success
                            bne GoMenuReStart               ; check: fail - yes: restart the game menu
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $04: show the castles leaderboard
; --------------------------------------------------------------------------------------------------------------------- ;
ChkScrnOptsCtrlType_Times   cmp #CC_WA_GameMenu_Type_Times  ; test Type_Times
                            bne MenuHandler_Exit            ; check: NE - yes: 
                            
                            lda TabWrkMenuCtrlBlk_Off_Sel   ; get offset ctrl block of the cursor selected entry
                            cmp #$ff                        ; test still initial value
                            beq GoMenuReStart               ; check: EQ - yes: no castle data file loaded - restart menu
; --------------------------------------------------------------------------------------------------------------------- ;
; show the castles escape times leaderboard
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameWarmStart               ; set up the machine for game play
                            jsr LeaderBoardShow             ; show the castles escape time leader board
                            
                            lda #<TabText_PressReturnToExit ; set pointer to bottom line text
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_PressReturnToExit ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawText                    ; "press RETURN to exit"
                            
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            
                            lda #$00                        ; get reset value
                            sta TabWrkTextInput_Len_Max     ; reset max input line length
                            
                            jsr TextLineInputHandler        ; get an input text line
                            jmp MenuReStart                 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; case type $01: exit menu - debounce joystick 1st
; --------------------------------------------------------------------------------------------------------------------- ;
MenuHandler_Exit            jsr GameMenuJoystickRelease     ; wait for joystick button release
                            jsr GameWarmStart               ; set up the machine for game play
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameMenuJoystickRelease   Does    : wait for the release of the actual joystick action
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameMenuJoystickRelease    .block                           ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
IniNextIRQWaitPeriod        lda #$02                        ; 
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            
WasteSomeTime               lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne WasteSomeTime               ; check: counted down - no: continue
                            
                            lda #$00                        ; set parm player number #1
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input
                            
                            lda TabWrkInput_Joy_Move_Subst  ; get move substitition value from TabJoy_Move_Subst
                            bpl IniNextIRQWaitPeriod        ; check: still pressed - yes: continue wait for release
                            
                            lda TabWrkInput_Joy_Fire        ; 
                            bne IniNextIRQWaitPeriod        ; check: still pressed - yes: continue wait for release
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkMenuCtrlBlk_Off       .byte $a0 ;       offset selected menu ctrl block
TabWrkMenuCtrlBlk_Off_Sel   .byte $ff ;       offset of the cursor selected ctrl block
TabWrkMenuCtrlBlk_Off_Max   .byte $a0 ;       maximum available ctrl block offset
TabWrkMenu_LivesUnlim       .byte $00 ; flag: unlimited lives on/off
TabWrkMenu_LivesUnlim_No        = $00 ; 
TabWrkMenu_LivesUnlim_Yes       = $ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; castle exit times base line text
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_PressReturnToExit   = * ; 
                            .byte $10       ; StartPosX
                            .byte $c0       ; StartPosY
                            .byte GREY      ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/single size
                            .byte "p"       ; Text: press
                            .byte "r"       ; 
                            .byte "e"       ; 
                            .byte "s"       ; 
                            .byte "s" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $78       ; StartPosX
                            .byte $c0       ; StartPosY
                            .byte GREY      ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/single size
                            .byte "t"       ; Text: to exit
                            .byte "o"       ; 
                            .byte " "       ; 
                            .byte "e"       ; 
                            .byte "x"       ; 
                            .byte "i"       ; 
                            .byte "t" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $40       ; StartPosX
                            .byte $c0       ; StartPosY
                            .byte GREY      ; Color
                            .byte CC_TextLine_Style_Set_Revrs | CC_TextLine_Style_Height_Sng ; Format = reversed/single size
                            .byte "r"       ; Text: return
                            .byte "e"       ; 
                            .byte "t"       ; 
                            .byte "u"       ; 
                            .byte "r"       ; 
                            .byte "n" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDataMenuDirLoad     Does    : try to load a cursor selected game menu castle data file
;                           Expects : .X=offset menu ctrl work area of the selected file entry
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataMenuDirLoad      .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpx TabWrkMenuCtrlBlk_Off_Sel   ; test with active menu ctrl block offset
                            bne CastleDataFileNew           ; check: NE - yes: a new castle data entry was selected
                            
                            jmp CastleDataMenuDirLoadX      ; castle data already loaded - nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataFileNew           lda #TabWrkLoadFile_ID_Data     ; get castle disk file name ID
                            sta TabWrkLoadFile_ID           ; set LOAD file ID
; --------------------------------------------------------------------------------------------------------------------- ;
; set the menu address pointer to the cursor selected row/column
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_GameMenu_Row,x        ; get the row number from the requested menu ctrl block
                            lda TabTextScreenRowAdr_Lo,y    ; get the screen row address Lo
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            lda TabTextScreenRowAdr_Hi,y    ; get the screen row address Hi
                            ora #>CC_ScreenMenu             ; insert menu text screen base Hi
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
                            
                            clc                             ; 
                            lda CCZ_MenuScrnEntryPtr_Lo     ; 
                            adc CC_WA_GameMenu_Col,x        ; add the column number from the requested menu ctrl block
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            bcc IniCopyFileName             ; check: overflow - no
                            inc CCZ_MenuScrnEntryPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the selected text screen castle data file name to the load file buffer
; --------------------------------------------------------------------------------------------------------------------- ;
IniCopyFileName             ldy #$00                        ; 
GetNextFileNameChar         lda (CCZ_MenuScrnEntryPtr),y    ; 
                            cmp #" "                        ; test with char <BLANK>
                            bcs SetFileNameChar             ; check: GE - yes: is already a char
                            
                            ora #$40                        ; not a char - convert it
                            
SetFileNameChar             sta TabWrkLoadFile_Name,y       ; 
                            
                            iny                             ; 
                            cpy #CC_WA_GameMenu_File_Len_Max; test with max disk dir file length
                            bcc GetNextFileNameChar         ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; load the selected castle data file
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_GameMenu_File_Len,x   ; get file length from the requested menu ctrl block
                            sty TabWrkLoadFile_Len          ; 
                            
                            lda #TabFlagLoadMem_Load        ; get flag target memory area load buffer
                            sta TabFlagLoadMem              ; set flag target memory area
                            
                            jsr CastleDataPrepareDiskIO     ; switch KERNAL back on
                            jsr CastleDataVerifyDisk        ; verify the master disk name of DUNGEONMASTER
                            cmp #$00                        ; test master disk name found
                            bne CastleDataMenuDirLoad_Fail  ; check: master disk - no: load fail
                            
                            jsr CastleDataFileLoad          ; load a file from disk
                            jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            cmp #$40                        ; test flag EndOfFile
                            beq CastleDataMenuDirLoad_OK    ; check: EQ - yes: success
                            
CastleDataMenuDirLoad_Fail  jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
                            jmp CastleDataMenuDirLoadX      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; castle data file loaded - get castle escape time leader board file
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataMenuDirLoad_OK    lda #TabWrkLoadFile_ID_Time     ; get castle disk file name header char - best times
                            sta TabWrkLoadFile_ID           ; 
                            
                            lda #TabFlagLoadMem_Times       ; get flag select memory escape times buffer
                            sta TabFlagLoadMem              ; set flag target memory area
                            
                            jsr CastleDataFileLoad          ; load a file from disk
                            jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            cmp #$40                        ; test flag EndOfFile
                            beq CastleTimeFileLoad_Good     ; check: EQ - yes: success
; --------------------------------------------------------------------------------------------------------------------- ;
; failed to load castle escape time leader board file - initialize the castle escape times buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_TimeData_Count_Last_Max ; init the file length header bytes
                            sta CC_TimeData_Count_Last      ; set block max used byte count 
                            lda #CC_TimeData_Count_Page_Max ; 
                            sta CC_TimeData_Count_Page      ; set number of pages ($00)
; --------------------------------------------------------------------------------------------------------------------- ;
; $02*$0a entries minus $02 bytes = offset CC_TimeData_End
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TimeData_Count_Last_Max - $03 ; get max buffer offset without leading length bytes
                            lda #CC_TimeData_EoT            ; get initial value - EndOfTable
IniNextTimeBufferByte       sta CC_TimeData_One_ID,y        ; init buffer
                            
                            dey                             ; dec buffer offset
                            bpl IniNextTimeBufferByte       ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; castle escape time leaderboard file was successfully loaded
; --------------------------------------------------------------------------------------------------------------------- ;
CastleTimeFileLoad_Good     jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
; --------------------------------------------------------------------------------------------------------------------- ;
; set the menu address pointer to the cursor selected row/column
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_GameMenu_Row,x        ; get cursor row number from the requested menu ctrl block
                            
                            lda TabTextScreenRowAdr_Lo,y    ; get the screen row address Lo
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            lda TabTextScreenRowAdr_Hi,y    ; get the screen row address Hi
                            ora #>CC_ScreenMenu             ; insert menu screen base address Hi
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
                            
                            clc                             ; 
                            lda CC_WA_GameMenu_Col,x        ; get the screen column number from the requested menu ctrl block
                            adc CCZ_MenuScrnEntryPtr_Lo     ; 
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            bcc SaveMenu_WA_Off             ; check: overflow - no
                            inc CCZ_MenuScrnEntryPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; unreverse the old file name - reverse the new filename
; --------------------------------------------------------------------------------------------------------------------- ;
SaveMenu_WA_Off             stx TabWrkGameMenuSel_WA_Off    ; save game menu work area offset of the selected castle data entry
                            
                            ldx TabWrkMenuCtrlBlk_Off_Sel   ; $ff after the 1st game start as no file was selected so far
; --------------------------------------------------------------------------------------------------------------------- ;
; set address pointer to the previously cursor selected row/column
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_GameMenu_Row,x        ; get cursor row number from the requested menu ctrl block
                            
                            lda TabTextScreenRowAdr_Lo,y    ; get the screen row address Lo
                            sta CCZ_MenuScrnFileNamePtr_Lo  ; 
                            lda TabTextScreenRowAdr_Hi,y    ; get the screen row address Hi
                            ora #>CC_ScreenMenu             ; insert menu screen base address Hi
                            sta CCZ_MenuScrnFileNamePtr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set address pointer to the new cursor selected row/column
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_MenuScrnFileNamePtr_Lo  ; 
                            adc CC_WA_GameMenu_Col,x        ; add the column number from the requested menu ctrl block
                            sta CCZ_MenuScrnFileNamePtr_Lo  ; 
                            bcc IniDataFileNamLen           ; check: overflow - no
                            inc CCZ_MenuScrnFileNamePtr_Hi  ; 
                            
IniDataFileNamLen           ldy #CC_WA_GameMenu_File_Len_Max; init max file name char count
                            
                            ldx TabWrkGameMenuSel_WA_Off    ; restore game menu work area offset of the selected castle data entry
GetNextSelDataFileNamChar   lda TabWrkMenuCtrlBlk_Off_Sel   ; 
                            cmp #$ff                        ; test still on 1st game start
                            beq ReverseMenuFileName         ; check: 1st start - yes: nothing selected so far - no file name to clear
; --------------------------------------------------------------------------------------------------------------------- ;
; unreverse old entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CCZ_MenuScrnFileNamePtr),y ; 
                            and #$7f                        ; normalize the previously selected castle data file name
                            sta (CCZ_MenuScrnFileNamePtr),y ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; reverse new entry
; --------------------------------------------------------------------------------------------------------------------- ;
ReverseMenuFileName         lda (CCZ_MenuScrnEntryPtr),y    ; 
                            ora #$80                        ; reverse (highlite) the selected castle data file name
                            sta (CCZ_MenuScrnEntryPtr),y    ; 
                            
                            dey                             ; dec actual castle data file name char count
                            bpl GetNextSelDataFileNamChar   ; check: min - no: continue
                            
                            stx TabWrkMenuCtrlBlk_Off_Sel   ; set offset ctrl block of the cursor selected entry
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataMenuDirLoadX      pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkGameMenuSel_WA_Off    .byte $86 ; game menu work area offset of the selected castle data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDataResumeFileLoad  Does    : load a saved game from a disk other than the master disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataResumeFileLoad   .block                           ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameWarmStart               ; set up the machine for game play
                            
                            lda #TabWrkSaveOrResume_Resume  ; get flag resume game
                            sta TabWrkSaveOrResume          ; set flag resume game
                            
                            jsr CastleDataResumeFileName    ; request castle data resume file name
                            
                            ldx TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            beq CastleDataResumeFileLoadX   ; check: ZERO - yes: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; copy input file name to load file name buffer
; --------------------------------------------------------------------------------------------------------------------- ;
CopyNextResumeFileNameChar  dex                             ; dec length of resume file name
                            bmi InitResumeFile              ; check: min - yes: done
                            
                            lda TabWrkTextInputBuf,x        ; get input filename char
                            sta TabWrkLoadFile,x            ; copy to load file name buffer
                            
                            jmp CopyNextResumeFileNameChar  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare resume game file load
; --------------------------------------------------------------------------------------------------------------------- ;
InitResumeFile              lda TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            sta TabWrkLoadFile_Len          ; 
                            
                            lda #TabFlagLoadMem_Game        ; get flag select memory CC_GameDataBuf
                            sta TabFlagLoadMem              ; set flag target memory area
                            
                            jsr CastleDataPrepareDiskIO     ; switch KERNAL back on
                            jsr CastleDataVerifyDisk        ; verify the master disk name of DUNGEONMASTER
                            cmp #$01                        ; test flag Master Disk Name Not Found
                            beq ResumeSaveGameFile          ; check: RQ - no: user disk - load the save game file
; --------------------------------------------------------------------------------------------------------------------- ;
; no file resumes allowed from the master disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
                            jmp CastleDataResumeFileLoadX   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ResumeSaveGameFile          jsr CastleDataFileLoad          ; load a file from disk
                            jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            sta TabWrkResumeDiskStatus      ; save the disk status byte
                            
                            jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
                            
                            lda TabWrkResumeDiskStatus      ; restore the disk status byte
                            cmp #$40                        ; test flag EndOfFile
                            bne CastleDataResumeFileLoadX   ; check: NE - yes: load saved game failed
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag resume game successful
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkFlagGameResumed_OK   ; 
                            sta TabWrkFlagGameResumed       ; set status of load a saved game
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataResumeFileLoadX   pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkFlagGameResumed       .byte TabWrkFlagGameResumed_Ini ; status load a saved game
TabWrkFlagGameResumed_Ini       = $00 ; 
TabWrkFlagGameResumed_OK        = $01 ; 
TabWrkResumeDiskStatus      .byte $90 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDataSaveFileGame    Does    : save an ongoing game to a file on an user disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataSaveFileGame     .block                           ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkSaveOrResume_Save    ; 
                            sta TabWrkSaveOrResume          ; 
                            
                            jsr CastleDataResumeFileName    ; request castle data resume file name
                            
                            ldx TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            beq CastleDataSaveFileGameX     ; check: ZERO - yes: exit no filename
                            
CopyNextSaveFileNameChar    dex                             ; 
                            bmi VerifyDisk                  ; check: min - yes: done
                            
                            lda TabWrkTextInputBuf,x        ; copy resume file name from input buffer
                            sta TabWrkSaveFile_Name_Id,x    ; 
                            
                            jmp CopyNextSaveFileNameChar    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; verify the disk in drive
; --------------------------------------------------------------------------------------------------------------------- ;
VerifyDisk                  lda TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            sta TabWrkSaveFile_Name_Len     ; 
                            
                            lda #TabWrkFlagSaveDataAdr_Game ; 
                            sta TabWrkFlagSaveDataAdr       ; 
                            
                            jsr CastleDataPrepareDiskIO     ; switch KERNAL back on
                            jsr CastleDataVerifyDisk        ; verify the master disk name of DUNGEONMASTER
                            cmp #$01                        ; test flag master disk not found
                            bne HandleErrors                ; check: NE - yes: master disk or disk error
; --------------------------------------------------------------------------------------------------------------------- ;
; user disk - save the game only if no master disk is in drive
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr CastleDataFileSave          ; replace the castle data resume file
                            jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            cmp #$00                        ; test OK
                            bne HandleErrors                ; check: NE - yes: failure
                            
                            jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
                            jmp CastleDataSaveFileGameX     ; exit
; --------------------------------------------------------------------------------------------------------------------- ;
; saves are not allowed on master disk
; --------------------------------------------------------------------------------------------------------------------- ;
HandleErrors                jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
                            
                            cmp #$00                        ; test master disk found
                            beq OutText_NotOnMaster         ; check: master disk
; --------------------------------------------------------------------------------------------------------------------- ;
; announce disk error
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabText_IO_Error          ; get adrress disk IO error message
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            
                            lda #>TabText_IO_Error          ; 
                            jmp SetMsgTexPtr_Hi             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; announce game saves on master disk are disallowed
; --------------------------------------------------------------------------------------------------------------------- ;
OutText_NotOnMaster         lda #<TabText_NoSavesOnMaster   ; get address disk no master disk saves error message
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            
                            lda #>TabText_NoSavesOnMaster   ; 
                            
SetMsgTexPtr_Hi             sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
                            jsr DrawText                    ; write out the selected error message
                            
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            
                            lda #$23                        ; get count of IRQs to wait
                            jsr WaitSomeIrqCycles           ; wait
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataSaveFileGameX     pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_NoSavesOnMaster     = * ; 
                            .byte $10       ; StartPosX
                            .byte $40       ; StartPosY
                            .byte LT_RED    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "y"       ; Text: you cannot save your
                            .byte "o"       ; 
                            .byte "u"       ; 
                            .byte " "       ; 
                            .byte "c"       ; 
                            .byte "a"       ; 
                            .byte "n"       ; 
                            .byte "n"       ; 
                            .byte "o"       ; 
                            .byte "t"       ; 
                            .byte " "       ; 
                            .byte "s"       ; 
                            .byte "a"       ; 
                            .byte "v"       ; 
                            .byte "e"       ; 
                            .byte " "       ; 
                            .byte "y"       ; 
                            .byte "o"       ; 
                            .byte "u"       ; 
                            .byte "r" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $24       ; StartPosX
                            .byte $58       ; StartPosY
                            .byte LT_RED    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "p"       ; Text: position to the
                            .byte "o"       ; 
                            .byte "s"       ; 
                            .byte "i"       ; 
                            .byte "t"       ; 
                            .byte "i"       ; 
                            .byte "o"       ; 
                            .byte "n"       ; 
                            .byte " "       ; 
                            .byte "t"       ; 
                            .byte "o"       ; 
                            .byte " "       ; 
                            .byte "t"       ; 
                            .byte "h"       ; 
                            .byte "e" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $34       ; StartPosX
                            .byte $70       ; StartPosY
                            .byte LT_RED    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "m"       ; Text: master disk
                            .byte "a"       ; 
                            .byte "s"       ; 
                            .byte "t"       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte " "       ; 
                            .byte "d"       ; 
                            .byte "i"       ; 
                            .byte "s"       ; 
                            .byte "k" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_IO_Error            = * ; 
                            .byte $3c       ; StartPosX
                            .byte $50       ; StartPosY
                            .byte LT_RED    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "i"       ; Text: i/o error
                            .byte "/"       ; 
                            .byte "o"       ; 
                            .byte " "       ; 
                            .byte "e"       ; 
                            .byte "r"       ; 
                            .byte "r"       ; 
                            .byte "o"       ; 
                            .byte "r" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDataResumeFileName  Does    : request castle data resume file name
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataResumeFileName   .block                           ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr InitHiResMemAndSpriteWA     ; init the hires screen and mark the sprite work areas as free
; --------------------------------------------------------------------------------------------------------------------- ;
; type info line #1
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabText_Resume_FileName   ; Text:  type in file name
                            sta CCZ_DrawItemDataPtr_Lo      ;       followed by RETURN
                            lda #>TabText_Resume_FileName   ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr CastleRoomDrawHandler       ; control drawing the castle room items
                            
                            lda TabWrkSaveOrResume          ; get flag save or resume
                            beq SetHeaderLine_Save          ; check: Save - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; type screen header line resume game
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabText_Resume_Header     ; Text: resume game
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_Resume_Header     ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jmp DisplayHeaderLine           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; type screen header line save position
; --------------------------------------------------------------------------------------------------------------------- ;
SetHeaderLine_Save          lda #<TabText_Save_Header       ; Text: save position
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabText_Save_Header       ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
DisplayHeaderLine           jsr CastleRoomDrawHandler       ; control drawing the castle room items
                            
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_DEN_ON              ; insert display enable on
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            
                            lda #$20                        ; 
                            sta TabWrkTextInput_PosX        ; 
                            lda #$48                        ; 
                            sta TabWrkTextInput_PosY        ; 
                            
                            lda #$10                        ; get max input line length
                            sta TabWrkTextInput_Len_Max     ; set max input line length
                            
                            lda #WHITE                      ; 
                            sta TabWrkTextInput_Color       ; 
                            
                            lda #CC_TextLine_Style_Height_Dbl ; 
                            sta TabWrkTextInput_Style       ; 
                            
                            jsr TextLineInputHandler        ; get an input text line
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSaveOrResume         .byte $a0 ; 
TabWrkSaveOrResume_Save        = $00 ; 
TabWrkSaveOrResume_Resume      = $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_Save_Header         = * ; 
                            .word DrawText  ; 
                            
                            .byte $2c       ; StartPosX
                            .byte $00       ; StartPosY
                            .byte WHITE     ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "s"       ; Text: save position
                            .byte "a"       ; 
                            .byte "v"       ; 
                            .byte "e"       ; 
                            .byte " "       ; 
                            .byte "p"       ; 
                            .byte "o"       ; 
                            .byte "s"       ; 
                            .byte "i"       ; 
                            .byte "t"       ; 
                            .byte "i"       ; 
                            .byte "o"       ; 
                            .byte "n" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText = 00
                            
                            .word $0000     ; EndOfRoomData
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_Resume_Header       = * ; 
                            .word DrawText  ; 
                            
                            .byte $34       ; StartPosX
                            .byte $00       ; StartPosY
                            .byte WHITE     ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Dbl ; Format = normal/double size
                            .byte "r"       ; Text: resume game
                            .byte "e"       ; 
                            .byte "s"       ; 
                            .byte "u"       ; 
                            .byte "m"       ; 
                            .byte "e"       ; 
                            .byte " "       ; 
                            .byte "g"       ; 
                            .byte "a"       ; 
                            .byte "m"       ; 
                            .byte "e" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText = 00
                            
                            .word $0000     ; EndOfRoomData
; --------------------------------------------------------------------------------------------------------------------- ;
TabText_Resume_FileName     = * ; 
                            .word DrawText  ; 
                            
                            .byte $1c       ; StartPosX
                            .byte $30       ; StartPosY
                            .byte LT_GREEN  ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "t"       ; Text: type in file name
                            .byte "y"       ; 
                            .byte "p"       ; 
                            .byte "e"       ; 
                            .byte " "       ; 
                            .byte "i"       ; 
                            .byte "n"       ; 
                            .byte " "       ; 
                            .byte "f"       ; 
                            .byte "i"       ; 
                            .byte "l"       ; 
                            .byte "e"       ; 
                            .byte " "       ; 
                            .byte "n"       ; 
                            .byte "a"       ; 
                            .byte "m"       ; 
                            .byte "e" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $18       ; StartPosX
                            .byte $38       ; StartPosY
                            .byte LT_GREEN  ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "f"       ; Text: followed by
                            .byte "o"       ; 
                            .byte "l"       ; 
                            .byte "l"       ; 
                            .byte "o"       ; 
                            .byte "w"       ; 
                            .byte "e"       ; 
                            .byte "d"       ; 
                            .byte " "       ; 
                            .byte "b"       ; 
                            .byte "y" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $78       ; StartPosX
                            .byte $38       ; StartPosY
                            .byte LT_GREEN  ; Color
                            .byte CC_TextLine_Style_Set_Revrs | CC_TextLine_Style_Height_Sng ; Format = reverse/normal size
                            .byte "r"       ; Text: return
                            .byte "e"       ; 
                            .byte "t"       ; 
                            .byte "u"       ; 
                            .byte "r"       ; 
                            .byte "n" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $20       ; StartPosX
                            .byte $78       ; StartPosY
                            .byte LT_RED    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "p"       ; Text: press_________to
                            .byte "r"       ; 
                            .byte "e"       ; 
                            .byte "s"       ; 
                            .byte "s"       ; 
                            
                            .byte " "       ; blank - placeholder filled with snippets below
                            .byte " "       ; 
                            .byte " "       ; 
                            .byte " "       ; 
                            .byte " "       ; 
                            .byte " "       ; 
                            .byte " "       ; 
                            .byte " "       ; 
                            .byte " "       ; 
                            
                            .byte "t"       ; 
                            .byte "o" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $50       ; StartPosX
                            .byte $78       ; StartPosY
                            .byte LT_RED    ; Color
                            .byte CC_TextLine_Style_Set_Revrs | CC_TextLine_Style_Height_Sng ; Format = reverse/normal size
                            .byte "r"       ; Text: restore
                            .byte "e"       ; 
                            .byte "s"       ; 
                            .byte "t"       ; 
                            .byte "o"       ; 
                            .byte "r"       ; 
                            .byte "e" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $48       ; StartPosX
                            .byte $80       ; StartPosY
                            .byte LT_RED    ; Color
                            .byte CC_TextLine_Style_Set_Norml | CC_TextLine_Style_Height_Sng ; Format = normal/normal size
                            .byte "c"       ; Text: cancel
                            .byte "a"       ; 
                            .byte "n"       ; 
                            .byte "c"       ; 
                            .byte "e"       ; 
                            .byte "l" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $00       ; EndOfText = 00
                            
                            .word $0000     ; EndOfRoomData
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextLineInputHandler      Does    : get an input text line
;                           Expects : TabWrkTextInput_Len_Max=max input buffer lenght
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextLineInputHandler       .block                           ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkKey_Restore_No       ; get initial value
                            sta TabWrkKey_Restore           ; init flag no <RESTORE> key pressed
; --------------------------------------------------------------------------------------------------------------------- ;
; pick up the mandatory parameters
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkTextInput_Color       ; get parm: text color
                            sta TabWrkTextLine_Color        ; 
                            
                            lda TabWrkTextInput_Style       ; get parm: text format
                            ora #CC_TextLine_Style_Set_Norml; insert non reversed charset
                            sta TabWrkTextLine_Style        ; 
                            
                            lda TabWrkTextInput_PosX        ; get parm: text PosX
                            sta TabWrkTextLine_PosX         ; 
                            
                            lda TabWrkTextInput_PosY        ; get parm: text PosY
                            sta TabWrkTextLine_PosY         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init the text input line with the empty text placeholder
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #"-"                        ; get empty input char placeholder
                            sta TabWrkTextChar              ; set as output char
                            
                            ldx TabWrkTextInput_Len_Max     ; get max input line length
OutNextPlaceholderChar      cpx #$00                        ; test all chars processed
                            beq IniInputTextLineBuf_Off     ; check: EQ - yes: init input buffer offset
                            
                            jsr TextSingleCharOut           ; output a single char as room item text
                            
                            dex                             ; dec amount of output chars
; --------------------------------------------------------------------------------------------------------------------- ;
; set output char gfx pointer to next position
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkTextLine_PosX         ; 
                            adc #$04 * $02                  ; add double room draw grid width - step two room grid position right
                            sta TabWrkTextLine_PosX         ; 
                            
                            jmp OutNextPlaceholderChar      ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
; handle cursor the rotating wait input cursor char
; --------------------------------------------------------------------------------------------------------------------- ;
IniInputTextLineBuf_Off     stx TabWrkTextInputBuf_Max      ; init the actual input buffer high water mark
                            
OutNextCursorChar           lda TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            cmp TabWrkTextInput_Len_Max     ; test max input line length
                            beq GetAnInputKey               ; check: EQ - yes: simply get a new key - do not output the cursor
; --------------------------------------------------------------------------------------------------------------------- ;
; select next output cursor char
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkCharCursor_Off        ; set next cursor char num
                            
                            lda TabWrkCharCursor_Off        ; get actual cursor char
                            and #TabCharNumCursor_Len       ; limit to max cursor char table length
                            tax                             ; set as offset
                            
                            lda TabCharNumCursor,x          ; get next cursor char
                            sta TabWrkTextChar              ; set as output char
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate the cursor column position
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - room item text char width
                            clc                             ; 
                            adc TabWrkTextInput_PosX        ; 
                            sta TabWrkTextLine_PosX         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; paint the cursor as a room item text char
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TextSingleCharOut           ; output a single char as room item text
; --------------------------------------------------------------------------------------------------------------------- ;
; get an input key value
; --------------------------------------------------------------------------------------------------------------------- ;
GetAnInputKey               jsr InputKeyGetSubstValue       ; get a substitution value for the pressed key
                            
                            cmp #$80                        ; test flag illegal key pressed
                            bne ChkKey_Delete               ; check: EQ - no: valid key found
; --------------------------------------------------------------------------------------------------------------------- ;
; illegal key found - but handle restore key to exit input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkKey_Restore           ; get <RESTORE> key flag
                            cmp #TabWrkKey_Restore_Yes      ; test flag <RESTORE> key pressed
                            beq IniWait_Restore             ; check: EQ - yes 
                            
                            lda #$03                        ; get initial value
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            
DebounceBad_Input           lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne DebounceBad_Input           ; check: EndOfWait - no: continue
                            
                            jmp OutNextCursorChar           ; blink cursor
; --------------------------------------------------------------------------------------------------------------------- ;
; handle restore key  -exit input
; --------------------------------------------------------------------------------------------------------------------- ;
IniWait_Restore             lda #$00                        ; get initial value
                            sta TabWrkTextInputBuf_Max      ; init the actual input buffer high water mark
                            
GetNextFlag_Restore         lda #TabWrkKey_Restore_No       ; 
                            sta TabWrkKey_Restore           ; set flag no <RESTORE> key pressed
                            
                            lda #$03                        ; get initial value
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            
Debounce_Restore            lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne Debounce_Restore            ; check: EndOfWait - no: continue
                            
                            lda TabWrkKey_Restore           ; 
                            cmp #TabWrkKey_Restore_No       ; test flag no <RESTORE> key pressed
                            bne GetNextFlag_Restore         ; check: NE - yes: continue
                            
                            jmp TextLineInputHandlerX       ; exit NoInput
; --------------------------------------------------------------------------------------------------------------------- ;
; check <DELETE> key
; --------------------------------------------------------------------------------------------------------------------- ;
ChkKey_Delete               cmp #$08                        ; test DELETE
                            bne ChkKey_Return               ; check: EQ - no: check RETURN
                            
                            lda TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            cmp TabWrkTextInput_Len_Max     ; test max input line length
                            beq TestLeftmostBufPos          ; check: EQ - yes: test leftmost buffer pos
                            
                            lda #"-"                        ; get empty input char placeholder
                            sta TabWrkTextChar              ; set as deelte output char
                            jsr TextSingleCharOut           ; output the placeholder char as room item text
                            
TestLeftmostBufPos          lda TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            beq DiplayNextCursorChar        ; check: leftmost postion - yes: blink cursor
                            
                            dec TabWrkTextInputBuf_Max      ; dec the actual input buffer high water mark
                            
DiplayNextCursorChar        jmp OutNextCursorChar           ; blink cursor
; --------------------------------------------------------------------------------------------------------------------- ;
; check <RETURN> key
; --------------------------------------------------------------------------------------------------------------------- ;
ChkKey_Return               cmp #CR                         ; test <RETURN>
                            bne OutNewInputChar             ; check: NE - yes: output the char as room item text
                            
                            jmp TextLineInputHandlerX       ; exit EndOfInput
; --------------------------------------------------------------------------------------------------------------------- ;
; store the input char and advance the input buffer pointer
; --------------------------------------------------------------------------------------------------------------------- ;
OutNewInputChar             ldx TabWrkTextInputBuf_Max      ; get the actual input buffer high water mark
                            cpx TabWrkTextInput_Len_Max     ; test max input line length
                            beq DiplayNextCursorChar        ; check: EQ - yes: simply output the char
                            
                            sta TabWrkTextInputBuf,x        ; write to buffer
                            
                            inx                             ; inc the input buffer position
                            stx TabWrkTextInputBuf_Max      ; set the new input buffer high water mark
                            
                            sta TabWrkTextChar              ; set as output char
                            jsr TextSingleCharOut           ; output a single char as room item text
                            jmp OutNextCursorChar           ; blink cursor
; --------------------------------------------------------------------------------------------------------------------- ;
TextLineInputHandlerX       pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextSingleCharOut         Does    : output a single char as room item text
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextSingleCharOut          .block                           ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; limit output to one char
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkTextChar              ; get output char
                            ora #$80                        ; insert flag EndOfLine
                            sta TabWrkTextChar              ; set output char
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to output char
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabWrkTextChar            ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            lda #>TabWrkTextChar            ; 
                            sta CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jsr DrawTextLine                ; draw a single text line of the selected height and style
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkTextInput_PosX        .byte $a0 ; 
TabWrkTextInput_PosY        .byte $a0 ; 
TabWrkTextInput_Color       .byte $a4 ; 
TabWrkTextInput_Style       .byte $b2 ; 
TabWrkTextInput_Len_Max     .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkTextInputBuf_Max      .byte $ff ; high water mark of the text input buffer
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkTextInputBuf          = *       ; buffer input text line
                            .byte $a0 ; 
                            .byte $e5 ; 
                            .byte $b2 ; 
                            .byte $a4 ; 
                            .byte $b2 ; 
                            .byte $a0 ; 
                            .byte $c8 ; 
                            .byte $c4 ; 
                            .byte $96 ; 
                            .byte $a0 ; 
                            .byte $cc ; 
                            .byte $a0 ; 
                            .byte $a0 ; 
                            .byte $b2 ; 
                            .byte $a0 ; 
                            .byte $a0 ; 
                            .byte $a0 ; 
                            .byte $a5 ; 
                            .byte $a0 ; 
                            .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkTextChar              .byte $ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkCharCursor_Off        .byte $b9 ; 
TabCharNumCursor            = *       ; 
                            .byte $6c ; $00
                            .byte $7b ; $01
                            .byte $7e ; $02
                            .byte $7c ; $03
TabCharNumCursor_Len = * - TabCharNumCursor - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; InputKeyGetSubstValue     Does    : get a substitution value for the pressed key
;                           Expects : 
;                           Returns : .A=substitution value for the pressed key
; --------------------------------------------------------------------------------------------------------------------- ;
InputKeyGetSubstValue      .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta TabWrkKeySubstBuf_Off       ; init actual key substition buffer offset
                            sta TabWrkKeyMatrixSubst_Off    ; init actual offset TabKeyMatrixSubst
                            
                            lda #~CIAPRA_KEY_SEL_ROW_0      ; #######. - get inital value for row0
                            sta TabWrkKeyMatrixScan_Row     ; init actual keyboard scan row mask
; --------------------------------------------------------------------------------------------------------------------- ;
; init scan all keyboard rows
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; init ALL keyboard OUT-puts
                            sta CIADDRA                     ; CIA1($DC02) Data Direction Register A
                            lda #$00                        ; init ALL keyboard IN-puts
                            sta CIADDRB                     ; CIA1($DC03) Data Direction Register B
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the keyboard rows and get the scan result
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextKeyboardScanMask     lda TabWrkKeyMatrixScan_Row     ; set actual keyboard scan row mask
                            sta CIAPRA                      ; CIA1($DC00) Data Port Register A - set scan row
                            
                            lda CIAPRB                      ; CIA1($DC01) Data Port Register B - get result row
                            sta TabWrkKeyMatrixResult_Row   ; get actual scan keyboard row scan result mask
                            
                            lda #$07                        ; init result row column bit count to max
                            sta TabWrkKeyMatrix_Col_Count   ; set row column bit number
; --------------------------------------------------------------------------------------------------------------------- ;
; test all the result colum bits for sa pressed key
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextScanResultRow        lsr TabWrkKeyMatrixResult_Row   ; shift all column bits out
                            bcs SetNextKeySubstOff          ; check: key pressed - no: set next
; --------------------------------------------------------------------------------------------------------------------- ;
; found a key - try to substitute it
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkKeyMatrixSubst_Off    ; get actual offset TabKeyMatrixSubst
                            lda TabKeyMatrixSubst,x         ; get a key substitution value
                            bmi SetNextKeySubstOff          ; check: bad key - yes: ignore
; --------------------------------------------------------------------------------------------------------------------- ;
; store the accepted key found
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkKeySubstBuf_Off       ; get actual key substition buffer offset
                            sta TabWrkKeySubstBuf,x         ; fill the key result table
                            
                            inx                             ; inc result table offset
                            stx TabWrkKeySubstBuf_Off       ; set next actual key substition buffer offset
                            
                            cpx #TabWrkKeySubstBuf_Len      ; test with result table offset max 
                            beq InitResultTabOff            ; check: EQ - yes: restart at begin of table
; --------------------------------------------------------------------------------------------------------------------- ;
; advance key substitotion offset and scan row column counter
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextKeySubstOff          inc TabWrkKeyMatrixSubst_Off    ; advance actual offset TabKeyMatrixSubst
                            
                            dec TabWrkKeyMatrix_Col_Count   ; set next set row column bit count
                            bpl SetNextScanResultRow        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; all row columns processed - set next scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; set .C for roll in
                            rol TabWrkKeyMatrixScan_Row     ; select next keyboard scan row
                            bcs GetNextKeyboardScanMask     ; check: all rows processed - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; TabWrkKeyMatrixScan_Row   #######. - row_0
;                           ######.# - row_1 
;                           #####.## - row_2 
;                           ####.### - row_3 
;                           ###.#### - row_4 
;                           ##.##### - row_5 
;                           #.###### - row_6 
;                           .####### - row_7 - last ROL clears the carry and ends the scan
;                           ######## - EndOfScan
; --------------------------------------------------------------------------------------------------------------------- ;
; pick up the entered key value from table
; --------------------------------------------------------------------------------------------------------------------- ;
InitResultTabOff            ldx #$00                        ; init key substition buffer offset
ChkNextResultTabOff         cpx TabWrkKeySubstBuf_Off       ; test with actual key substition buffer offset
                            beq GetKey_Illegal              ; check: not found or none - yes: return flag illegal or none
; --------------------------------------------------------------------------------------------------------------------- ;
; compare result buffer of this scan with result buffer previous scan
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; init key result table offset
ChkNextTabOff_Previous      cpy TabWrkKeySubstBuf_Off_Last  ; test with previous key substition buffer offset
                            beq GetKey_Found                ; check: EQ - yes: same entry found - done
                            
                            lda TabWrkKeySubstLastBuf,y     ; get previous result table entry
                            cmp TabWrkKeySubstBuf,x         ; test with actual table entry
                            beq SetTabOff_Actual            ; check: EQ - yes: advance actual scan result table offset
                            
                            iny                             ; inc previous scan result table offset
                            jmp ChkNextTabOff_Previous      ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
SetTabOff_Actual            inx                             ; inc actual scan result table offset
                            jmp ChkNextResultTabOff         ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
; get illegal key found or no key pressed
; --------------------------------------------------------------------------------------------------------------------- ;
GetKey_Illegal              lda #$80                        ; get flag illegal key or none
                            jmp SetKey_Found                ; temp store key found value
; --------------------------------------------------------------------------------------------------------------------- ;
; get legal key found
; --------------------------------------------------------------------------------------------------------------------- ;
GetKey_Found                lda TabWrkKeySubstBuf,x         ; get key found
; --------------------------------------------------------------------------------------------------------------------- ;
; store the substitution value of this pressed key
; --------------------------------------------------------------------------------------------------------------------- ;
SetKey_Found                sta TabWrkKeyFound_Save         ; save the substituted key
                            
                            ldx TabWrkKeySubstBuf_Off       ; get actual key substition buffer offset
                            stx TabWrkKeySubstBuf_Off_Last  ; save to previous key substition buffer offset
; --------------------------------------------------------------------------------------------------------------------- ;
; copy result buffer of this scan to result buffer previous scan
; --------------------------------------------------------------------------------------------------------------------- ;
CopyNextInputKey            dex                             ; dec key substition buffer offset
                            bmi GameGetInputKeyX            ; check: min - yes: done
                            
                            lda TabWrkKeySubstBuf,x         ; get key value found
                            sta TabWrkKeySubstLastBuf,x     ; save key value found
                            
                            jmp CopyNextInputKey            ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
GameGetInputKeyX            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get the return key value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkKeyFound_Save         ; restore the substituted key
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabKeyMatrixSubst           = *       ; key matrix substitution value table
TabKeyMatrixSubstColBit_0   = *       ; 
                            .byte $08 ; good: DELETE
                            .byte $0d ; good: RETURN
                            .byte $08 ; good: CRSR_R - mapped to DELETE
                            .byte $80 ; bad : F7
                            .byte $80 ; bad : F1
                            .byte $80 ; bad : F3
                            .byte $80 ; bad : F5
                            .byte $80 ; bad : CRSR_D
TabKeyMatrixSubstColBit_1   = *       ; 
                            .byte $33 ; good: 3
                            .byte $57 ; good: W
                            .byte $41 ; good: A
                            .byte $34 ; good: 4
                            .byte $5a ; good: Z
                            .byte $53 ; good: S
                            .byte $45 ; good: E
                            .byte $80 ; bad : LSHIFT
TabKeyMatrixSubstColBit_2   = *       ; 
                            .byte $35 ; good: 5
                            .byte $52 ; good: R
                            .byte $44 ; good: D
                            .byte $36 ; good: 6
                            .byte $43 ; good: C
                            .byte $46 ; good: F
                            .byte $54 ; good: T
                            .byte $58 ; good: X
TabKeyMatrixSubstColBit_3   = *       ; 
                            .byte $37 ; good: 7
                            .byte $59 ; good: Y
                            .byte $47 ; good: G
                            .byte $38 ; good: 8
                            .byte $42 ; good: B
                            .byte $48 ; good: H
                            .byte $55 ; good: U
                            .byte $56 ; good: V
TabKeyMatrixSubstColBit_4   = *       ; 
                            .byte $39 ; good: 9
                            .byte $49 ; good: I
                            .byte $4a ; good: J
                            .byte $30 ; good: 0
                            .byte $4d ; good: M
                            .byte $4b ; good: K
                            .byte $4f ; good: O
                            .byte $4e ; good: N
TabKeyMatrixSubstColBit_5   = *       ; 
                            .byte $2b ; good: +
                            .byte $50 ; good: P
                            .byte $4c ; good: L
                            .byte $2d ; good: -
                            .byte $2e ; good: .
                            .byte $3a ; good: :
                            .byte $40 ; good: @
                            .byte $2c ; good: ,
TabKeyMatrixSubstColBit_6   = *       ; 
                            .byte $80 ; bad : LIRA
                            .byte $2a ; good: *
                            .byte $3b ; good: ;
                            .byte $80 ; bad : HOME
                            .byte $80 ; bad : RSHIFT
                            .byte $3d ; good: =
                            .byte $80 ; bad : ^
                            .byte $2f ; good: /
TabKeyMatrixSubstColBit_7   = *       ; 
                            .byte $31 ; good: 1
                            .byte $08 ; good: <-
                            .byte $80 ; bad : CTRL
                            .byte $32 ; good: 2
                            .byte $20 ; good: SPACE
                            .byte $80 ; bad : C=
                            .byte $51 ; good: Q
                            .byte $80 ; bad : STOP
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkKeySubstBuf_Off       .byte $a0 ; actual key substition buffer offset
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkKeySubstBuf           = *       ; 
                            .byte $a0 ; 
                            .byte $d2 ; 
                            .byte $a0 ; 
TabWrkKeySubstBuf_Len       = * - TabWrkKeySubstBuf ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkKeySubstBuf_Off_Last  .byte $00 ; previous key substition buffer offset
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkKeySubstLastBuf       = *       ; 
                            .byte $b2 ; 
                            .byte $c6 ; 
                            .byte $c8 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkKeyMatrixScan_Row     .byte $a0 ; actual keyboard scan row mask
TabWrkKeyMatrixResult_Row   .byte $ae ; 
TabWrkKeyMatrixSubst_Off    .byte $a0 ; actual offset TabKeyMatrixSubst
TabWrkKeyFound_Save         = *       ; save substituted key
TabWrkKeyMatrix_Col_Count   .byte $ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDataFileSave        Does    : save/replace a file on disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataFileSave         .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; preparation
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$02                        ; get logical file number
                            ldx #FA_DISK                    ; get device number #8
                            ldy #$00                        ; get secondary address - LOAD file to address in .X.Y
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            
                            clc                             ; 
                            lda TabWrkSaveFile_Name_Len     ; get save filename length
                            adc #$03                        ; add replace file header length  
                            ldx #<TabWrkSaveFile_Name_Full  ; filename with replace file header
                            ldy #>TabWrkSaveFile_Name_Full  ; 
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
; --------------------------------------------------------------------------------------------------------------------- ;
; set the source start memory pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkFlagSaveDataAdr       ; get flag save memory target address
                            asl a                           ; *2
                            tax                             ; set as offset
                            
                            lda TabSaveFileSourceMem + $00,x; get address source memory
                            sta CCZ_SaveFileSourcePtr_Lo    ; 
                            lda TabSaveFileSourceMem + $01,x; 
                            sta CCZ_SaveFileSourcePtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set the source end memory register values
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldy #$00                        ; get offset length of file
                            lda (CCZ_SaveFileSourcePtr),y   ; get lenght of file Lo
                            adc CCZ_SaveFileSourcePtr_Lo    ; 
                            tax                             ; set end address + $01 Lo
                            
                            iny                             ; inc offset lenght of file
                            
                            lda (CCZ_SaveFileSourcePtr),y   ; get lenght of file Hi
                            adc CCZ_SaveFileSourcePtr_Hi    ; 
                            tay                             ; set end address + $01 Hi
                            
                            lda #CCZ_SaveFileSourcePtr_Lo   ; get indirect ZP pointer to start memory address
                            jsr SAVE                        ; Kernal($FFD8) Save to a device (via $332 to $F5DD)
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkFlagSaveDataAdr       .byte $a0 ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
TabWrkFlagSaveDataAdr_Game      = $00 ; flag: $00=$7800 - actual level data for play
TabWrkFlagSaveDataAdr_Times     = $02 ; flag: $02=$b800 - loaded best times
TabWrkSaveFile_Name_Len     .byte $ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSaveFile_Name_Full    = *       ; 
                            .byte "@" ; header: replace a file 
                            .byte "0" ; 
                            .byte ":" ; 
TabWrkSaveFile_Name_Id      .byte $f0 ; 
TabWrkSaveFile_Name         = *       ; 
                            .byte $b0 ; 
                            .byte $b1 ; 
                            .byte $b2 ; 
                            .byte $a0 ; 
                            .byte $f0 ; 
                            .byte $a0 ; 
                            .byte $96 ; 
                            .byte $a0 ; 
                            .byte $a0 ; 
                            .byte $b8 ; 
                            .byte $a0 ; 
                            .byte $85 ; 
                            .byte $a0 ; 
                            .byte $d3 ; 
                            .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSaveFileSourceMem        = *       ; 
                            .word CC_GameDataBuf
                            .word CC_LoadDataBuf   
                            .word CC_TimeDataBuf 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDataFileLoad        Does    : load a file from disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataFileLoad         .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$02                        ; get logical file number
                            ldx #FA_DISK                    ; get drive number #8
                            ldy #$00                        ; get secondary address - LOAD file to address in .X.Y
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            
                            lda TabWrkLoadFile_Len          ; get filename parms
                            ldx #<TabWrkLoadFile            ; 
                            ldy #>TabWrkLoadFile            ; 
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            
                            lda #$00                        ; get flag LOAD
                            ldx TabFlagLoadMem              ; get flag target memory area
                            ldy TabLoadFileTargetMem_Hi,x   ; get LOAD target address HI
                            ldx #<CC_GameDataBuf            ; get LOAD target address LO - same for all mem areas
                            jsr LOAD                        ; Kernal($FFD5) Load from device (via $330 to $F49E)
                            
                            stx TabWrkLoadFileDataEnd_Lo    ; 
                            sty TabWrkLoadFileDataEnd_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabLoadFileTargetMem_Hi     = * ; 
                            .byte >CC_GameDataBuf ; 
                            .byte >CC_LoadDataBuf ; 
                            .byte >CC_TimeDataBuf ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDataPrepareDiskIO   Does    : switch KERNAL back on
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataPrepareDiskIO    .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get disable all VIC IRQs
                            sta IRQMASK                     ; VIC($D01A) IRQ Mask Register
                            
                            lda #CIAICR_SC_CLR_ALL          ; .####### - Clear All Interrupt Sources
                            sta CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            
                            lda CIAICR                      ; CIA1($DC0D) Interrupt Control - Cleared on read
                            
                            lda #D6510_CHAREN_OUT | D6510_HIRAM_OUT | D6510_LORAM_OUT ; 
                            sta D6510                       ; 
                            
                            lda #D6510_CHAREN_OUT | D6510_HIRAM_OUT & D6510_LORAM_IN  ; 
                            sta R6510                       ; 
                            
                            jsr IOINIT                      ; Kernal($FF84) Init I/O devices ($FDA3)
                            
                            lda #D6510_CHAREN_OUT | D6510_HIRAM_OUT | D6510_LORAM_OUT ; 
                            sta D6510                       ; 
                            
                            lda #CHAREN_IO_ON | HIRAM_KERNAL_ON & LORAM_BASIC_OFF     ; 
                            sta R6510                       ; 
                            
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            and #SCROLY_BMM_ON              ; 
                            beq CastleDataPrepareDiskIOX    ; check: BMM - no: exit
                            
                            lda CI2DDRA                     ; CIA2($DD02) Data Dir A
                            ora #CI2DDRA_BANK_B1 | CI2DDRA_BANK_B0 ; set bit0-1 to output
                            sta CI2DDRA                     ; CIA2($DD02) Data Dir A
                            
                            lda CI2PRA                      ; CIA2($DD00) Data Port A - Bits 0-1 = VIC mem bank
                            and #~CI2PRA_VIC_BANK           ; set bank 3 - $c000-$ffff
                            sta CI2PRA                      ; CIA2($DD00) Data Port A - Bits 0-1 = VIC mem bank
                            
                            lda TabFlagColdStart_Done       ; 
                            cmp #TabFlagColdStart_Done_No   ; test flag end of cold start
                            bne CastleDataPrepareDiskIOX    ; check: NE - yes
                            
                            lda #YELLOW                     ; 
                            sta EXTCOL                      ; VIC($D020) Border Color
                            
                            lda #WHITE                      ; 
                            sta BGCOL0                      ; VIC($D021) Background Color 0
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDataPrepareDiskIOX    pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameWaitAndWarmStart      Does    : wait and exec GameWarmStart
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameWaitAndWarmStart       .block                           ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$f8                        ; get wait time
                            sta TabWrkWaitTimeRestart_Lo    ; 
                            sta TabWrkWaitTimeRestart_Mid   ; 
                            sta TabWrkWaitTimeRestart_Hi    ; 
                            
IncNextWaitTime_Lo          inc TabWrkWaitTimeRestart_Lo    ; 
                            bne IncNextWaitTime_Lo          ; check: max - no: continue
                            
                            inc TabWrkWaitTimeRestart_Mid   ; 
                            bne IncNextWaitTime_Lo          ; check: max - no: continue
                            
                            inc TabWrkWaitTimeRestart_Hi    ; 
                            bne IncNextWaitTime_Lo          ; check: max - no: continue
                            
                            jsr GameWarmStart               ; set up the machine for game play
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkLoadFile              = * ; 
TabWrkLoadFile_ID           .byte $ef ; Y/Z for level times/level data
TabWrkLoadFile_ID_Dir         = "$"   ; ID for a disk directory
TabWrkLoadFile_ID_Data        = "z"   ; ID for a castle data file
TabWrkLoadFile_ID_Time        = "y"   ; ID for a castle escape time leader board file
TabWrkLoadFile_Name         = *       ; level file name part
                            .byte $b6 ; 
                            .byte $a0 ; 
                            .byte $8a ; 
                            .byte $a0 ; 
TabWrkLoadFileMusicNum      = *       ; music file name apendix - MUSICn
                            .byte $8d ; 
                            .byte $b3 ; 
                            .byte $c3 ; 
                            .byte $a0 ; 
                            .byte $a0 ; 
                            .byte $ca ; 
                            .byte $a0 ; 
                            .byte $e5 ; 
                            .byte $b5 ; 
                            .byte $c9 ; 
                            .byte $80 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagLoadMem              .byte $a0 ; 
TabFlagLoadMem_Game             = $00 ; select memory CC_GameDataBuf
TabFlagLoadMem_Load             = $01 ; select memory CC_LoadDataBuf  
TabFlagLoadMem_Times            = $02 ; select memory CC_TimeDataBuf
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkLoadFile_Len          .byte $b6 ; 
TabWrkLoadFileDataEnd_Lo    .byte $a0 ; 
TabWrkLoadFileDataEnd_Hi    .byte $ad ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkWaitTimeRestart_Lo    .byte $f0 ; 
TabWrkWaitTimeRestart_Mid   .byte $a0 ; 
TabWrkWaitTimeRestart_Hi    .byte $b7 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleTimeItemFillHandler Does   : control the setup of the TabDataCastleTimeFrame item
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleTimeItemFillHandler  .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_GameDataVar_Times_P1_Sec - CC_GameDataVar_Times ; get offset seconds of castle data variables
                            lda (CCZ_DrawItemDataPtr),y     ; get castle time data from castle data variables
                            ldy #TabDataCastleTimeFrame_Sec ; get time frame char offset seconds
                            jsr CastleTimeItemFill          ; fill the TabDataCastleTimeFrame item with time digit chars
                            
                            ldy #CC_GameDataVar_Times_P1_Min - CC_GameDataVar_Times ; get offset minutes of castle data variables
                            lda (CCZ_DrawItemDataPtr),y     ; get castle time data from castle data variables
                            ldy #TabDataCastleTimeFrame_Min ; get time frame char offset minutes
                            jsr CastleTimeItemFill          ; fill the TabDataCastleTimeFrame item with time digit chars
                            
                            ldy #CC_GameDataVar_Times_P1_Hrs - CC_GameDataVar_Times ; get offset hours of castle data variables
                            lda (CCZ_DrawItemDataPtr),y     ; get castle time data from castle data variables
                            ldy #TabDataCastleTimeFrame_Hrs ; get time frame char offset hours
                            jsr CastleTimeItemFill          ; fill the TabDataCastleTimeFrame item with time digit chars
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleTimeItemFill        Does    : fill the TabDataCastleTimeFrame item with time digit chars
;                           Expects : .A=BCD encoded time value
;                                   : .Y=offset castle time frame item output
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleTimeItemFill         .block                           ; 
                            pha                             ; 
                            sta TabWrkTimeValue_Save        ; save parm BCD time value
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get SetBcdPart_1s
                            sta TabWrkTimeValue_Part        ; set SetBcdPart_1s
                            
                            lda TabWrkTimeValue_Save        ; ####.... - get parm BCD time value
                            lsr a                           ; .####... - shift 10s part to right nibble
                            lsr a                           ; ..####..
                            lsr a                           ; ...####.
                            lsr a                           ; ....####
                            
SetNextDigitCharOff         asl a                           ; *2 - multiply with char tab entry lenght 
                            asl a                           ; *4
                            asl a                           ; *8
                            tax                             ; set as offset
                            
GetNextDigitCharOff         txa                             ; get char tab offset
                            and #$07                        ; isolate offset
                            cmp #$07                        ; test max offset
                            beq SetBcdPart_1s               ; check: max - yes: done - set next BCD digit part
                            
                            lda TabTimeFrameDigitChar,x     ; get next digit part byte from digit char table
                            sta TabDataCastleTimeFrame_Char,y ; put it to its castle time frame char pos
                            
                            clc                             ; 
                            tya                             ; get castle time frame char pos
                            adc #TabDataCastleTimeFrame_Cols; add castle time frame row width - set next char part row
                            tay                             ; set castle time frame char offset
                            
                            inx                             ; 
                            jmp GetNextDigitCharOff         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set BCD 10s part
; --------------------------------------------------------------------------------------------------------------------- ;
SetBcdPart_1s               inc TabWrkTimeValue_Part        ; inc BCD process flag
                            
                            lda TabWrkTimeValue_Part        ; 
                            cmp #$02                        ; test BCD process flag beyond max
                            beq CastleTimeItemFillX         ; check: byeond max - yes: done - processed 10s and 1s
                            
                            tya                             ; get castle time frame char pos
                            sec                             ; 
                            sbc #TabDataCastleTimeFrame_Cols * $07 - $01 ; reset castle time frame char pos to start
                            tay                             ; set starting castle time frame char pos
                            
                            lda TabWrkTimeValue_Save        ; get parm BCD time value
                            and #$0f                        ; ....#### isolate BCD 1s part
                            jmp SetNextDigitCharOff         ; continue with BCD 1s part
; --------------------------------------------------------------------------------------------------------------------- ;
CastleTimeItemFillX         pla                              ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabTimeFrameDigitChar       = *       ; 
                            .byte $fc ; ######..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            
                            .byte $30 ; ..##....
                            .byte $30 ; ..##....
                            .byte $30 ; ..##....
                            .byte $30 ; ..##....
                            .byte $30 ; ..##....
                            .byte $30 ; ..##....
                            .byte $30 ; ..##....
                            .byte $00 ; ........
                            
                            .byte $fc ; ######..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $fc ; ######..
                            .byte $c0 ; ##......
                            .byte $c0 ; ##......
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            
                            .byte $fc ; ######..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $fc ; ######..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $fc ; ######..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $00 ; ........
                            
                            .byte $fc ; ######..
                            .byte $c0 ; ##......
                            .byte $c0 ; ##......
                            .byte $fc ; ######..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            
                            .byte $c0 ; ##......
                            .byte $c0 ; ##......
                            .byte $c0 ; ##......
                            .byte $fc ; ######..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            
                            .byte $fc ; ######..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $00 ; ........
                            
                            .byte $fc ; ######..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $fc ; ######..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            
                            .byte $fc ; ######..
                            .byte $cc ; ##..##..
                            .byte $cc ; ##..##..
                            .byte $fc ; ######..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $0c ; ....##..
                            .byte $00 ; ........
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkTimeValue_Save        .byte $85 ; 
TabWrkTimeValue_Part        .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawText                  Does    : draw all castle room text lines of different shapes
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawText                   .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextTextLine            ldy #CC_TextLine_PosX           ; get offset text PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get text PosX
                            beq DrawText_Exit               ; check: CC_TextLine_EoD  - yes: prepare exit
                            
                            sta TabWrkTextLine_PosX         ; set text PosX
                            
                            ldy #CC_TextLine_PosY           ; get offset text PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get text PosY
                            sta TabWrkTextLine_PosY         ; set text PosX
                            
                            ldy #CC_TextLine_Color          ; get offset text line color
                            lda (CCZ_DrawItemDataPtr),y     ; get text line color
                            sta TabWrkTextLine_Color        ; set text line color
                            
                            ldy #CC_TextLine_Style          ; get offset text line style
                            lda (CCZ_DrawItemDataPtr),y     ; get text line style
                            sta TabWrkTextLine_Style        ; set text line style
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next text data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_TextLineItem_Len        ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc DawThisTextChar             ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
DawThisTextChar             jsr DrawTextLine                ; draw a single text line of the selected height and style
                            
                            jmp DrawNextTextLine            ; continue with next line
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte EndOfTextData and exit
; --------------------------------------------------------------------------------------------------------------------- ;
DrawText_Exit               inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne DrawTextX                   ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawTextX                   pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawTextLine              Does    : draw a single text line of the selected height and style
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawTextLine               .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkTextLine_PosX         ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            lda TabWrkTextLine_PosY         ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda #ItemNum_CharClear          ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #ItemNum_Char               ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_2 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda TabWrkTextLine_Style        ; 
                            and #CC_TextLine_Style_Height_Mask ; isolate text format height bits
                            bne SetTextFormat               ; check: heigh set - yes: bypass default
                            
                            lda #CC_TextLine_Style_Height_Sng ; get default height
                            
SetTextFormat               sta TabWrkTextLine_Height       ; save the selected text line height
                            
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - char rows
                            sta TabDataCharClear_Rows       ; set clear item data row count for the selected heigth
                            sta TabDataChar_Rows            ; set draw  item data row count for the selected heigth
; --------------------------------------------------------------------------------------------------------------------- ;
; point to char item colors of the desired text char height - color data directly follows the char data
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl a                           ; *16 - char item color offset
                            
                            clc                             ; 
                            adc #<TabDataChar_Height_Single ; add char item base address Lo
                            sta CCZ_ItemCharColorPtr_Lo     ; 
                            lda #$00                        ; 
                            adc #>TabDataChar_Height_Single ; add char item base address Hi
                            sta CCZ_ItemCharColorPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set the char item colors of the desired height
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$05                        ; get max color count
                            lda TabWrkTextLine_Color        ; get char color
                            asl a                           ; shift to lefty nybble
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
SetNextCharItemColor        sta (CCZ_ItemCharColorPtr),y    ; 
                            
                            dey                             ; dec max color count
                            bpl SetNextCharItemColor        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill the text char item with the data of the chosen char and style
; --------------------------------------------------------------------------------------------------------------------- ;
ConvertNextTextLineChar     ldy #$00                        ; 
                            lda TabWrkTextLine_Style        ; get the chosen char style
                            and #CC_TextLine_Style_Set_Mask ; ..##.... - isolate charset (normal/reverse)
                            lsr a                           ; ...##...
                            lsr a                           ; ....##..
                            lsr a                           ; .....##.
                            tax                             ; set as char gen rom adress table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; each char number is a pointer to the char rom data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CCZ_DrawItemDataPtr),y     ; get next text line character from castle data
                            and #$7f                        ; clear bit7
                            sta CCZ_ItemCharPtr_Lo          ; 
                            lda #$00                        ; 
                            sta CCZ_ItemCharPtr_Hi          ; 
                            
                            asl CCZ_ItemCharPtr_Lo          ; *2
                            rol CCZ_ItemCharPtr_Hi          ; 
                            asl CCZ_ItemCharPtr_Lo          ; *4
                            rol CCZ_ItemCharPtr_Hi          ; 
                            asl CCZ_ItemCharPtr_Lo          ; *8 - char data length
                            rol CCZ_ItemCharPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; add the CHAR ROM base address of the selected char style
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabCharGenRomAdr + $00,x    ; get CHAR ROM address Lo for the selected character style
                            adc CCZ_ItemCharPtr_Lo          ; 
                            sta CCZ_ItemCharPtr_Lo          ; 
                            
                            lda TabCharGenRomAdr + $01,x    ; get CHAR ROM address Hi for the selected character style
                            adc CCZ_ItemCharPtr_Hi          ; 
                            sta CCZ_ItemCharPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the selected char data from the CHAR ROM
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$07                        ; init character data length
                            
                            sei                             ; do not get interrupted
                            
                            lda #D6510_CHAREN_OUT | D6510_HIRAM_OUT | D6510_LORAM_OUT ; 
                            sta D6510                       ; 
                            
                            lda #$00 & CHAREN_IO_OFF & HIRAM_KERNAL_OFF | LORAM_BASIC_ON ; switch the CHAR ROM on
                            sta R6510                       ; 
                            
CopyNextCharDataByte        lda (CCZ_ItemCharPtr),y         ; 
                            sta TabWrkCharRomData,y         ; fill the char data work area
                            
                            dey                             ; dec character data length
                            bpl CopyNextCharDataByte        ; check: min - no: continue
                            
                            lda #CHAREN_IO_ON & HIRAM_KERNAL_OFF | LORAM_BASIC_ON ; switch the CHAR ROM back off
                            sta R6510                       ; 
                            
                            cli                             ; reallow interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; generate the desired char item
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; init char data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set the char item address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabDataChar + TabData_Hdr_Len ; get char item base address Lo
                            sta CCZ_ItemCharPtr_Lo          ; 
                            lda #>TabDataChar + TabData_Hdr_Len ; get char item base address Lo
                            sta CCZ_ItemCharPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; split the char byte into a left and right part - double the width
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextWrkCharRomDataByte   lda TabWrkCharRomData,x         ; get a character copied from the selected CHAR ROM style data
                            lsr a                           ; shift left to right nybble
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            and #$0f                        ; isolate right nybble
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; preset the left/right char item data byte parts
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabCharDataConversion,y     ; get char data conversion byte for this character nybble
                            
                            ldy #$00                        ; 
                            sta (CCZ_ItemCharPtr),y         ; preset left item data byte part
                            
                            lda TabWrkCharRomData,x         ; get a character read from the selected CHAR ROM style
                            and #$0f                        ; isolate right nybble
                            tay                             ; set as offset
                            
                            lda TabCharDataConversion,y     ; 
                            ldy #$01                        ; 
                            sta (CCZ_ItemCharPtr),y         ; preset right item data byte part
; --------------------------------------------------------------------------------------------------------------------- ;
; care for single char heigth
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkTextLine_Height       ; restore the selected text line style
                            cmp #CC_TextLine_Style_Height_Dbl ; test double height
                            bcs CheckDoubleHeight           ; check: GE - yes: double or triple heigth
                            
                            lda #$02                        ; get single advance item data pointer amount
                            jmp AdvanceCharItemDataPtr      ; was single data heigth - done - nothing more to do
; --------------------------------------------------------------------------------------------------------------------- ;
; care for double char heigth
; --------------------------------------------------------------------------------------------------------------------- ;
CheckDoubleHeight           bne WasTripleHeight             ; check: EQ - no: triple heigth
                            
                            ldy #$00                        ; 
                            lda (CCZ_ItemCharPtr),y         ; get left preset item data byte
                            
                            ldy #$02                        ; 
                            sta (CCZ_ItemCharPtr),y         ; propagate left preset item data byte
                            
                            ldy #$01                        ; 
                            lda (CCZ_ItemCharPtr),y         ; get right preset item data byte
                            
                            ldy #$03                        ; 
                            sta (CCZ_ItemCharPtr),y         ; propagate right preset item data byte
                            
                            lda #$04                        ; get double advance item data pointer amount
                            jmp AdvanceCharItemDataPtr      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; care for triple char heigth
; --------------------------------------------------------------------------------------------------------------------- ;
WasTripleHeight             ldy #$00                        ; 
                            lda (CCZ_ItemCharPtr),y         ; get left preset item data byte
                            
                            ldy #$02                        ; 
                            sta (CCZ_ItemCharPtr),y         ; propagate left preset item data byte
                            ldy #$04                        ; 
                            sta (CCZ_ItemCharPtr),y         ; propagate left preset item data byte
                            
                            ldy #$01                        ; 
                            lda (CCZ_ItemCharPtr),y         ; get right preset item data byte
                            
                            ldy #$03                        ; 
                            sta (CCZ_ItemCharPtr),y         ; propagate right preset item data byte
                            ldy #$05                        ; 
                            sta (CCZ_ItemCharPtr),y         ; propagate right preset item data byte
                            
                            lda #$06                        ; get triple advance item data pointer amount
; --------------------------------------------------------------------------------------------------------------------- ;
; advance char item data pointer for the selected char heigth
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceCharItemDataPtr      clc                             ; 
                            adc CCZ_ItemCharPtr_Lo          ; 
                            sta CCZ_ItemCharPtr_Lo          ; 
                            bcc IncCharDataOff              ; check: overflow - no
                            inc CCZ_ItemCharPtr_Hi          ; 
                            
IncCharDataOff              inx                             ; inc char data offset
                            cpx #$08                        ; test max
                            bcc GetNextWrkCharRomDataByte   ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the generated char item
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDraw                ; draw the selected room item
                            
                            ldy #CC_TextLine_PosX           ; get offset next text line char PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get next text line char PosX
                            bmi DrawTextLine_Exit           ; check: CC_TextLine_EoL - yes: done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set castle data pointer to next text char
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne AdvanceDrawGridPosX         ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance graphic output PosX to next draw grid column
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceDrawGridPosX         clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc #$04 * $02                  ; add double room draw grid width - step two room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX item type_0
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX item type_1
                            
                            jmp ConvertNextTextLineChar     ; continue the text line char substitution
; --------------------------------------------------------------------------------------------------------------------- ;
DrawTextLine_Exit           inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne DrawTextLineX               ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawTextLineX               pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkTextLine_PosX      .byte $c5 ; 
TabWrkTextLine_PosY      .byte $c4 ; 
TabWrkTextLine_Color     .byte $a0 ; 
TabWrkTextLine_Style     .byte $cc ; 
TabWrkTextLine_Height    .byte $ca ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; character generator ROM addresses
; --------------------------------------------------------------------------------------------------------------------- ;
TabCharGenRomAdr            .word CHARGEN_UG  ; upper case/gfx
                            .word CHARGEN_UGR ; upper case/gfx   - reversed
                            .word CHARGEN_UL  ; upper/lower case
                            .word CHARGEN_ULR ; upper/lower case - reversed
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkCharRomData           = *       ; charater data for this character read from the CHAR ROM
                            .byte $89 ; 
                            .byte $ce ; 
                            .byte $f0 ; 
                            .byte $c1 ; 
                            .byte $a0 ; 
                            .byte $ba ; 
                            .byte $b1 ; 
                            .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabCharDataConversion       = *       ; 
                            .byte $00 ; ........ - $00
                            .byte $01 ; .......# - $01
                            
                            .byte $04 ; .....#.. - $02
                            .byte $05 ; .....#.# - $03
                            
                            .byte $10 ; ...#.... - $04
                            .byte $11 ; ...#...# - $05
                            
                            .byte $14 ; ...#.#.. - $06
                            .byte $15 ; ...#.#.# - $07
                            
                            .byte $40 ; .#...... - $08
                            .byte $41 ; .#.....# - $09
                            
                            .byte $44 ; .#...#.. - $0a
                            .byte $45 ; .#...#.# - $0b
                            
                            .byte $50 ; .#.#.... - $0c
                            .byte $51 ; .#.#...# - $0d
                            
                            .byte $54 ; .#.#.#.. - $0e
                            .byte $55 ; .#.#.#.# - $0f
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameForceEndlessIRQ       Does    : endlessly execute BRK instructions - never reached (hopefully)
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameForceEndlessIRQ        .block                           ; 
                            brk                             ; 
                            brk                             ; 
                            brk                             ; 
                            brk                             ; 
                            brk                             ; 
                            brk                             ; 
                            brk                             ; 
                            brk                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CopyProtection            Does    : read bad block track=35 sector=9 and good block track=01 sector=9
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CopyProtection             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; read track 35 sector 9 - must have a "27, READ ERROR,tt,ss" - Header block checksum error
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #"3"                        ; TabDiskCmd_Trk_Hi
                            ldy #"5"                        ; TabDiskCmd_Trk_Lo
                            lda #$00                        ; table offset
                            jsr CopyProtectionBlockRead     ; 
                            beq CopyProtectionX             ; check: success - yes
                            
                            ldx #"0"                        ; TabDiskCmd_Trk_Hi
                            ldy #"1"                        ; TabDiskCmd_Trk_Lo
                            lda #$01                        ; table offset
                            jsr CopyProtectionBlockRead     ; 
                            bne CopyProtectionX             ; check: success - no
                            
CopyProtectionX             jmp CopyProtectionSuccess       ; correct ItemDrawRoutineAdr table entries
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; correction values for RoomDoor_Bad and DrawFloor_Bad
; --------------------------------------------------------------------------------------------------------------------- ;
TabRoomCorrection_DoorFloor  = *      ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; correction values for DrawPole_Bad and RoomBell_Bad
; --------------------------------------------------------------------------------------------------------------------- ;
TabRoomCorrection_PoleBell   = *      ; 
                            .byte $00 ; 
                            .byte " " ; 
                            .byte "2" ; 
                            .byte "7" ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CopyProtectionBlockRead   Does    : read a block from disk into disk buffer
;                           Expects : .A=return code table offset
;                                   : .X=track numer HI
;                                   : .Y=track numer LO
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CopyProtectionBlockRead    .block                           ; 
                            sta CCZ_CopyProtDataTabOff      ; $00/$01 - set disk block data table offset
                            stx TabDiskCmd_Trk_Hi           ; "3"/"0"
                            sty TabDiskCmd_Trk_Lo           ; "5"/"1"
                            
                            lda #$00                        ; get flag: no file name
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
; --------------------------------------------------------------------------------------------------------------------- ;
; open 15,8,15
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #SA_CHANNEL_CMD             ; get command channel file number
                            ldx #FA_DISK                    ; get device number #8
                            tay                             ; get secondary address
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
; --------------------------------------------------------------------------------------------------------------------- ;
; open 5,8,5,"#"
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #FileNameString_Len         ; length of file name
                            ldx #<FileNameString            ; adr file name LO - "#"
                            ldy #>FileNameString            ; adr file name HI - "#"
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            
                            lda #$05                        ; get logical file number
                            ldx #FA_DISK                    ; get device number #8
                            tay                             ; get secondary address
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
; --------------------------------------------------------------------------------------------------------------------- ;
; print#15,"U1: 5 0 35 9" - must return an error $09 - 27, READ ERROR,tt,ss - Header block checksum error
; print#15,"U1: 5 0 01 9" - must return an error $00 - 00, OK,00,00
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #SA_CHANNEL_CMD             ; get command channel number
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
                            
                            ldy #$00                        ; 
PutNextDiskCmdCharRead      lda TabDiskCmd,y                ; 
                            beq DiskCmdClrChannel           ; check: end of cmd string - yes: clear channels
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; 
                            bne PutNextDiskCmdCharRead      ; check: end of command - no: continue
                            
DiskCmdClrChannel           jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
; --------------------------------------------------------------------------------------------------------------------- ;
; get disk error number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #SA_CHANNEL_CMD             ; 
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            ldy CCZ_CopyProtDataTabOff      ; get disk block data table offset
                            sta TabRoomCorrection_DoorFloor,y ; set disk error number Hi
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            sta TabRoomCorrection_PoleBell,y; set disk error number Lo
; --------------------------------------------------------------------------------------------------------------------- ;
; discard error message string
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextDiskDataByte         jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            cmp #CR                         ; test <ENTER>
                            bne GetNextDiskDataByte         ; check: EQ - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; close command channel
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #SA_CHANNEL_CMD             ; 
                            jsr CLOSE                       ; Kernal($FFC3) Close a logical file (via $31C to $F291)
                            
                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)
; --------------------------------------------------------------------------------------------------------------------- ;
; close command channel
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CCZ_CopyProtDataTabOff      ; get disk block data table offset
                            lda TabRoomCorrection_DoorFloor,y ; set disk error number Hi
                            ora TabRoomCorrection_PoleBell,y; get disk error number Lo
                            
                            cmp #"0"                        ; test success and set flags
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
FileNameString              .byte "#" ; 
FileNameString_Len          = * - FileNameString ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmd                   = *      ; 
                            .byte "u" ; user command id
                            .byte "1" ; user command type - 1=read  2=write
                            .byte ":" ; 
                            .byte " " ; 
                            .byte "5" ; channel number
                            .byte " " ; 
                            .byte "0" ; drive number
                            .byte " " ; 
TabDiskCmd_Trk_Hi           .byte "0" ; track number HI
TabDiskCmd_Trk_Lo           .byte "1" ; track number LO
                            .byte " " ; 
                            .byte "9" ; sector number HI
                            
                            .byte CR  ; <RETURN>
                            .byte $00 ; end of disk command
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CopyProtectionSuccess     Does    : correct ItemDrawRoutineAdr table entries with the RC value from disk block read
;                           Expects : 
;                           Returns : 
;                           Remark  : working only after a '27, READ ERROR,35,09'
; --------------------------------------------------------------------------------------------------------------------- ;
CopyProtectionSuccess      .block                                   ; 
                            lda TabRoomCorrection_DoorFloor         ; 
                            eor ItemDrawRoutineAdr.ItemAdr_03_08_Hi ; DrawDoor  address
                            sta ItemDrawRoutineAdr.ItemAdr_03_08_Hi ; 
                            
                            lda TabRoomCorrection_PoleBell          ; 
                            eor ItemDrawRoutineAdr.ItemAdr_0f_08_Hi ; DrawBell  address
                            sta ItemDrawRoutineAdr.ItemAdr_0f_08_Hi ; 
                            
                            lda TabRoomCorrection_PoleBell          ; 
                            eor ItemDrawRoutineAdr.ItemAdr_09_08_Hi ; DrawPole  address
                            sta ItemDrawRoutineAdr.ItemAdr_09_08_Hi ; 
                            
                            lda TabRoomCorrection_DoorFloor         ; 
                            eor ItemDrawRoutineAdr.ItemAdr_06_08_Hi ; DrawFloor address
                            sta ItemDrawRoutineAdr.ItemAdr_06_08_Hi ;
                            
                            jmp GameWarmStart                       ; set up the machine for game play
                           .bend                                    ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; dead code: start
; --------------------------------------------------------------------------------------------------------------------- ;
A_2cd8                      .byte $ff ; 
                            
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_2ce0                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_2cf0                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
Game_Never_Called_NoCode    .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_2d00                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_2d10                      .byte $00 ; 
                            
                            .byte $03 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; Game_Never_Called         Does    : dead subroutine - never called - header missing
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
Game_Never_Called          .block                           ; 
                            stx TabWrk_NeverCalled_2e04     ; 
                            
                            bit TabWrk_NeverCalled_2e07     ; 
                            beq Game_Never_Called_NoCode    ; 
                            
                            stx TabWrk_NeverCalled_2e05     ; 
                            jmp Game_Never_Called_NoCode    ; 
                            
Game_Never_Called_2d20      lda #$0d                        ; 
                            jsr Game_Never_Called_Sub       ; 
                            
                            ldx #$c7                        ; 
Game_Never_Called_2d27      ldy TabWrk_NeverCalled_2e08     ; 
                            txa                             ; 
                            cmp TabWrk_NeverCalled_2e04,y   ; 
                            bcs Game_Never_Called_2d33      ; 
                            jmp Game_Never_Called_2d87      ; 
                            
Game_Never_Called_2d33      lda $b900,x                     ; 
                            cpy #$01                        ; 
                            bne Game_Never_Called_2d3e      ; 
                            
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
Game_Never_Called_2d3e      sta TabWrk_NeverCalled_2e09     ; 
                            
                            lda TabWrk_NeverCalled_Val      ; 
                            
                            asl TabWrk_NeverCalled_2e09     ; 
                            rol a                           ; 
                            asl TabWrk_NeverCalled_2e09     ; 
                            rol a                           ; 
                            tay                             ; 
                            
                            lda Tab_NeverCalled_Text,y      ; 
                            sta TabWrk_NeverCalled_2e0a     ; 
                            
                            lda TabWrk_NeverCalled_Val      ; 
                            
                            asl TabWrk_NeverCalled_2e09     ; 
                            rol a                           ; 
                            asl TabWrk_NeverCalled_2e09     ; 
                            rol a                           ; 
                            
                            tay                             ; 
                            lda Tab_NeverCalled_Text,y      ; 
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
                            ora TabWrk_NeverCalled_2e0a     ; 
                            ora #$80                        ; 
                            jsr Game_Never_Called_Sub       ; 
                            jsr Game_Never_Called_Sub       ; 
                            
                            sta TabWrk_NeverCalled_2e0a     ; 
                            
                            txa                             ; 
                            and #$0f                        ; 
                            bne Game_Never_Called_2d7f      ; 
                            
                            lda TabWrk_NeverCalled_2e0a     ; 
                            jsr Game_Never_Called_Sub       ; 
                            
Game_Never_Called_2d7f      dex                             ; 
                            cpx #$ff                        ; 
                            beq Game_Never_Called_2d87      ; 
                            jmp Game_Never_Called_2d27      ; 
                            
Game_Never_Called_2d87      inc TabWrk_NeverCalled_2e08     ; 
                            
                            lda TabWrk_NeverCalled_2e08     ; 
                            cmp #$02                        ; 
                            bcs Game_Never_Called_2d94      ; 
                            jmp Game_Never_Called_2d20      ; 
                            
Game_Never_Called_2d94      inc TabWrk_NeverCalled_2e03     ; 
                            jmp $2c95                       ; bad address
; --------------------------------------------------------------------------------------------------------------------- ;
; dead code return point
; --------------------------------------------------------------------------------------------------------------------- ;
Game_Never_Called_Ret       jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)
                            jsr $095f                       ; GameWarmStart - prepare the machine
                            
                            lda TabWrk_NeverCalled_Val      ; 
                            bne Game_Never_CalledX          ; 
                            
                            lda TabWrk_NeverCalled_2e13     ; 
                            sta CCZ_VIC_SPENA               ; set IRQ work register value
                            
                            ldx #CCZ_TabSprtDataPtrs_Len    ; 
Game_Never_Called_2dac      lda TabWrk_NeverCalled_2e14,x   ; 
                            sta CCZ_TabSprtDataPtrs,x       ; 
                            
                            dex                             ; 
                            bpl Game_Never_Called_2dac      ; 
                            
                            ldx #$03                        ; 
Game_Never_Called_2db6      lda TabWrk_NeverCalled_2e0b,x   ; 
                            sta TODTEN,x                    ; CIA1($DC08) Time of Day Clock Tenths
                            
                            lda TabWrk_NeverCalled_2e0f,x   ; 
                            sta TO2TEN,x                    ; CIA2($DD08) Time of Day Clock Tenths
                            
                            dex                             ; 
                            bpl Game_Never_Called_2db6      ; check: 
; --------------------------------------------------------------------------------------------------------------------- ;
Game_Never_CalledX          pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; Game_Never_Called_Sub     Does    : dead subroutine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
Game_Never_Called_Sub      .block                           ; 
                            pha                             ; 
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            jsr READST                      ; Kernal($FFB7) Read I/O status word ($FE07)
                            cmp #$00                        ; test status byte
                            beq Game_Never_Called_SubX      ; check: OK - yes: normall exit
                            
                            pla                             ; 
                            
                            pla                             ; 
                            pla                             ; 
                            jmp Game_Never_Called.Game_Never_Called_Ret ; 
                            
Game_Never_Called_SubX      pla                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
Tab_NeverCalled_Text         = *      ; 
                            .byte $00 ; 
                            .byte $05 ; 
                            .byte $03 ; 
                            .byte $0f ; 
                            .byte $00 ; 
                            .byte $0f ; 
                            .byte $03 ; 
                            .byte $01 ; 
                            
                            .byte "(" ; Text: (c) 1984 br0derbund software
                            .byte "c" ; 
                            .byte ")" ; 
                            .byte " " ; 
                            .byte "1" ; 
                            .byte "9" ; 
                            .byte "8" ; 
                            .byte "4" ; 
                            .byte " " ; 
                            .byte "b" ; 
                            .byte "r" ; 
                            .byte "0" ; 
                            .byte "d" ; 
                            .byte "e" ; 
                            .byte "r" ; 
                            .byte "b" ; 
                            .byte "u" ; 
                            .byte "n" ; 
                            .byte "d" ; 
                            .byte " " ; 
                            .byte "s" ; 
                            .byte "o" ; 
                            .byte "f" ; 
                            .byte "t" ; 
                            .byte "w" ; 
                            .byte "a" ; 
                            .byte "r" ; 
                            .byte "e" | $80 ; EndOfLine = Bit 7 set
; --------------------------------------------------------------------------------------------------------------------- ;
; the only table entry consumed in the main program
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrk_NeverCalled_Val      .byte $b0 ; 
TabWrk_NeverCalled_Val_Yes      = $01 ; 
TabWrk_NeverCalled_Val_No       = $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; all subsequent table entries are consumed in subroutine 'Game_Never_Called' and thus never used
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrk_NeverCalled_2e03     .byte $d2 ; 
TabWrk_NeverCalled_2e04     .byte $ac ; 
TabWrk_NeverCalled_2e05     .byte $a0 ; 
                            .byte $f0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrk_NeverCalled_2e07     .byte $0f ; 
TabWrk_NeverCalled_2e08     .byte $c4 ; 
TabWrk_NeverCalled_2e09     .byte $a0 ; 
TabWrk_NeverCalled_2e0a     .byte $b0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrk_NeverCalled_2e0b      = *      ; 
                            .byte $82 ; 
                            .byte $a0 ; 
                            .byte $82 ; 
                            .byte $aa ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrk_NeverCalled_2e0f      = *      ; 
                            .byte $85 ; 
                            .byte $c5 ; 
                            .byte $a0 ; 
                            .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrk_NeverCalled_2e13     .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrk_NeverCalled_2e14      = *      ; 
                            .byte $92 ; 
                            .byte $b8 ; 
                            .byte $a0 ; 
                            .byte $c6 ; 
                            .byte $a0 ; 
                            .byte $cc ; 
                            .byte $a0 ; 
                            .byte $86 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; dead code: end
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleRoomActionHandler   Does    : detect sprite collisions and handle all sprite/item actions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleRoomActionHandler    .block                           ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for the IRA timer counted down
; --------------------------------------------------------------------------------------------------------------------- ;
WasteSomeTime               lda TabWrkIRQ_Count             ; counted down to $00 with every IRQ
                            bne WasteSomeTime               ; check: ZERO - no: continue wait
                            
                            lda #$02                        ; get inital value
                            sta TabWrkIRQ_Count             ; counted down to $00 with every IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
; look for sprite collisions
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomGetSpriteCollision      ; set WA flag if sprite collided with sprite or background
; --------------------------------------------------------------------------------------------------------------------- ;
; move sprites and room items
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomSpriteHandler           ; loop through the sprite work areas and look for actions
                            jsr RoomItemHandler             ; loop through the item work areas and look for actions
; --------------------------------------------------------------------------------------------------------------------- ;
; count up the IRQ delay value - lower three bits used for all kinds of delays
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkIRQ_Delay             ; constantly count up the subroutine delay time value
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkIRQ_Count             .byte $00 ; counted down to $00 with every IRQ
TabWrkIRQ_Delay             .byte $a0 ; counted up for subroutine delay checks
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomGetSpriteCollision    Does    : set work area flag if sprite collided with sprite or background
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomGetSpriteCollision     .block                           ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SPSPCL                      ; VIC($D01E) Sprite-Sprite Collision - Cleared on read
                            sta TabWrkSprtColl_Sprt         ; save actual sprite-sprite collision status
                            
                            lda SPBGCL                      ; VIC($D01F) Sprite-Background Collision - Cleared on read
                            sta TabWrkSprtColl_Back         ; save actual sprite-background collision status
                            
                            ldx #$00                        ; init sprite work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
; test all active sprite work areas for a collision
; --------------------------------------------------------------------------------------------------------------------- ;
TestNextSprtFlag            lda CC_WA_Sprite_Flag,x         ; get next sprite work ara flag
                            bit TabFlagSprt_WA_Free         ; test flag sprite work area is used
                            beq CheckSpriteColl             ; check: WA used - yes: check it
; --------------------------------------------------------------------------------------------------------------------- ;
; clear this sprite collision status flags - continue with next sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr TabWrkSprtColl_Sprt         ; shift actual sprite-sprite collision status bit out
                            lsr TabWrkSprtColl_Back         ; shift actual sprite-background collision out
                            jmp SetNextSprt_WA_Off          ; continue with next sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; test a possible sprite collision
; --------------------------------------------------------------------------------------------------------------------- ;
CheckSpriteColl             and #~CC_WA_Sprite_Flag_Coll_Mask ; clear the sprite collision detection bits
                            
                            lsr TabWrkSprtColl_Sprt         ; shift actual sprite-sprite collision status into carry
                            bcc CheckCollBckgr              ; check: sprite-sprite collision status bit set - no
                            
                            ora #CC_WA_Sprite_Flag_Coll_Sprt; insert sprite-sprite collision flag
                            
CheckCollBckgr              lsr TabWrkSprtColl_Back         ; actual sprite-background collision status
                            bcc SetSprt_WA_Flag             ; check: collision with background - no
                            
                            ora #CC_WA_Sprite_Flag_Coll_Back; insert sprite-background collision
                            
SetSprt_WA_Flag             sta CC_WA_Sprite_Flag,x         ; set new sprite work ara flag
; --------------------------------------------------------------------------------------------------------------------- ;
; advance sprite work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSprt_WA_Off          clc                             ; 
                            txa                             ; get sprite work area offset
                            adc #CC_WA_Sprite_Len           ; add work area length
                            tax                             ; set new sprite work area offset
                            bne TestNextSprtFlag            ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSprtColl_Sprt         .byte $c5 ; actual sprite-sprite collision status
TabWrkSprtColl_Back         .byte $d0 ; actual sprite-background collision status
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomSpriteHandler         Does    : loop through the sprite work area queue and check for actions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomSpriteHandler          .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; init sprite work area offset
TestNextSprt_WA_Flag        lda CC_WA_Sprite_Flag,x         ; get next sprite work ara flag
                            bit TabFlagSprt_WA_Free         ; test flag sprite work area is free again
                            beq TestCollType                ; check: WA free - no: test type of collision
                            
                            jmp SetNextSprt_WA_Off          ; continue with next sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; test if a collision with a sprite or background happened
; --------------------------------------------------------------------------------------------------------------------- ;
TestCollType                bit TabFlagSprt_Moves           ; test flag sprite to be moved
                            bne IniCallSprtMoveHandler      ; check: sprite active - yes: prepare sprite move routine
                            
                            bit TabFlagSprt_Dead            ; test flag this sprite is dead
                            bne GoRoomSpriteDeathHandler    ; check: dead - yes: animate death
                            
                            dec CC_WA_Sprite_SeqNum_Sav,x   ; dec actual sprite sequence number
                            beq CheckDeathAnimationActive   ; check: min - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; test if a collision with a sprite happened
; --------------------------------------------------------------------------------------------------------------------- ;
                            bit TabFlagSprt_Coll_Sprt       ; test flag sprite collided with a sprite
                            beq TryNextSprite_WA            ; check: collided with a sprite - no
                            
                            jsr RoomSpriteSprtCollHandler   ; kill a sprite if it can be killed by the touched sprite
; --------------------------------------------------------------------------------------------------------------------- ;
; check if something not so wonderful has happened
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Flag,x         ; get sprite flag
                            bit TabFlagSprt_Dead            ; test flag sprite dead
                            bne GoRoomSpriteDeathHandler    ; check: dead - yes: animate the death
                            
TryNextSprite_WA            jmp SetNextSprt_WA_Off          ; continue with next work area
; --------------------------------------------------------------------------------------------------------------------- ;
CheckDeathAnimationActive   bit TabFlagSprt_Dies            ; test active death animation
                            bne GoRoomSpriteDeathHandler    ; check: ongoing death - yes: continue death animation
; --------------------------------------------------------------------------------------------------------------------- ;
; test if a collision with background happened
; --------------------------------------------------------------------------------------------------------------------- ;
                            bit TabFlagSprt_Coll_Back       ; test flag sprite collided with background
                            beq CheckCollisionWithSprt      ; check: collided with background - no: check sprite collision
                            
                            jsr RoomPlayerMoveHandler       ; loop through all active room item work areas and look for actions
; --------------------------------------------------------------------------------------------------------------------- ;
; check if something not so wonderful has happened
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Flag,x         ; get sprite flag
                            bit TabFlagSprt_Dead            ; test flag sprite dead
                            bne GoRoomSpriteDeathHandler    ; check: dead - yes: animate the death
; --------------------------------------------------------------------------------------------------------------------- ;
CheckCollisionWithSprt      lda CC_WA_Sprite_Flag,x         ; get sprite flag
                            bit TabFlagSprt_Coll_Sprt       ; test flag sprite collided with a sprite
                            beq IniCallSprtMoveHandler      ; check: collided with a sprite - no
                            
                            jsr RoomSpriteSprtCollHandler   ; kill a sprite if it can be killed by the touched sprite
; --------------------------------------------------------------------------------------------------------------------- ;
; check if something not so wonderful has happened
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Flag,x         ; get sprite flag
                            bit TabFlagSprt_Dead            ; test flag sprite dead
                            bne GoRoomSpriteDeathHandler    ; check: dead - yes: animate the death
; --------------------------------------------------------------------------------------------------------------------- ;
; set up for room sprite move handler address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
IniCallSprtMoveHandler      lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - TabSprtActn_Len
                            tay                             ; set as table offset
                            
                            lda TabSprtActn_Move_Sprt + $00,y ; 
                            sta smRoomSpriteMoveAdr_Lo      ; set address room sprite move handler Lo
                            lda TabSprtActn_Move_Sprt + $01,y ; 
                            sta smRoomSpriteMoveAdr_Hi      ; set address room sprite move handler Hi
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch the selected room sprite move handler
; --------------------------------------------------------------------------------------------------------------------- ;
smRoomSpriteMoveAdr         = * + $01                       ; 
smRoomSpriteMoveAdr_Lo        = smRoomSpriteMoveAdr + $00   ; 
smRoomSpriteMoveAdr_Hi        = smRoomSpriteMoveAdr + $01   ; 
                            jmp smRoomSpriteMoveAdr         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; common RTS point from the different sprite move routines
; --------------------------------------------------------------------------------------------------------------------- ;
RTS_RoomSpriteHandler       lda CC_WA_Sprite_Flag,x         ; get sprite flag
                            bit TabFlagSprt_Dead            ; test flag sprite dead
                            beq CheckSpriteMove             ; check: dead - no: bypass death animation
; --------------------------------------------------------------------------------------------------------------------- ;
; call the sprite death animation routine
; --------------------------------------------------------------------------------------------------------------------- ;
GoRoomSpriteDeathHandler    jsr RoomSpriteDeathHandler      ; handle the sprite death animation
; --------------------------------------------------------------------------------------------------------------------- ;
; test sprite move status
; --------------------------------------------------------------------------------------------------------------------- ;
CheckSpriteMove             lda CC_WA_Sprite_Flag,x         ; 
                            bit TabFlagSprt_Moves           ; test flag sprite to be moved
                            bne IniCallSprtMoveHandler      ; check: move - yes
                            
                            txa                             ; get sprite work area offset
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
                            lsr a                           ; /32 - CC_WA_Sprite_Len
                            tay                             ; set sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; test if sprite needs to be disabled
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Flag,x         ; get sprite flag
                            bit TabFlagSprt_Disable         ; test flag sprite to be disabled
                            beq CheckSprite_PosX            ; check: disable - no: bypass diablement
; --------------------------------------------------------------------------------------------------------------------- ;
; free sprite work area and disable this sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabFlagSprt_WA_Free         ; get flag sprite work area is free again
                            sta CC_WA_Sprite_Flag,x         ; reset sprite work area to free again
                            
                            jmp SpriteDisable               ; disable this sprite
; --------------------------------------------------------------------------------------------------------------------- ;
; check sprite PosX and set most significant bit in MSGIX accordingly
; --------------------------------------------------------------------------------------------------------------------- ;
CheckSprite_PosX            lda CC_WA_Sprite_PosX,x         ; 
                            sta CCZ_SpritePosX_Lo           ; set sprite work PosX Lo
                            
                            lda #$00                        ; get initial value
                            sta CCZ_SpritePosX_Hi           ; init sprite work PosX Hi
                            
                            asl CCZ_SpritePosX_Lo           ; 
                            rol CCZ_SpritePosX_Hi           ; sprite work PosX *2
                            
                            sec                             ; 
                            lda CCZ_SpritePosX_Lo           ; get sprite work PosX Lo
                            sbc #$08                        ; adjust sprite PosX
                            
                            sei                             ; disallow interrupts
                            
                            sta CCZ_VIC_SPnX_Long,y         ; set IRQ work register value - sprite PosX
                            
                            lda CCZ_SpritePosX_Hi           ; get sprite work PosX Hi
                            sbc #$00                        ; subtract carry
                            bcc SpriteDisable               ; check: underflow - yes
                            beq ClearSprite_MSIGX           ; check: ZERO - yes: max PosX reached - set MSGIX
; --------------------------------------------------------------------------------------------------------------------- ;
; set  MSGIX for the selected sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_VIC_MSIGX               ; MSB X-Pos Sprites 0-7
                            ora TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            jmp SetSprite_MSIGX             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ClearSprite_MSIGX           lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits for clear
                            and CCZ_VIC_MSIGX               ; MSB X-Pos Sprites 0-7
                            
SetSprite_MSIGX             sta CCZ_VIC_MSIGX               ; set IRQ work register value - MSB X-Pos Sprites 0-7
                            
                            and TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            beq SetSprite_PosY              ; 
                            
                            lda CCZ_VIC_SPnX_Long,y         ; get sprite PosX from sprite PosX table
                            cmp #$58                        ; test sprite has completely left the screen to the right
                            bcc SetSprite_PosY              ; check: LT - yes: still on screen
; --------------------------------------------------------------------------------------------------------------------- ;
; disable sprite if off screen - floor right end terminator missing
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDisable               lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits for clear
                            and CCZ_VIC_SPENA               ; clear desired sprite bit
                            jmp SetSprite_Spena             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetSprite_PosY              lda CC_WA_Sprite_PosY,x         ; get selected sprite PosY
                            clc                             ; 
                            adc #$32                        ; adjust sprite PosY
                            sta CCZ_VIC_SPnY_Long,y         ; set IRQ work register value - sprite PosY
                            
                            lda CCZ_VIC_SPENA               ; get IRQ VIC SPENA value for selected sprite
                            ora TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            
SetSprite_Spena             sta CCZ_VIC_SPENA               ; set IRQ work register value
                            
                            cli                             ; enable IRQs again
                            
                            lda CC_WA_Sprite_SeqNum,x       ; get sprite sequence number
                            sta CC_WA_Sprite_SeqNum_Sav,x   ; save sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
; advance sprite work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSprt_WA_Off          clc                             ; 
                            txa                             ; get sprite work area offset
                            adc #CC_WA_Sprite_Len           ; add work area length
                            tax                             ; set new sprite work area offset
                            beq RoomSpriteHandlerX          ; check: max - yes: all work areas handled - done
                            
                            jmp TestNextSprt_WA_Flag        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomSpriteHandlerX          pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprt_VIC_BitNum          = *       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite move direction flag table
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteMove               = *       ; 
TabSpriteMove_Up            = * - TabSpriteMove ; 
                            .byte $01 ; .......#  $00: move ctrl - CC_MoveCtrl_Up
                            .byte $02 ; ......#. 
TabSpriteMove_Ri            = * - TabSpriteMove ; 
                            .byte $04 ; .....#..  $02: move ctrl - CC_MoveCtrl_Right
                            .byte $08 ; ....#... 
TabSpriteMove_Do            = * - TabSpriteMove ; 
                            .byte $10 ; ...#....  $04: move ctrl - CC_MoveCtrl_Down    
                            .byte $20 ; ..#..... 
TabSpriteMove_Le            = * - TabSpriteMove ; 
                            .byte $40 ; .#......  $06: move ctrl - CC_MoveCtrl_Left
                            .byte $80 ; #....... 
                            
TabSpriteMove_Len           = * - TabSpriteMove - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomSpriteDeathHandler    Does    : handle the sprite death animation
;                           Expects : .X=sprite work area block offset
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomSpriteDeathHandler     .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Flag,x         ; 
                            bit TabFlagSprt_Dead            ; test flag sprite dead
                            bne SetSpriteDeath              ; check: dead - yes: try to anmimate the death
                            
                            lda CC_WA_Sprite_DeathSfxTone,x ; 
                            bne CheckSprtColorPhase         ; check: death tone ongoing - yes
                            
                            lda CC_WA_Sprite_Flag,x         ; 
                            eor TabFlagSprt_Dies            ; flip flag active death animation
                            
                            jmp SetFlagSprite_DoMove        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpriteDeath              eor TabFlagSprt_Dead            ; flip flag sprite is dead
                            sta CC_WA_Sprite_Flag,x         ; set flag sprite is dead
                            
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - TabSprtActn_Len
                            tay                             ; set sprite action table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; check if this sprite mortal
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSprtActn_Mortal,y        ; get get this sprite type mortality flag
                            bit TabFlagSprt_Mortal          ; test flag sprite mortal
                            bne IniDeathTuneSfxPhase        ; check: mortal - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; this sprite type is immortal
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Flag,x         ; get original sprite flag value and keep it
; --------------------------------------------------------------------------------------------------------------------- ;
; mark sprite still to be moved
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagSprite_DoMove        ora TabFlagSprt_Moves           ; insert flag sprite to be moved in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; 
                            
                            jmp SetAnimationActiveX         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; animate this sprites death
; --------------------------------------------------------------------------------------------------------------------- ;
IniDeathTuneSfxPhase        lda #$08                        ; 
                            sta CC_WA_Sprite_DeathSfxTone,x ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get this sprite number from work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; 
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
                            lsr a                           ; /32 - sprite bit position
                            tay                             ; set as offset
                            
                            lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits
                            and SPMC                        ; VIC($D01C) Sprite Multicolor
                            sta SPMC                        ; VIC($D01C) Sprite Multicolor
                            
                            lda CC_WA_Sprite_Flag,x         ; 
                            ora TabFlagSprt_Dies            ; insert flag death animation active
                            sta CC_WA_Sprite_Flag,x         ; 
                            
                            lda #$01                        ; 
                            sta CC_WA_Sprite_SeqNum,x       ; sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
; flicker dead sprite color - check the active phase 1st
; --------------------------------------------------------------------------------------------------------------------- ;
CheckSprtColorPhase         lda TabWrkIRQ_Delay             ; get delay time value
                            and #$01                        ; isolate flicker phase bit
                            bne SetSprtDeathColor_Black     ; check: in WHITE phase - yes: switch to BLACK
; --------------------------------------------------------------------------------------------------------------------- ;
; phase #1: set death flicker color white
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; 
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
                            lsr a                           ; /32 - sprite bit position
                            tay                             ; set as offset
                            
                            lda #WHITE                        ; 
                            sta SP0COL,y                    ; VIC($D027) Color Sprite 0
; --------------------------------------------------------------------------------------------------------------------- ;
; phase #2: set death flicker color black
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CC_WA_Sprite_DeathSfxTone,x ; 
                            
                            lda CC_WA_Sprite_DeathSfxTone,x ; 
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8
                            sta TabSFX_Death_Tone           ; vary the death sfx
                            
                            lda #NumSfx_Death               ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
                            
                            jmp SetAnimationActive_Exit     ; prepare exit
; --------------------------------------------------------------------------------------------------------------------- ;
SetSprtDeathColor_Black     txa                             ; 
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
                            lsr a                           ; /32 - sprite bit position
                            tay                             ; set as offset
                            
                            lda #BLACK                      ; 
                            sta SP0COL,y                    ; VIC($D027) Color Sprite 0
; --------------------------------------------------------------------------------------------------------------------- ;
; save the actual death animation sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
SetAnimationActive_Exit     lda CC_WA_Sprite_SeqNum,x       ; get this sprite sequence number
                            sta CC_WA_Sprite_SeqNum_Sav,x   ; save this sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
SetAnimationActiveX         pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomSpriteSprtCollHandler Does    : kill a sprite if it can be killed by the touched sprite
;                           Expects : .X=sprite work area block offset
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomSpriteSprtCollHandler  .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            stx TabWrkSprt_Coll_WA_Off      ; save this sprite work area offset
                            
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - length of TabSprtActn
                            
                            tay                             ; set as table offset
                            lda TabSprtActn_KillPrio,y      ; get sprite-sprite collision priority
                            bpl SpriteTouchPrio             ; check: flag bypass handler set - no: handle prio
                            
                            jmp RoomSpriteSprtCollHandlerX  ; nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; store this sprite-sprite collision priority
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteTouchPrio             sta TabWrkSprt_Type_Kill_Prio   ; save actual sprite-sprite kill priority
; --------------------------------------------------------------------------------------------------------------------- ;
; store this sprite position and width/height
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PosX,x         ; 
                            sta TabWrkSprt_WA_PosX          ; actual sprite PosX
                            
                            clc                             ; 
                            adc CC_WA_Sprite_Cols,x         ; 
                            sta TabWrkSprt_WA_PosX_Max      ; actual sprite max PosX - added sprite cols
                            bcc GetSprt_PosY                ; check: overflow - no
                            
                            lda #$00                        ; 
                            sta TabWrkSprt_WA_PosX          ; init actual sprite PosX
                            
GetSprt_PosY                lda CC_WA_Sprite_PosY,x         ; 
                            sta TabWrkSprt_WA_PosY          ; actual sprite PosY
                            
                            clc                             ; 
                            adc CC_WA_Sprite_Rows,x         ; 
                            sta TabWrkSprt_WA_PosY_Max      ; actual sprite max PosY - added sprite rows
                            bcc IniSprt_WA_QueueLookUp      ; check: overflow - no
                            
                            lda #$00                        ; 
                            sta TabWrkSprt_WA_PosY          ; init actual sprite PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; search the sprite work area queue
; --------------------------------------------------------------------------------------------------------------------- ;
IniSprt_WA_QueueLookUp      ldy #$00                        ; get initial value
CheckNextSprt_WA_Entry      sty TabWrkSprt_WA_Queue_Off     ; set actual sprite work area offset in the sprite work area queue
                            
                            cpy TabWrkSprt_Coll_WA_Off      ; test with this sprite work area offset
                            beq SetNextSprt_WA_Off          ; check: EQ - yes: continue with next sprite work area
                            
                            lda CC_WA_Sprite_Flag,y         ; get flag from the sprite work area queue
                            bit TabFlagSprt_WA_Free         ; test flag sprite work area is free again
                            bne SetNextSprt_WA_Off          ; check: free - yes: continue with next sprite work area
                            
                            bit TabFlagSprt_Coll_Sprt       ; test flag sprite collided with a sprite
                            beq SetNextSprt_WA_Off          ; check: collision - no: continue with next sprite work area
                            
                            lda CC_WA_Sprite_Type,y         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - length of TabSprtActn
                            
                            tay                             ; set as table offset
                            lda TabSprtActn_KillPrio,y      ; get sprite coll prio from actual sprite work area queue entry
                            bmi SetNextSprt_WA_Off          ; check: flag bypass handler set - yes: address next work sprite area
                            
                            bit TabWrkSprt_Type_Kill_Prio   ; test with this sprite-sprite kill priority
                            bne SetNextSprt_WA_Off          ; check: kill - no: try next sprite work area queue entry
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite work area queue entry with different kill priority found - test if both sprites positions overlap
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkSprt_WA_Queue_Off     ; get actual sprite work area offset in the sprite work area queue
; --------------------------------------------------------------------------------------------------------------------- ;
; test if actual sprite approached from left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSprt_WA_PosX_Max      ; actual sprite max PosX - added sprite cols
                            cmp CC_WA_Sprite_PosX,y         ; test with left PosX of the sprite in the sprite work area queue
                            bcc SetNextSprt_WA_Off          ; check: LT - yes: not the touched one
; --------------------------------------------------------------------------------------------------------------------- ;
; test if actual sprite approached from right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PosX,y         ; get PosX of the sprite in the sprite work area queue
                            clc                             ; 
                            adc CC_WA_Sprite_Cols,y         ; set max PosX of the sprite in the sprite work area queue
                            cmp TabWrkSprt_WA_PosX          ; test with actual sprite left PosX
                            bcc SetNextSprt_WA_Off          ; check: LT - yes: not the touched one
; --------------------------------------------------------------------------------------------------------------------- ;
; test if actual sprite approached from above
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSprt_WA_PosY_Max      ; actual sprite max PosY - added sprite rows
                            cmp CC_WA_Sprite_PosY,y         ; test with top PosY of the sprite in the sprite work area queue
                            bcc SetNextSprt_WA_Off          ; check: LT - yes: not the touched one
; --------------------------------------------------------------------------------------------------------------------- ;
; test if actual sprite approached from below
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PosY,y         ; get PosY of the sprite in the sprite work area queue
                            clc                             ; 
                            adc CC_WA_Sprite_Rows,y         ; 
                            cmp TabWrkSprt_WA_PosY          ; test with actual sprite top PosY
                            bcc SetNextSprt_WA_Off          ; check: LT - yes: not the touched one
; --------------------------------------------------------------------------------------------------------------------- ;
; found the touched sprite in the work area queue - 1st: kill the moved sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomSpriteKillHandler       ; kill the sprite addressed by the work area offset in .Y
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd: kill the touched sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkSprt_WA_Queue_Off     ; get actual sprite work area offset in the sprite work area queue
                            ldy TabWrkSprt_Coll_WA_Off      ; get touched sprite work area offset
                            
                            jsr RoomSpriteKillHandler       ; kill the sprite addressed by the work area offset in .Y
; --------------------------------------------------------------------------------------------------------------------- ;
; set next sprite work area queue offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSprt_WA_Off          ldx TabWrkSprt_Coll_WA_Off      ; get touched sprite work area offset
                            
                            ldy TabWrkSprt_WA_Queue_Off     ; get actual sprite work area offset in the sprite work area queue
                            tya                             ; 
                            clc                             ; 
                            adc #CC_WA_Sprite_Len           ; add work area length
                            beq RoomSpriteSprtCollHandlerX  ; check: all work areas handled - yes: exit
                            
                            tay                             ; set actual sprite work area offset in the sprite work area queue
                            jmp CheckNextSprt_WA_Entry      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomSpriteSprtCollHandlerX  pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomSpriteKillHandler     Does    : kill the sprite addressed by the work area offset in .Y
;                           Expects : .X=touched sprite work area block offset
;                                   : .Y=moved   sprite work area block offset
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomSpriteKillHandler      .block                           ; 
                            lda CC_WA_Sprite_Flag,x         ; get flag of the touched sprite
                            bit TabFlagSprt_Dies            ; test flag active death animation
                            bne RoomSpriteKillHandlerX      ; check: death animation ongoing - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; mark sprite as dead
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkSprt_Flag_Dead_Yes   ; 
                            sta TabWrkSprt_Flag_Dead        ; init flag sprite is dead
                            
                            sty TabWrkSprt_WA_Off           ; save offset moved sprite work ara
; --------------------------------------------------------------------------------------------------------------------- ;
; set up for rsprite kill handler address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get sprite type number of the touched sprite
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - TabSprtActn_Len
                            
                            tay                             ; set as table offset
                            lda TabSprtActn_Coll_Sprt + $00,y ; 
                            sta smRoomSpriteCollAdr_Lo      ; set address sprite kill handler Lo
                            
                            lda TabSprtActn_Coll_Sprt + $01,y ; 
                            sta smRoomSpriteCollAdr_Hi      ; set address sprite kill handler Hi
                            beq MarkSpriteAsDead            ; check: routine available - no: bypass collision routine dispatch
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch the selected room sprite kills a sprite handler for the moved sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkSprt_WA_Off           ; restore offset moved sprite work ara
smRoomSpriteCollAdr         = * + $01                       ; self modified sprite kill handler address
smRoomSpriteCollAdr_Lo        = smRoomSpriteCollAdr + $00   ; self modified sprite kill handler address
smRoomSpriteCollAdr_Hi        = smRoomSpriteCollAdr + $01   ; 
                            jmp smRoomSpriteCollAdr         ; call the desired sprite kill handler for the moved sprite
; --------------------------------------------------------------------------------------------------------------------- ;
; common RTS point to the sprite kills a sprite handler
; --------------------------------------------------------------------------------------------------------------------- ;
RTS_RoomSprtSprtCollHandler lda TabWrkSprt_Flag_Dead        ; get flag sprite live status
                            cmp #TabWrkSprt_Flag_Dead_Yes   ; test flag sprite alive
                            bne RoomSpriteKillHandlerX      ; check: dead - no: bypass set death flag
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
MarkSpriteAsDead            lda CC_WA_Sprite_Flag,x         ; get flag of the touched sprite
                            ora TabFlagSprt_Dead            ; insert flag this sprite is dead
                            sta CC_WA_Sprite_Flag,x         ; set flag of the touched sprite
                            
RoomSpriteKillHandlerX      rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSprt_Coll_WA_Off      .byte $ac ;       touched sprite work area offset
TabWrkSprt_WA_Queue_Off     .byte $b1 ;       actual sprite work area offset in the sprite work area queue
TabWrkSprt_WA_PosX          .byte $c4 ;       actual sprite PosX
TabWrkSprt_WA_PosX_Max      .byte $a0 ;       actual sprite max PosX - added sprite cols
TabWrkSprt_WA_PosY          .byte $92 ;       actual sprite PosY
TabWrkSprt_WA_PosY_Max      .byte $b9 ;       actual sprite max PosY - added sprite rows
TabWrkSprt_Type_Kill_Prio   .byte $a0 ;       actual sprite kill priority
TabWrkSprt_WA_Off           .byte $ff ;       actual moved sprite work area offset
TabWrkSprt_Flag_Dead        .byte $d3 ; flag: player live status
TabWrkSprt_Flag_Dead_No         = $00 ; 
TabWrkSprt_Flag_Dead_Yes        = $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomPlayerMoveHandler     Does    : loop through all active room item work areas and look for actions
;                           Expects : .X=player sprite work area offset
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomPlayerMoveHandler      .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; store this sprite position and width/height
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            sta TabWrkSprt_PosX             ; 
                            
                            adc CC_WA_Sprite_Cols,x         ; 
                            sta TabWrkSprt_PosX_Max         ; sprite PosX with sprite cols added
                            bcc GetPlayerSprt_PosY          ; check: overflow - no
                            
                            lda #$00                        ; 
                            sta TabWrkSprt_PosX             ; 
                            
GetPlayerSprt_PosY          clc                             ; 
                            lda CC_WA_Sprite_PosY,x         ; 
                            sta TabWrkSprt_PosY             ; 
                            
                            adc CC_WA_Sprite_Rows,x         ; 
                            sta TabWrkSprt_PosY_Max         ; sprite PosY with sprite rows added
                            bcc GetSprt_WA_UseCount         ; check: overflow - no
                            
                            lda #$00                        ; 
                            sta TabWrkSprt_PosY             ; 
                            
GetSprt_WA_UseCount         lda TabItem_WA_UseCount         ; 
                            bne GetEndOf_WA_Marker          ; check: ZERO - no: at least one sprite work area available
                            
                            jmp RoomPlayerMoveHandlerX      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; calc the EndOfWA value
; --------------------------------------------------------------------------------------------------------------------- ;
GetEndOf_WA_Marker          asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - offset next free work area - EndOfWA
                            sta TabWrkItem_WA_Off_Max       ; set offset end of used work areas
; --------------------------------------------------------------------------------------------------------------------- ;
; loop through all active room item work areas and look for actions
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get initial value
TryNextItem_WA              sty TabWrkItem_WA_Off           ; set actual work area offset
                            
                            lda CC_WA_ItemDef_Status,y      ; get this work area status
                            bit TabItem_WA_Flag_Init        ; test CC_WA_ItemDef_Status_Init
                            bne RTS_ItemManualMoveHandler   ; check: inact - yes: nothing to do - try next work area
; --------------------------------------------------------------------------------------------------------------------- ;
; test if sprite is on a room item
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSprt_PosX_Max         ; get sprite PosX with sprite cols added
                            cmp CC_WA_ItemDef_PosX,y        ; test with item PosX
                            bcc RTS_ItemManualMoveHandler   ; check: LT - yes: left of item - nothing to do - try next work area
                            
                            clc                             ; 
                            lda CC_WA_ItemDef_PosX,y        ; get item PosX
                            adc CC_WA_ItemDef_Width,y       ; add item width
                            cmp TabWrkSprt_PosX             ; test with sprite PosX
                            bcc RTS_ItemManualMoveHandler   ; check: LT - yes: right of item - nothing to do - try next work area
                            
                            lda TabWrkSprt_PosY_Max         ; get sprite PosY with sprite rows added
                            cmp CC_WA_ItemDef_PosY,y        ; test with sprite PosY
                            bcc RTS_ItemManualMoveHandler   ; check: LT- yes: below item - nothing to do - try next work area
                            
                            clc                             ; 
                            lda CC_WA_ItemDef_PosY,y        ; get item PosY
                            adc CC_WA_ItemDef_Rows,y        ; add item height
                            cmp TabWrkSprt_PosY             ; test with sprite PosY
                            bcc RTS_ItemManualMoveHandler   ; check: LT - yes: above item  - nothing to do - try next work area
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite is on room item - init flag as dead before dispatch the collision handler
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkSprt_Flag_Hit_Yes    ; get initial value
                            sta TabWrkSprt_Flag_Hit         ; init flag this sprite is hurt by a collision
; --------------------------------------------------------------------------------------------------------------------- ;
; set up for room sprite item collision handler address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - TabSprtActn_Len
                            
                            tay                             ; set as table offset
                            lda TabSprtActn_Coll_Item + $00,y ; 
                            sta smRoomSpriteCollAdr_Lo      ; 
                            lda TabSprtActn_Coll_Item + $01,y ; 
                            sta smRoomSpriteCollAdr_Hi      ; 
                            beq IniItemMoveHandler          ; check: routine available - no: continue with move handler
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch the selected room item sprite collision handler
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkItem_WA_Off           ; get actual item work area start offset
smRoomSpriteCollAdr         = * + $01                       ; 
smRoomSpriteCollAdr_Lo        = smRoomSpriteCollAdr + $00   ; 
smRoomSpriteCollAdr_Hi        = smRoomSpriteCollAdr + $01   ; 
                            jmp smRoomSpriteCollAdr         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; common RTS point from the selected room item sprite collision handler
; --------------------------------------------------------------------------------------------------------------------- ;
RTS_RoomPlayerMoveHandler   ldy TabWrkItem_WA_Off           ; <obsolete> get actual work area start offset
                            
                            lda TabWrkSprt_Flag_Hit         ; get flag sprite status after a collision
                            cmp #TabWrkSprt_Flag_Hit_Yes    ; test with flag sprite was hit
                            bne IniItemMoveHandler          ; check: EQ - no: no accident happened - try to move it
; --------------------------------------------------------------------------------------------------------------------- ;
; mark this sprite as a dead
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Flag,x         ; 
                            ora TabFlagSprt_Dead            ; insert flag this sprite is dead
                            sta CC_WA_Sprite_Flag,x         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set up for room item auto move handler address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
IniItemMoveHandler          ldy TabWrkItem_WA_Off           ; get actual work area start offset
                            lda CC_WA_ItemDef_Type,y        ; 
                            asl a                           ; *2
                            asl a                           ; *4 
                            tay                             ; set as offset
                            
                            lda TabMoveHandler_Player + $00,y ; 
                            sta smRoomItemManualMoveAdr_Lo  ; 
                            lda TabMoveHandler_Player + $01,y ; 
                            sta smRoomItemManualMoveAdr_Hi  ; 
                            
                            beq RTS_ItemManualMoveHandler   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch the selected room item manual move handler
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkItem_WA_Off           ; get actual work area offset
smRoomItemManualMoveAdr     = * + $01                       ; 
smRoomItemManualMoveAdr_Lo    = smRoomItemManualMoveAdr + $00 ; 
smRoomItemManualMoveAdr_Hi    = smRoomItemManualMoveAdr + $01 ; 
                            jmp smRoomItemManualMoveAdr     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; common RTS point to the room item manual move handler
; --------------------------------------------------------------------------------------------------------------------- ;
RTS_ItemManualMoveHandler   lda TabWrkItem_WA_Off           ; get actual work area start offset
                            clc                             ; 
                            adc #CC_WA_ItemDef_Len          ; add work area length
                            
                            tay                             ; set as actual work area start offset
                            cpy TabWrkItem_WA_Off_Max       ; test offset end of used work areas
                            beq RoomPlayerMoveHandlerX      ; check: EQ - yes: done - exit
                            
                            jmp TryNextItem_WA              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomPlayerMoveHandlerX      pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkItem_WA_Off_Max       .byte $b0 ;       end of used work areas
TabWrkItem_WA_Off           .byte $ff ;       actual work area start offset
TabWrkSprt_PosX             .byte $a0 ; 
TabWrkSprt_PosX_Max         .byte $83 ;       sprite PosX with sprite cols added
TabWrkSprt_PosY             .byte $a0 ; 
TabWrkSprt_PosY_Max         .byte $8d ;       sprite PosY with sprite rows added
TabWrkSprt_Flag_Hit         .byte $c3 ; flag: sprite had an accident
TabWrkSprt_Flag_Hit_Yes         = $01 ; 
TabWrkSprt_Flag_Hit_No          = $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerSpriteMove          Does    : get player into room and control his moves
;                           Expects : .X=offset player sprite work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerSpriteMove           .block                           ; 
                            lda CC_WA_Sprite_Flag,x         ; get sprite flag
                            bit TabFlagSprt_Moves           ; test flag sprite to be moved in RoomSpriteHandler
                            beq MovePlayer                  ; check: set - no
                            
                            eor TabFlagSprt_Moves           ; flip flag sprite to be moved in RoomSpriteHandler
                            
                            ora TabFlagSprt_Disable         ; insert flag sprite to be disabled in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; set flag sprite to be disabled
; --------------------------------------------------------------------------------------------------------------------- ;
; save player castle time
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PlayerNum,x    ; get player number
                            asl a                           ; *2 - timer address table entry length
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get CIA1/CIA2 timer source address pointer for the selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabPlayer_TimerAdr_CIA + $00,y ; 
                            sta CCZ_PlayerTimeSourcePtr_Lo  ; set pointer CIA ToD for selected player Lo
                            lda TabPlayer_TimerAdr_CIA + $01,y ; 
                            sta CCZ_PlayerTimeSourcePtr_Hi  ; set pointer CIA ToD for selected player Hi
; --------------------------------------------------------------------------------------------------------------------- ;
; set castle data time target address pointer for the selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabPlayer_TimerAdr_Var + $00,y ; 
                            sta CCZ_PlayerTimeTargetPtr_Lo  ; set pointer castle time storage for selected player Lo
                            lda TabPlayer_TimerAdr_Var + $01,y ; 
                            sta CCZ_PlayerTimeTargetPtr_Hi  ; set pointer castle time storage for selected player Hi
; --------------------------------------------------------------------------------------------------------------------- ;
; store this players time in castle data variables part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_GameDataVar_Times_Len / $02 ; get length of castle time storage in castle data variables
NextPlayerTimeByte_Save     lda (CCZ_PlayerTimeSourcePtr),y ; get time values from castle data variables
                            sta (CCZ_PlayerTimeTargetPtr),y ; 
                            
                            dey                             ; dec time offset
                            bpl NextPlayerTimeByte_Save     ; check: min - no: continue
                            
                            jmp PlayerSpriteMoveX           ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
MovePlayer                  bit TabFlagSprt_WA_Init         ; test flag sprite work area initialized
                            beq CheckPlayerRoomIO           ; check: init already - yes: no need to reinit
                            
                            eor TabFlagSprt_WA_Init         ; flip flag sprite work area initialized
                            sta CC_WA_Sprite_Flag,x         ; mark sprite work area as used
; --------------------------------------------------------------------------------------------------------------------- ;
; restore player castle time
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PlayerNum,x    ; get player number
                            asl a                           ; *2 - address lenght
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get CIA1/CIA2 timer target address pointer for the selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabPlayer_TimerAdr_CIA + $00,y ; 
                            sta CCZ_PlayerTimeTargetPtr_Lo  ; 
                            lda TabPlayer_TimerAdr_CIA + $01,y ; 
                            sta CCZ_PlayerTimeTargetPtr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set castle data time source address pointer for the selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabPlayer_TimerAdr_Var + $00,y ; 
                            sta CCZ_PlayerTimeSourcePtr_Lo  ; 
                            lda TabPlayer_TimerAdr_Var + $01,y ; 
                            sta CCZ_PlayerTimeSourcePtr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; restore this players time from castle data variables part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_GameDataVar_Times_Len / $02 ; get length of castle time storage in castle data variables
NextPlayerTimeByte_Restore  lda (CCZ_PlayerTimeSourcePtr),y ; 
                            sta (CCZ_PlayerTimeTargetPtr),y ; 
                            
                            dey                             ; dec time offset
                            bpl NextPlayerTimeByte_Restore  ; check: min - no: continue
                            
                            ldy CC_WA_Sprite_PlayerNum,x    ; get player number
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_IO_Start ; test flag player enters/leaves a room
                            beq RoomIO_Continue             ; check: EQ - yes
                            
                            jsr PlayerSpriteMoveGetData     ; uncompress and color player sprite
                            jmp CheckPlayerTrapSwitchStatus ; see if this player touched a trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
; check ongoing room In/Out
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayerRoomIO           lda CC_WA_Sprite_PlayerNum,x    ; get this player number
                            tay                             ; set as offset
                            
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_IO_Room ; test ongoing room In/Out ongoing
                            beq CheckPlayerRoomIO_Done      ; check: ongoing - no
                            
                            cmp #CC_GameDataVar_Flag_IO_Start ; test start room In/Out
                            bne CheckPlayerArrived          ; check: start - no
                            
                            lda #CC_GameDataVar_Flag_IO_Room ; 
                            sta CC_GameDataVar_Flag,y       ; set this player status flag in castle data variables
                            
                            jmp RoomIO_Continue             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayerRoomIO_Done      sty TabWrkPlayer_Num            ; save this player number
                            
                            ldy CC_WA_Sprite_RoomIO_Block_Off,x ; get offset room In/Out block
                            lda TabPlayer_RoomIO_EoD,y      ; 
                            cmp #TabPlayer_RoomIO_EoD_No    ; test flag not End of In/Out block
                            beq SetNextInOutBlockOff        ; check: EQ - yes: set next IO block offset
                            
                            ldy TabWrkPlayer_Num            ; restore this player number
                            sta CC_GameDataVar_Flag,y       ; set this player status flag in castle data variables
                            
                            lda #$01                        ; get initial value
                            sta CC_WA_Sprite_SeqNum,x       ; sprite sequence number
                            
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            jmp CheckPlayerArrived          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance offset to next Room In/Out data block
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextInOutBlockOff        clc                             ; 
                            lda CC_WA_Sprite_RoomIO_Block_Off,x ; get offset room In/Out block
                            adc #TabPlayer_RoomIO_Block_Len ; add block length
                            sta CC_WA_Sprite_RoomIO_Block_Off,x ; set new offset room In/Out block
                            
                            tay                             ; 
                            
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            adc TabPlayer_RoomIO_Add_PosX,y ; 
                            sta CC_WA_Sprite_PosX,x         ; 
                            
                            clc                             ; 
                            lda CC_WA_Sprite_PosY,x         ; 
                            adc TabPlayer_RoomIO_Add_PosY,y ; 
                            sta CC_WA_Sprite_PosY,x         ; 
                            
RoomIO_Continue             ldy CC_WA_Sprite_RoomIO_Block_Off,x ; get offset room In/Out block
                            lda TabPlayer_RoomIO_SpriteNum,y; 
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            jsr PlayerSpriteMoveGetData     ; uncompress and color player sprite
                            jmp PlayerSpriteMoveX           ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player has arrived in this room
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayerArrived          cmp #CC_GameDataVar_Flag_InRoom ; test this player has arrived in room
                            beq CheckPlayerTrapSwitchStatus ; check: arrived - yes: check if trap switch is touched
                            
                            lda CC_WA_Sprite_Flag,x         ; 
                            ora TabFlagSprt_Moves           ; set flag sprite to be moved in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; 
                            
                            jmp PlayerSpriteMoveX           ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player has touched a trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayerTrapSwitchStatus lda CC_WA_Sprite_TrapSw_DataOff,x ; get this player trap door switch work area offset
                            cmp #$ff                        ; test initial value
                            beq SetPlayerStatus             ; check: EQ - yes: still init value - trap switch not touched
                            
                            cmp CC_WA_Sprite_Player_SwDataOff,x ; test with trap castle data offset
                            beq SetPlayerStatus             ; check: still same - yes: avoid constant switching
                            
                            jsr RoomItemTrapDoorHandler     ; flip the trap door mode - paint the trap door switch - mark move control data
                            
SetPlayerStatus             sta CC_WA_Sprite_Player_SwDataOff,x ; 
                            
                            lda #$ff                        ; get initial value
                            sta CC_WA_Sprite_TrapSw_DataOff,x ; init this player trap door switch work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
; check move control data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameSpriteMoveCtrlPtrSet    ; prepare and set sprite move control memory pointer
                            
                            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; get move control value for this player position
                            and CC_WA_Sprite_Player_Move_No,x ; isolate this players move control stop value for occupied ladders and poles
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
                            
                            lda #$ff                        ; get initial value
                            sta CC_WA_Sprite_Player_Move_No,x ; reinit this players move control stop value for occupied ladders and poles
; --------------------------------------------------------------------------------------------------------------------- ;
; check draw grid row offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDrawGrid_PosY_Off     ; get sprite max row offset in draw grid ($00-$07)
                            beq CheckDrawGridFloorColOff    ; check: start of grid - yes: foot on start - check column offset
; --------------------------------------------------------------------------------------------------------------------- ;
; not on start - this player might be on a ladder or on a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkPlayer_MoveCtrl_Val   ; get move control work value for this player
                            and #CC_MoveCtrl_Up_Do          ; isolate move up/down - ladder or pole
                            bne CheckJoystickInput          ; check: ladder/pole - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; not on floor / not on ladder / not on pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkPlayer_MoveCtrl_Val   ; get move control work value for this player
                            and #~CC_MoveCtrl_Le_Ri         ; clear move left/right - floor
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDrawGrid_PosY_Off     ; get sprite max row offset in draw grid ($00-$07)
                            lsr a                           ; /2
                            cmp TabWrkDrawGrid_PosX_Off     ; test sprite max x-offset in draw grid ($00-$03)
                            beq DrawGridMatchPosXY          ; check: EQ - yes: only possible match is $02
                            
                            lda TabWrkPlayer_MoveCtrl_Val   ; get move control work value for this player
                            and #CC_MoveCtrl_Le_Ri | CC_MoveCtrl_Up_Do | CC_MoveCtrl_Bit5 | CC_MoveCtrl_Bit1 ; clear bit7 and bit3 (.###.###)
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
                            jmp CheckJoystickInput          ; 
                            
DrawGridMatchPosXY          lda TabWrkPlayer_MoveCtrl_Val   ; get move control work value for this player
                            and #CC_MoveCtrl_Le_Ri | CC_MoveCtrl_Up_Do | CC_MoveCtrl_Bit7  | CC_MoveCtrl_Bit3 ; clear bit5 and bit1 (##.###.#)
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
                            jmp CheckJoystickInput          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; this player is on a floor - check draw grid column offset
; --------------------------------------------------------------------------------------------------------------------- ;
CheckDrawGridFloorColOff    lda TabWrkDrawGrid_PosX_Off     ; get sprite max x-offset in draw grid ($00-$03)
                            cmp #$03                        ; test end of draw grid col
                            bne CheckMinGridColOff          ; check: end - no: bypass adapt move control pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; end of draw grid column - set move control data pointer one row up and one column forward
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            sbc #LLEN2 - $02                ; add double row of $50 cols - each ctrl screen entry has $02 bytes
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcs GetPlayerMoveCtrl_Ri        ; check: underflow - no
                            dec CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get move control in front of this player
; --------------------------------------------------------------------------------------------------------------------- ;
GetPlayerMoveCtrl_Ri        ldy #$00                        ; 
                            
                            lda TabWrkPlayer_MoveCtrl_Val   ; get move control work value for this player
                            and #CC_MoveCtrl_Le_Ri | CC_MoveCtrl_Up_Do | CC_MoveCtrl_Bit5 ; clear bit7 / bit3 / bit1 (.###.#.#)
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
                            
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #CC_MoveCtrl_Bit1           ; clear all but bit1
                            ora TabWrkPlayer_MoveCtrl_Val   ; insert move control work value for this player
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
                            
                            jmp CheckJoystickInput          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CheckMinGridColOff          cmp #$00                        ; test start of draw grid column
                            bne IsolatePureMoves            ; check: start - no: bypass set ctrl ptr one row up
; --------------------------------------------------------------------------------------------------------------------- ;
; start of draw grid column - set move control data pointer one row up and one column backward
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            sbc #LLEN2 + $02                ; add double row of $50 cols - each ctrl screen entry has $02 bytes
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcs GetPlayerMoveCtrl_Le        ; check: underflow - no
                            dec CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get move control behind of this player
; --------------------------------------------------------------------------------------------------------------------- ;
GetPlayerMoveCtrl_Le        ldy #$00                        ; 
                            lda TabWrkPlayer_MoveCtrl_Val   ; get move control work value for this player
                            and #CC_MoveCtrl_Le_Ri | CC_MoveCtrl_Up_Do | CC_MoveCtrl_Bit3 ; clear bit7 / bit5 / bit1 (.#.###.#) 
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
                            
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #CC_MoveCtrl_Bit7           ; clear all but bit7
                            ora TabWrkPlayer_MoveCtrl_Val   ; insert move control work value for this player
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
                            
                            jmp CheckJoystickInput          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; mid of draw grid column - isolate all possible moves
; --------------------------------------------------------------------------------------------------------------------- ;
IsolatePureMoves            lda TabWrkPlayer_MoveCtrl_Val   ; get move control work value for this player
                            and #CC_MoveCtrl_Up | CC_MoveCtrl_Right | CC_MoveCtrl_Down | CC_MoveCtrl_Left ; 
                            sta TabWrkPlayer_MoveCtrl_Val   ; set new move control work value for this player
; --------------------------------------------------------------------------------------------------------------------- ;
; get and check joystick input for this player
; --------------------------------------------------------------------------------------------------------------------- ;
CheckJoystickInput          lda CC_WA_Sprite_PlayerNum,x    ; get player number
                            jsr GameGetInputKeyJoy          ; get STOP key and player jostick input
                            
                            lda TabWrkInput_Joy_Fire        ; 
                            sta CC_WA_Sprite_FireButton,x   ; set status fire button for this player
                            
                            lda TabWrkInput_Joy_Move_Subst  ; get move substitition value from TabJoy_Move_Subst
                            sta CC_WA_Sprite_Move_Subst,x   ; set move substitition value for this player
; --------------------------------------------------------------------------------------------------------------------- ;
; get and check joystick move input
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; set move value as offset
                            bmi SetPlayerMove_None          ; check: move - no: set this player does not move - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick move substitute for a legal move for the tile under this player position
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSpriteMove,y             ; get sprite move direction bit table value for this players move
                            bit TabWrkPlayer_MoveCtrl_Val   ; test move control work value for this player
                            beq CheckPlayerMoveBad          ; check: legal - no: illegal move for the tile of this players position
; --------------------------------------------------------------------------------------------------------------------- ;
; illegal move values for the tile of this players position
;   left  at start of floor
;   right at end   of floor
;   down  at end   of pole
;   down  at end   of ladder
;   up    at top   of ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; restore move value
                            sta CC_WA_Sprite_Player_Move,x  ; set legal move for the tile of this player position
                            
                            jmp CheckPlayerMove_Ri          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check combined moves - the combined values directly surround the left/right move values
; --------------------------------------------------------------------------------------------------------------------- ;
; TabJoyMoveSubst_UR = .......# ; $01 ; - $01 = Up/right
; TabJoyMoveSubst_R  = ......#. ; $02 ;         Right
; TabJoyMoveSubst_DR = ......## ; $03 ; + $01 = Down/right
; --------------------------------------------------------------------------------------------------------------------- ;
; TabJoyMoveSubst_DL = .....#.# ; $05 ; - $01 = Down/left
; TabJoyMoveSubst_L  = .....##. ; $06 ;         Left
; TabJoyMoveSubst_UL = .....### ; $07 ; + $01 = Up/left
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayerMoveBad          lda CC_WA_Sprite_Player_Move,x  ; get legal move for the tile under this player position
                            bmi SetPlayerMove_None          ; check: move - no: set this player does not move - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; add one - check complex move of up + left/right
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$01                        ; set to the adjacent move up
                            and #TabJoy_Move_Subst_Mask     ; allow move values only - correct a possible overflow
                            cmp TabWrkInput_Joy_Move_Subst  ; test with move substitition value from TabJoy_Move_Subst
                            beq CheckPlayerMove             ; check: legal move - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; subtract one - check complex move of down + left/right - $02 because of the previous add of $01
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc #$02                        ; set to the adjacent move down
                            and #TabJoy_Move_Subst_Mask     ; allow move values only - correct a possible underflow
                            cmp TabWrkInput_Joy_Move_Subst  ; test with move substitition value from TabJoy_Move_Subst
                            bne SetPlayerMove_None          ; check: legal move - no: set this player does not move - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check the legal move found
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayerMove             ldy CC_WA_Sprite_Player_Move,x  ; get legal move for the tile of this player position
                            lda TabSpriteMove,y             ; get sprite move direction bit table value for this players move
                            bit TabWrkPlayer_MoveCtrl_Val   ; test move control work value for this player
                            bne CheckPlayerMove_Ri          ; check: legal move - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; set this player no move and exit
; --------------------------------------------------------------------------------------------------------------------- ;
SetPlayerMove_None          lda #TabJoy_Move_Subst_None     ; 
                            sta CC_WA_Sprite_Player_Move,x  ; set legal move for the tile of this player position
                            
                            jmp PlayerSpriteMoveX           ; not moving - exit
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayerMove_Ri          lda CC_WA_Sprite_Player_Move,x  ; get legal move for the tile of this player position
                            and #TabJoy_Move_Subst_DR       ; isolate move down/right
                            cmp #TabJoy_Move_Subst_R        ; test move right
                            bne CheckPlayerMove_Up          ; check: right - no: bypass PosY correction
; --------------------------------------------------------------------------------------------------------------------- ;
; correct sprite draw grid PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CC_WA_Sprite_PosY,x         ; 
                            sbc TabWrkDrawGrid_PosY_Off     ; sub sprite max y-offset in draw grid ($00-$07)
                            sta CC_WA_Sprite_PosY,x         ; 
                            
                            jmp SetPlayerNewPos             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayerMove_Up          cmp #TabJoy_Move_Subst_U        ; test player move up
                            bne SetPlayerNewPos             ; check: move up - yes: bypass PosX correction
; --------------------------------------------------------------------------------------------------------------------- ;
; correct sprite draw grid PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            sbc TabWrkDrawGrid_PosX_Off     ; sub sprite max x-offset in draw grid ($00-$03)
                            sta CC_WA_Sprite_PosX,x         ; 
                            
                            inc CC_WA_Sprite_PosX,x         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; update player PosX/PosY
; --------------------------------------------------------------------------------------------------------------------- ;
SetPlayerNewPos             ldy CC_WA_Sprite_Player_Move,x  ; get legal move for the tile of this player position
                            
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            adc TabPlayer_Sprite_PosX_Add,y ; 
                            sta CC_WA_Sprite_PosX,x         ; 
                            
                            clc                             ; 
                            lda CC_WA_Sprite_PosY,x         ; 
                            adc TabPlayer_Sprite_PosY_Add,y ; 
                            sta CC_WA_Sprite_PosY,x         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; care for next player move sprite number and uncompress the necessary sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; get legal move for the tile of this player position
                            
                            and #TabJoy_Move_Subst_DR       ; isolate move down/right
                            bne SetNextSprtNumClimb_Up      ; check: down/right - yes
                            
                            lda TabWrkPlayer_MoveCtrl_Val   ; get move control work value for this player
                            and #CC_MoveCtrl_Up             ; isolate move control up - ladder
                            beq SetSprtNumSlide_Pole        ; check: ladder - no: is pole
                            
                            lda CC_WA_Sprite_Player_Move,x  ; get legal move for the tile of this player position
                            bne SetNextSprtNumClimb_Do      ; check: TabJoyMoveSubst_U - no: move a ladder down
                            
                            inc CC_WA_Sprite_Num,x          ; set next sprite number climb up
                            jmp SetNextSprtNumClimb_Min     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set next player sprite number for climb a ladder downwards
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSprtNumClimb_Do      dec CC_WA_Sprite_Num,x          ; set next sprite number climb down
                            
SetNextSprtNumClimb_Min     lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_PlayerClimb_Min  ; test 
                            bcs SetNextSprtNumClimb_Max     ; check: GE - yes: bypass reset to max
                            
                            lda #SpriteNum_PlayerClimb_Max  ; 
                            sta CC_WA_Sprite_Num,x          ; reset to max
                            
                            jmp GoGetPlayerSpriteData       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSprtNumClimb_Max     cmp #SpriteNum_PlayerClimb_Max + $01 ; test max
                            bcc GoGetPlayerSpriteData       ; check: LT - yes: get new sprite data
                            
                            lda #SpriteNum_PlayerClimb_Min  ; 
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            jmp GoGetPlayerSpriteData       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetSprtNumSlide_Pole        lda #SpriteNum_PlayerSlidePole  ; 
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            jmp GoGetPlayerSpriteData       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set next player sprite number for climb a ladder upwards
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSprtNumClimb_Up      inc CC_WA_Sprite_Num,x          ; 
                            
                            lda CC_WA_Sprite_Player_Move,x  ; get legal move for the tile of this player position
                            cmp #TabJoy_Move_Subst_D        ; test move down
                            bcs GetNextSprtNum_Le           ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; advance player sprite number for move right - care for max overflow
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Num,x          ; get this player sprite number
                            cmp #SpriteNum_PlayerMoveRi_Max + $01 ; test max
                            bcs GetNextSprtNumMin_Ri        ; check: GE - yes: set min
                            
                            cmp #SpriteNum_PlayerMoveRi_Min ; test min
                            bcs GoGetPlayerSpriteData       ; check: GE - yes: bypass reset to min
                            
GetNextSprtNumMin_Ri        lda #SpriteNum_PlayerMoveRi_Min ; 
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            jmp GoGetPlayerSpriteData       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance player sprite number for move left - care for max overflow
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSprtNum_Le           lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_PlayerMoveLe_Max + $01 ; test 
                            bcc GoGetPlayerSpriteData       ; check: LT - yes: bypass reset to min
                            
                            lda #SpriteNum_PlayerMoveLe_Min ; 
                            sta CC_WA_Sprite_Num,x          ; reset to min
; --------------------------------------------------------------------------------------------------------------------- ;
; uncompress next player sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetPlayerSpriteData       jsr PlayerSpriteMoveGetData     ; uncompress and color player sprite
                            
PlayerSpriteMoveX           jmp RoomSpriteHandler.RTS_RoomSpriteHandler ; back to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerSpriteMoveGetData   Does    : uncompress and color player sprite
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerSpriteMoveGetData    .block                           ; 
                            jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
                            
                            txa                             ; get offset sprite WA
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
                            lsr a                           ; /32
                            sta TabWrkPlayer_SpriteNum      ; set as player sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; get color for selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_Sprite_PlayerNum,x    ; get player number
                            lda TabPlayer_Color,y           ; get color for selected player
                            
                            ldy TabWrkPlayer_SpriteNum      ; get player sprite number
                            sta SP0COL,y                    ; VIC($D027) Color Sprite 0
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; offsets data blocks for player leaves/enters a room stepss
; --------------------------------------------------------------------------------------------------------------------- ;
TabPlayer_RoomIO            = *       ; 
TabPlayer_RoomIO_Add_PosX   = * + $00 ;       adds to player SpritePosX
TabPlayer_RoomIO_Add_PosY   = * + $01 ;       adds to player SpritePosY
TabPlayer_RoomIO_SpriteNum  = * + $02 ;       player room In/Out sprite number
TabPlayer_RoomIO_EoD        = * + $03 ; flag: end of room In/Out data blocks
TabPlayer_RoomIO_EoD_No         = $ff ;       another data block follows
; --------------------------------------------------------------------------------------------------------------------- ;
; step sequence blocks player leaves a room
; --------------------------------------------------------------------------------------------------------------------- ;
TabPlayer_RoomIO_Off_Leave  = * - TabPlayer_RoomIO           ; 
                            .byte $00                        ;       player PosX addition value
                            .byte $00                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_01 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
TabPlayer_RoomIO_Block_Len  = * - TabPlayer_RoomIO           ; 
                            
                            .byte $01                        ;       player PosX addition value
                            .byte $ff                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_02 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $01                        ;       player PosX addition value
                            .byte $00                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_03 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $01                        ;       player PosX addition value
                            .byte $ff                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_04 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $01                        ;       player PosX addition value
                            .byte $00                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_05 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $01                        ;       player PosX addition value
                            .byte $ff                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_06 ;       player sprite number
                            .byte $01                        ; flag: End of Data enter a room
; --------------------------------------------------------------------------------------------------------------------- ;
; step sequence blocks player enters a room
; --------------------------------------------------------------------------------------------------------------------- ;
TabPlayer_RoomIO_Off_Enter  = * - TabPlayer_RoomIO           ; 
                            .byte $00                        ;       player PosX addition value
                            .byte $00                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_06 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $ff                        ;       player PosX addition value
                            .byte $01                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_05 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $ff                        ;       player PosX addition value
                            .byte $00                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_04 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $ff                        ;       player PosX addition value
                            .byte $01                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_03 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $ff                        ;       player PosX addition value
                            .byte $00                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_02 ;       player sprite number
                            .byte TabPlayer_RoomIO_EoD_No    ; flag: a next move block exists
                            
                            .byte $ff                        ;       player PosX addition value
                            .byte $01                        ;       player PosY addition value
                            .byte SpriteNum_PlayerArrives_01 ;       player sprite number
                            .byte $00                        ; flag: End of Data leave a room
; --------------------------------------------------------------------------------------------------------------------- ;
; save offset for players sprite work areas
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkPlayer_Sprite_WA      .byte $80 ; player #1
                            .byte $a0 ; player #2
; --------------------------------------------------------------------------------------------------------------------- ;
TabPlayer_Color             = *       ; 
TabPlayer_Color_P1          .byte YELLOW ; 
TabPlayer_Color_P2          .byte ORANGE ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkPlayer_MoveCtrl_Val   .byte $82 ; player move control value
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkPlayer_Num            = *       ; player number
TabWrkPlayer_SpriteNum      .byte $d1 ; player sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
TabPlayer_Sprite_PosX_Add    = *      ; 
                            .byte $00 ; 
                            .byte $01 ; 
                            .byte $01 ; 
                            .byte $01 ; 
                            .byte $00 ; 
                            .byte $ff ; -1
                            .byte $ff ; -1
                            .byte $ff ; -1
; --------------------------------------------------------------------------------------------------------------------- ;
TabPlayer_Sprite_PosY_Add    = *      ; 
                            .byte $fe ; -2
                            .byte $fe ; -2
                            .byte $00 ; 
                            .byte $02 ; 
                            .byte $02 ; 
                            .byte $02 ; 
                            .byte $00 ; 
                            .byte $fe ; -2
; --------------------------------------------------------------------------------------------------------------------- ;
TabPlayer_TimerAdr_CIA      = *       ; 
                            .word TOD10TH ; CIA1 - time of day player #1
                            .word TO210TH ; CIA2 - time of day player #2
; --------------------------------------------------------------------------------------------------------------------- ;
TabPlayer_TimerAdr_Var      = *       ; 
                            .word CC_GameDataVar_Times_P1 ; address time values for player #1 in castle data variables
                            .word CC_GameDataVar_Times_P2 ; address time values for player #2 in castle data variables
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerTrapTouch           Does    : check if player is on open trap door or touched a trap door switch
;                           Expects : .X=offset mummy sprite work area
;                                   : .Y=offset work area trap door
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerTrapTouch            .block                           ; 
                            lda CC_WA_ItemDef_Type,y        ; get work area type
                            cmp #CC_WA_ItemDef_Type_TrapDoor; test trap door
                            bne TestPlayerTrapSwitch        ; check: EQ - no: continue with trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
; was trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get player PosX
                            adc CC_WA_Sprite_Width,x        ; 
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; sub item PosX
                            cmp #$04                        ; test trap door width
                            bcc SetFlagPlayerWasHit         ; check: LT - yes: on trap door - flag it
; --------------------------------------------------------------------------------------------------------------------- ;
; test if player touches a trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
TestPlayerTrapSwitch        lda #TabWrkSprt_Flag_Hit_No     ; get inital value
                            sta TabWrkSprt_Flag_Hit         ; init flag this sprite is still not hurt
                            
                            lda CC_WA_ItemDef_Type,y        ; get work area type
                            cmp #CC_WA_ItemDef_Type_TrapCtrl; test trap door switch
                            bne PlayerTrapTouchX            ; check: EQ - no: noting to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; was trap door switch - check if player touches it
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get player PosX
                            adc CC_WA_Sprite_Width,x        ; 
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; 
                            cmp #$04                        ; test trap switch width
                            bcs PlayerTrapTouchX            ; check: GE - yes: not on trap switch - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; save trap castle data offset if this player touched a trap switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Trap_DataOff,y   ; get offset this trap door in castle data
                            sta CC_WA_Sprite_TrapSw_DataOff,x ; set trap castle data offset if a trap switch was touched
                            
                            jmp PlayerTrapTouchX            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; flag this player hit by an open trap door
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagPlayerWasHit         ldy CC_WA_Sprite_PlayerNum,x    ; get player number
                            lda #CC_GameDataVar_Flag_Hit    ; 
                            sta CC_GameDataVar_Flag,y       ; set this player status flag in castle data variables
                            
PlayerTrapTouchX            jmp RoomPlayerMoveHandler.RTS_RoomPlayerMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerSpriteCollide       Does    : player collides with another sprite
;                           Expects : .X=offset player sprite work area
;                                   : .Y=offset touching sprite work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerSpriteCollide        .block                           ; 
                            lda CC_WA_Sprite_Type,y         ; get sprite type number of the touched sprite
                            cmp #CC_WA_Sprite_Type_Force    ; test touching a force field
                            beq SetFlagPlayerIsAlive        ; check: EQ - yes: set flag sprite is alive - exit
                            
                            cmp #CC_WA_Sprite_Type_Player   ; test touching a player
                            bne SetFlagPlayerDeadlyHit      ; check: EQ - no: player hit by Spark / Mummy / Gun Beam / Frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
; players cannot pass each other on ladders or poles
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Num,y          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if touching player is on ladder or pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #SpriteNum_PlayerClimb_01   ; test on ladder
                            beq ChkThisPlayerLadderPole     ; check: EQ - yes: test this player
                            
                            cmp #SpriteNum_PlayerClimb_02   ; test on ladder 
                            beq ChkThisPlayerLadderPole     ; check: EQ - yes: test this player
                            
                            cmp #SpriteNum_PlayerClimb_03   ; test on ladder
                            beq ChkThisPlayerLadderPole     ; check: EQ - yes: test this player
                            
                            cmp #SpriteNum_PlayerClimb_04   ; test on ladder
                            beq ChkThisPlayerLadderPole     ; check: EQ - yes: test this player
                            
                            cmp #SpriteNum_PlayerSlidePole  ; test on pole
                            bne SetFlagPlayerIsAlive        ; check: NE - yes: set flag player is alive - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if this player is on ladder or pole
; --------------------------------------------------------------------------------------------------------------------- ;
ChkThisPlayerLadderPole     lda CC_WA_Sprite_Num,x          ; 
                            
                            cmp #SpriteNum_PlayerClimb_01   ; test on ladder
                            beq ChkPlayerLadderPolePos      ; check: EQ - yes
                            
                            cmp #SpriteNum_PlayerClimb_02   ; test on ladder
                            beq ChkPlayerLadderPolePos      ; check: EQ - yes
                            
                            cmp #SpriteNum_PlayerClimb_03   ; test on ladder
                            beq ChkPlayerLadderPolePos      ; check: EQ - yes
                            
                            cmp #SpriteNum_PlayerClimb_04   ; test on ladder
                            beq ChkPlayerLadderPolePos      ; check: EQ - yes
                            
                            cmp #SpriteNum_PlayerSlidePole  ; test on pole
                            bne SetFlagPlayerIsAlive        ; check: NE - yes: set flag player is alive - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; both players are on a ladder or a pole - get move control value to forbid a furth move up/down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkPlayerLadderPolePos      lda CC_WA_Sprite_PosY,y         ; get touching player PosY
                            cmp CC_WA_Sprite_PosY,x         ; test with this players PosY 
                            beq SetFlagPlayerIsAlive        ; check: EQ - yes: bypass setting move isolation flags
                            bcc GetForbidMove_Up            ; check: LT - yes: get move control forbid move up
                            
                            lda #~CC_MoveCtrl_Down          ; get move control forbid move down
                            sta CC_WA_Sprite_Player_Move_No,x ; set move control stop value for occupied ladders and poles
                            
                            jmp SetFlagPlayerIsAlive        ; set flag sprite is alive - exit
; --------------------------------------------------------------------------------------------------------------------- ;
GetForbidMove_Up            lda #~CC_MoveCtrl_Up            ; get move control forbid move up
                            sta CC_WA_Sprite_Player_Move_No,x ; set move control stop value for occupied ladders and poles
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag player survived
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagPlayerIsAlive        lda #TabWrkSprt_Flag_Dead_No    ; 
                            sta TabWrkSprt_Flag_Dead        ; set flag player is still alive
                            
                            jmp PlayerSpriteCollideX        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; if player arrived in room set hit flag in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagPlayerDeadlyHit      ldy CC_WA_Sprite_PlayerNum,x    ; get player number
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne SetFlagPlayerIsAlive        ; check: arrived - no: set flag player is alive - exit
                            
                            lda #CC_GameDataVar_Flag_Hit    ; get flag this player was hit
                            sta CC_GameDataVar_Flag,y       ; set this player status flag in castle data variables
                            
PlayerSpriteCollideX        jmp RoomSpriteKillHandler.RTS_RoomSprtSprtCollHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerRoomEnter           Does    : get a player into a room
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerRoomEnter            .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr SpriteGetFree_WA_Block      ; find and initialize the next free sprite work area block
                            
                            ldy TabWrkPlayer_InRoom_Num     ; get number of this player in room
                            
                            txa                             ; get sprite work area offset
                            sta TabWrkPlayer_Sprite_WA,y    ; store sprite work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set door data pointer in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_TargDoor,y   ; get players start door number from castle data variables
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - CC_Door__Item_Len
                            
                            clc                             ; 
                            adc TabWrkDoor_DataPtr_Lo       ; 
                            sta CCZ_DoorDataPtr_Lo          ; 
                            
                            lda TabWrkDoor_DataPtr_Hi       ; 
                            adc #$00                        ; add carry
                            sta CCZ_DoorDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check door status
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_MapWall            ; get offset door wall
                            lda (CCZ_DoorDataPtr),y         ; get door wall
                            and #CC_Door_MapWall_Open       ; isolate flag door open
                            beq DoorIsStillClosed           ; check: open - no: still closed
; --------------------------------------------------------------------------------------------------------------------- ;
; door is open - prepare player to be moved in
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_GameDataVar_Flag_IO_Start ; get flag player enters/leaves a room
                            ldy TabWrkPlayer_InRoom_Num     ; get number of this player in room
                            sta CC_GameDataVar_Flag,y       ; set flag this player enters a room
                            
                            clc                             ; 
                            ldy #CC_Door_PosX               ; get offset door PosX
                            lda (CCZ_DoorDataPtr),y         ; get door PosX
                            adc #$0b                        ; 
                            sta CC_WA_Sprite_PosX,x         ; init player start PosX
                            
                            clc                             ; 
                            ldy #CC_Door_PosY               ; get offset door PosY
                            lda (CCZ_DoorDataPtr),y         ; get door PosY
                            adc #$0c                        ; 
                            sta CC_WA_Sprite_PosY,x         ; init player start PosY
                            
                            lda #TabPlayer_RoomIO_Off_Enter ; get offset player enters a room block
                            sta CC_WA_Sprite_RoomIO_Block_Off,x ; init offset enter room In/Out block
                            
                            lda #$03                        ; 
                            sta CC_WA_Sprite_SeqNum,x       ; init sprite sequence number
                            
                            jmp IniThisPlayerSprite_WA      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; door is closed - starting room - just place the player in front of the door
; --------------------------------------------------------------------------------------------------------------------- ;
DoorIsStillClosed           lda #CC_GameDataVar_Flag_InRoom ; get flag player has arrived in room
                            ldy TabWrkPlayer_InRoom_Num     ; get number of this player in room
                            sta CC_GameDataVar_Flag,y       ; set this player status flag in castle data variables
                            
                            ldy #$00                        ; get offset door PosX
                            lda (CCZ_DoorDataPtr),y         ; get door PosX
                            clc                             ; 
                            adc #$06                        ; 
                            sta CC_WA_Sprite_PosX,x         ; init player start PosX
                            
                            ldy #$01                        ; get offset door PosY
                            lda (CCZ_DoorDataPtr),y         ; get door PosY
                            clc                             ; 
                            adc #$0f                        ; 
                            sta CC_WA_Sprite_PosY,x         ; init player start PosY
; --------------------------------------------------------------------------------------------------------------------- ;
IniThisPlayerSprite_WA      lda #$03                        ; 
                            sta CC_WA_Sprite_Width,x        ; init this player sprite width
                            
                            lda #$11                        ; 
                            sta CC_WA_Sprite_Height,x       ; init this player sprite height
                            
                            lda #TabJoy_Move_Subst_None     ; 
                            sta CC_WA_Sprite_Player_Move,x  ; init legal move for the tile of this player position
                            
                            lda TabWrkPlayer_InRoom_Num     ; get number of this player in room
                            sta CC_WA_Sprite_Player_CtrlVal,x ; 
                            
                            lda #SpriteNum_PlayerMoveLe_Min ; 
                            sta CC_WA_Sprite_Num,x          ; init player sprite number
                            
                            lda #$ff                        ; 
                            sta CC_WA_Sprite_Player_SwDataOff,x ; 
                            sta CC_WA_Sprite_TrapSw_DataOff,x ; trap castle data offset if a trap switch was touched
                            sta CC_WA_Sprite_Player_Move_No,x ; move control stop value for occupied ladders and poles
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkPlayer_InRoom_Num     .byte $ba ; number of this player in room
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LightSparkSpriteMove      Does    : get next lightning machine random spark sprite
;                           Expects : .X=offset lightning machine spark sprite work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LightSparkSpriteMove       .block                           ; 
                            lda CC_WA_Sprite_Flag,x         ; get spark sprite flag
                            bit TabFlagSprt_Moves           ; test flag sprite to be moved in RoomSpriteHandler
                            beq MoveSpark                   ; check: move - yes: handle it
; --------------------------------------------------------------------------------------------------------------------- ;
; mark spark as inactive
; --------------------------------------------------------------------------------------------------------------------- ;
                            eor TabFlagSprt_Moves           ; flip flag sprite to be moved in RoomSpriteHandler
                            
                            ora TabFlagSprt_Disable         ; insert flag sprite to be disabled in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; set flag sprite to be disabled
                            
                            jmp LightSparkSpriteMoveX       ; exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; try to move this spark
; --------------------------------------------------------------------------------------------------------------------- ;
MoveSpark                   bit TabFlagSprt_WA_Init         ; test flag sprite work area initialized
                            beq GetSparkRndVal              ; check: init - no: bypass set init flag
                            
                            eor TabFlagSprt_WA_Init         ; flip flag sprite work area initialized
                            sta CC_WA_Sprite_Flag,x         ; mark sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; get a random flicker value for sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
GetSparkRndVal              jsr GetNextRandomValue          ; get a random value
                            and #$03                        ; limit - ......##
                            sta CC_WA_Sprite_SeqNum,x       ; init spark sprite sequence number
                            
                            inc CC_WA_Sprite_SeqNum,x       ; advance spark sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
; get a random flicker value for sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GetNextRandomValue          ; get a random value
                            and #$03                        ; limit - ......##
; --------------------------------------------------------------------------------------------------------------------- ;
; test spark sprite number lower limit
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #SpriteNum_SparkFlicker_Min ; add minimum spark sprite number
                            cmp CC_WA_Sprite_Num,x          ; test with actual sprite number
                            bne SetSparkFlickerSprtNum      ; check: EQ - no: take it
                            
                            clc                             ; is minimum
                            adc #$01                        ; advance spark sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; test spark sprite number upper limit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #SpriteNum_SparkFlicker_Max + $01 ; test with maximum spark sprite number
                            bcc SetSparkFlickerSprtNum      ; check: LT - yes: take it
                            
                            lda #SpriteNum_SparkFlicker_Min ; reset spark sprite number to minimum
                            
SetSparkFlickerSprtNum      sta CC_WA_Sprite_Num,x          ; set new spark sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; set lightning spark sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
                            
LightSparkSpriteMoveX       jmp RoomSpriteHandler.RTS_RoomSpriteHandler ; back to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LightSparkSpriteCollide   Does    : set flag lightning machine spark is still active
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LightSparkSpriteCollide    .block                           ; 
                            lda #TabWrkSprt_Flag_Dead_No    ; 
                            sta TabWrkSprt_Flag_Dead        ; set flag light is still active
                            
                            jmp RoomSpriteKillHandler.RTS_RoomSprtSprtCollHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LightSpriteInitSpark_WA   Does    : get and initialize a spark sprite work area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LightSpriteInitSpark_WA    .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; 
                            jsr SpriteGetFree_WA_Block      ; find and initialize the next free sprite work area block
                            
                            lda #CC_WA_Sprite_Type_Spark    ; get type lighning machine spark
                            sta CC_WA_Sprite_Type,x         ; init work area type lighning machine spark
; --------------------------------------------------------------------------------------------------------------------- ;
; adjust spark start PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_PosY,y        ; get lightning machine orb PosY
                            clc                             ; 
                            adc #$08                        ; step one room grid positions down
                            sta CC_WA_Sprite_PosY,x         ; set spark PosY
                            
                            lda CC_WA_ItemDef_PosX,y        ; get lightning machine orb PosX
                            sta CC_WA_Sprite_PosX,x         ; set spark PosX
                            
                            lda CC_WA_Item_Light_Orb_DataOff,y ; get offset lightning machine orb in castle data
                            sta CC_WA_Sprite_Light_DataOff,x; save offset lightning machine orb in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ForceSpriteMove           Does    : get next force field random spark sprite
;                           Expects : .X=offset force field sprite work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ForceSpriteMove            .block                           ; 
                            lda CC_WA_Sprite_Flag,x         ; get force field sprite flag
                            bit TabFlagSprt_Moves           ; test flag sprite to be moved in RoomSpriteHandler
                            beq MoveForce                   ; check: moves - yes: handle it
; --------------------------------------------------------------------------------------------------------------------- ;
; mark force field sprite as inactive
; --------------------------------------------------------------------------------------------------------------------- ;
                            eor TabFlagSprt_Moves           ; flip flag sprite to be moved in RoomSpriteHandler
                            
                            ora TabFlagSprt_Disable         ; insert flag sprite to be disabled in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; set flag sprite to be disabled
                            
                            jmp ForceSpriteMoveX            ; exit
; --------------------------------------------------------------------------------------------------------------------- ;
; try to move this force field
; --------------------------------------------------------------------------------------------------------------------- ;
MoveForce                   bit TabFlagSprt_WA_Init         ; test flag sprite work area initialized
                            beq TestForceMode               ; check: init - no: bypass set init flag
                            
                            eor TabFlagSprt_WA_Init         ; flip flag sprite work area initialized
                            sta CC_WA_Sprite_Flag,x         ; mark sprite work area as used
; --------------------------------------------------------------------------------------------------------------------- ;
; test actual mode of this force field
; --------------------------------------------------------------------------------------------------------------------- ;
TestForceMode               ldy CC_WA_Sprite_Force_Num,x    ; 
                            lda TabWrkForce_Mode,y          ; get actual mode for this force field from mode table
                            cmp #TabWrkForce_Mode_Shut      ; test shut
                            bne CheckForceFieldMode         ; check: shut - yes: insert a gap into floor control data
                            
                            lda CC_WA_Sprite_Force_Mode,x   ; 
                            cmp #CC_WA_Sprite_Force_Mode_Open ; test open
                            beq GetForceSpriteNum           ; check: open - no: get next force field sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; flag force field as open
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Sprite_Force_Mode_Open ; 
                            sta CC_WA_Sprite_Force_Mode,x   ; 
                            
                            jsr GameSpriteMoveCtrlPtrSet    ; prepare and set sprite move control memory pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; get pointer to game control data
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            sbc #CC_MoveCtrl_Entry_Len      ; step one move control position left
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcs MarkFloorPassable           ; check: underflow - no
                            dec CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark start of floor beyond force field curtain
; --------------------------------------------------------------------------------------------------------------------- ;
MarkFloorPassable           ldy #CC_MoveCtrl_Entry_Len * $00; get offset this move control position
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #~CC_MoveCtrl_Right         ; clear a possible move right
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; close a possible gap in floor control data beyond the force field curtain
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_MoveCtrl_Entry_Len * $02; get offset two move control positions right
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #~CC_MoveCtrl_Left          ; clear a possible move left
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            jmp GetForceSpriteNum_Min       ; init force field sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; get next force field sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
GetForceSpriteNum           lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_ForceCurtain_Min ; test min
                            bne GetForceSpriteNum_Min       ; check: EQ - no: get min
                            
                            lda #SpriteNum_ForceCurtain_02  ; 
                            jmp GetForceSpriteData          ; 
                            
GetForceSpriteNum_Min       lda #SpriteNum_ForceCurtain_Min ; 
                            jmp GetForceSpriteData          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; try to mark the fllor beyond the force field curtain as open
; --------------------------------------------------------------------------------------------------------------------- ;
CheckForceFieldMode         lda CC_WA_Sprite_Force_Mode,x   ; 
                            cmp #CC_WA_Sprite_Force_Mode_Open ; test open
                            bne ForceSpriteMoveX            ; check: open - yes: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; flag force field as shut
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Sprite_Force_Mode_Shut ; get force field mode shut
                            sta CC_WA_Sprite_Force_Mode,x   ; set force field shut in work area
                            
                            jsr GameSpriteMoveCtrlPtrSet    ; prepare and set sprite move control memory pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; get pointer to game control data
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            sbc #CC_MoveCtrl_Entry_Len      ; step one move control position left
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcs MarkFloorImpassable         ; check: underflow - no
                            dec CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; insert a gap into floor control data beyond the force field curtain
; --------------------------------------------------------------------------------------------------------------------- ;
MarkFloorImpassable         ldy #CC_MoveCtrl_Entry_Len * $00; get offset this move control position
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            ora #CC_MoveCtrl_Right          ; insert a possible move right
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            ldy #CC_MoveCtrl_Entry_Len * $02; get offset two move control positions right
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            ora #CC_MoveCtrl_Left           ; insert a possible move left
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            lda #SpriteNum_ForceCurtain_Max ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get the desired force field sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
GetForceSpriteData          sta CC_WA_Sprite_Num,x          ; 
                            jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
                            
ForceSpriteMoveX            jmp RoomSpriteHandler.RTS_RoomSpriteHandler ; back to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ForceSpriteCollide        Does    : set flag force field sprite is still active
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ForceSpriteCollide         .block                           ; 
                            lda #TabWrkSprt_Flag_Dead_No    ; 
                            sta TabWrkSprt_Flag_Dead        ; set flag force is still alive
                            
                            jmp RoomSpriteKillHandler.RTS_RoomSprtSprtCollHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ForceSpriteInitField_WA   Does    : alloc and init a force field sprite work area
;                           Expects : .Y=offset force field room data
;                           Returns : .X=offset force field sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
ForceSpriteInitField_WA    .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr SpriteGetFree_WA_Block      ; find and initialize the next free sprite work area block
                            
                            lda #CC_WA_Sprite_Type_Force    ; get force field
                            sta CC_WA_Sprite_Type,x         ; init work area type force field
                            
                            ldy #CC_ForceField_Emitter_PosX ; get offset emitter PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get emitter PosX
                            sta CC_WA_Sprite_PosX,x         ; set emitter PosX in work area
                            
                            ldy #CC_ForceField_Emitter_PosY ; get offset emitter PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get emitter PosY
                            
                            clc                             ; 
                            adc #$02                        ; correct PosY for force field
                            sta CC_WA_Sprite_PosY,x         ; set emitter PosY
                            
                            lda #SpriteNum_ForceCurtain_Min ; get initial value
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            lda TabWrkForce_Num             ; get actual force field number
                            sta CC_WA_Sprite_Force_Num,x    ; 
                            
                            lda #CC_WA_Sprite_Force_Mode_Shut ; get initial value
                            sta CC_WA_Sprite_Force_Mode,x   ; init curtain to close
                            
                            lda #$04                        ; 
                            sta CC_WA_Sprite_SeqNum,x       ; sprite sequence number
                            
                            lda #$02                        ; 
                            sta CC_WA_Sprite_Width,x        ; 
                            
                            lda #$19                        ; 
                            sta CC_WA_Sprite_Height,x       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MummySpriteMove           Does    : get mummy out of his tomb or let him follow preferably player #1
;                           Expects : .X=offset mummy sprite work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MummySpriteMove            .block                           ; 
                            lda CC_WA_Sprite_Flag,x         ; get mummy sprite flag
                            bit TabFlagSprt_Moves           ; test flag sprite to be moved in RoomSpriteHandler
                            beq MummyMove                   ; check: moves - no
; --------------------------------------------------------------------------------------------------------------------- ;
; flag this mummy as inactive
; --------------------------------------------------------------------------------------------------------------------- ;
                            eor TabFlagSprt_Moves           ; flip flag sprite to be moved in RoomSpriteHandler
                            
                            ora TabFlagSprt_Disable         ; insert flag sprite to be disabled in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; set flag sprite to be disabled
                            
                            jmp MummySpriteMoveX            ; exit - nothing more to do
; --------------------------------------------------------------------------------------------------------------------- ;
; try to move this mummy
; --------------------------------------------------------------------------------------------------------------------- ;
MummyMove                   bit TabFlagSprt_WA_Init         ; test flag sprite work area initialized
                            beq CheckMummyTrapSwitchStatus  ; check: init - no
                            
                            eor TabFlagSprt_WA_Init         ; flip flag sprite work area initialized
                            sta CC_WA_Sprite_Flag,x         ; mark sprite work area as used
; --------------------------------------------------------------------------------------------------------------------- ;
; check if mummy is still buried
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Mummy_Mode,x   ; get this mummy mode
                            beq CheckMummyTrapSwitchStatus  ; check: still in tomb - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; init mummy move sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #SpriteNum_MummyMoveLe_01   ; get initial sprite number
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if mummy has touched a trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
CheckMummyTrapSwitchStatus  lda CC_WA_Sprite_Mummy_SwDataOff,x ; get this mummy trap door switch work area offset
                            cmp #$ff                        ; test initial value
                            beq SetMummyStatus              ; check: EQ - yes: still init value - trap switch not touched
; --------------------------------------------------------------------------------------------------------------------- ;
; switch a trap switch only if mummy has left the switch inbetween
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp CC_WA_Sprite_Mummy_WA_Off,x ; test with this mummy work area offset
                            beq SetMummyStatus              ; check: still same offset - yes: avoid constant switching
                            
                            jsr RoomItemTrapDoorHandler     ; flip the trap door mode - paint the trap door switch - mark move control data
                            
SetMummyStatus              sta CC_WA_Sprite_Mummy_WA_Off,x ; set this mummy work area offset - avoid constant switching
                            
                            lda #$ff                        ; get initial value
                            sta CC_WA_Sprite_Mummy_SwDataOff,x ; init this mummy trap door switch work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set mummy data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkMummy_DataPtr_Lo      ; 
                            adc CC_WA_Sprite_Mummy_DataOff,x; add this mummy castle data offset
                            sta CCZ_MummyDataPtr_Lo         ; 
                            
                            lda TabWrkMummy_DataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_MummyDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if mummy has already left its tomb
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Mummy_Mode,x   ; get this mummy mode
                            bne TestPlayerNumberToChase     ; check: left the tomb - yes: select player to chase
; --------------------------------------------------------------------------------------------------------------------- ;
; step mummy out of its tomb
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CC_WA_Sprite_Mummy_BirthStep,x ; inc offset table mummy birth steps
                            
                            ldy CC_WA_Sprite_Mummy_BirthStep,x ; get offset table mummy birth steps
                            lda TabMummy_BirthStep_SprtNum,y; get next mummy birth step table entry
                            cmp #$ff                        ; test flag end of sprite number data
                            beq SetFlagMummyOut             ; check: end of birth step table - yes: mummy has fully left its tomb
                            
                            sta CC_WA_Sprite_Num,x          ; set new birth step sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; set next mummy birth step position
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            adc TabMummy_BirthStep_PosX,y   ; 
                            sta CC_WA_Sprite_PosX,x         ; 
                            
                            clc                             ; 
                            lda CC_WA_Sprite_PosY,x         ; 
                            adc TabMummy_BirthStep_PosY,y   ; 
                            sta CC_WA_Sprite_PosY,x         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set next mummy birth step sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Mummy_BirthStep,x ; get mummy birth step count
                            asl a                           ; *2
                            asl a                           ; *4
                            adc #$24                        ; 
                            sta TabSFX_MummyOut_Tone        ; 
                            
                            lda #NumSfx_MummyOut            ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
                            
                            jmp GetMummySpriteData_Move     ; get next mummy birth step sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
; mummy has left its tomb
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagMummyOut             lda #CC_WA_Sprite_Mummy_Mode_Out; 
                            sta CC_WA_Sprite_Mummy_Mode,x   ; set flag mummy is alive
; --------------------------------------------------------------------------------------------------------------------- ;
; init first mummy position outside the tomb
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldy #CC_Mummy_Tomb_PosX         ; get offset tomb PosX
                            lda (CCZ_MummyDataPtr),y        ; get tomb PosX from castle data
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta CC_WA_Sprite_PosX,x         ; set new sprite PosX
                            
                            clc                             ; 
                            ldy #CC_Mummy_Tomb_PosY         ; get offset tomb PosY
                            lda (CCZ_MummyDataPtr),y        ; get tomb PosY from castle data
                            adc #$07                        ; add room draw grid heigth - step one room grid position right
                            sta CC_WA_Sprite_PosY,x         ; set new sprite PosY
                            
                            lda #$02                        ; 
                            sta CC_WA_Sprite_SeqNum,x       ; sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
; decide which player the mummy has to follow - player #1 is preferred if he is still alive
; --------------------------------------------------------------------------------------------------------------------- ;
TestPlayerNumberToChase     lda CC_GameDataVar_Flag_P1      ; 
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            beq ChasePlayer_1               ; check: player #1 has arrived - yes: choose him 1st
                            
                            lda CC_GameDataVar_Flag_P2      ; 
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            beq ChasePlayer_2               ; check: player #2 has arrived - yes: choose him 2nd
                            
                            jmp MummySpriteMoveX            ; no player available anymore - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; select the appropriate player number
; --------------------------------------------------------------------------------------------------------------------- ;
ChasePlayer_1               ldy #$00                        ; get offset player #1
                            jmp GetPlayer_WA_Off            ; 
                            
ChasePlayer_2               ldy #$01                        ; get offset player #2
                            
GetPlayer_WA_Off            lda TabWrkPlayer_Sprite_WA,y    ; get the selected player work area offset
                            tay                             ; set as offset
                            
                            jsr GameSpriteMoveCtrlPtrSet    ; prepare and set sprite move control memory pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; test if mummy has reached the selected players PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get mummy sprite PosX
                            sbc CC_WA_Sprite_PosX,y         ; sub selected player sprite PosX
                            bcs TestMummyAtPlayerPosX       ; check: underflow - no
                            
                            eor #$ff                        ; make positive
                            adc #$01                        ; set ones complement
                            
TestMummyAtPlayerPosX       cmp #$02                        ; test player width
                            bcc MummySpriteMoveX            ; check: LT - no: not reached - nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; move mummy towards the selected player PosX - player #1 is preferred if he is still alive
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CC_WA_Sprite_Num,x          ; 
                            
                            lda CC_WA_Sprite_PosX,x         ; get mummy sprite PosX
                            cmp CC_WA_Sprite_PosX,y         ; test selected player sprite PosX
                            bcs MummyMove_Le                ; check: GE - yes: player is left of mummy
; --------------------------------------------------------------------------------------------------------------------- ;
; move mummy right towards player
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; get mummy move control value
                            and #CC_MoveCtrl_Right          ; isolate move right
                            beq MummySpriteMoveX            ; check: right - no: at end of a floor - immobile
                            
                            inc CC_WA_Sprite_PosX,x         ; step mummy right
                            
                            lda CC_WA_Sprite_Num,x          ; get actual mummy sprite number
                            cmp #SpriteNum_MummyMoveRi_Min  ; test min move number right
                            bcc SetMummySprtNumMin_Ri       ; check: LT - yes: init sprite number
                            
                            cmp #SpriteNum_MummyMoveRi_Max + $01 ; test max move number right
                            bcc SetMummyPosX                ; check: LT - no
                            
SetMummySprtNumMin_Ri       lda #SpriteNum_MummyMoveRi_Min  ; 
                            sta CC_WA_Sprite_Num,x          ; set min sprite number mummy moves right
                            
                            jmp SetMummyPosX                ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; move mummy left towards player
; --------------------------------------------------------------------------------------------------------------------- ;
MummyMove_Le                ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; get mummy move control value
                            and #CC_MoveCtrl_Left           ; isolate move left
                            beq MummySpriteMoveX            ; check: left - no: at end of a floor - immobile
                            
                            dec CC_WA_Sprite_PosX,x         ; step mummy left
                            
                            lda CC_WA_Sprite_Num,x          ; get actual mummy sprite number
                            cmp #SpriteNum_MummyMoveLe_Min  ; test min move number left
                            bcc SetMummySprtNumMin_Le       ; check: LT - yes: init sprite number left
                            
                            cmp #SpriteNum_MummyMoveLe_Max + $01 ; test max move number left
                            bcc SetMummyPosX                ; check: LT - no
                            
SetMummySprtNumMin_Le       lda #SpriteNum_MummyMoveLe_Min  ; 
                            sta CC_WA_Sprite_Num,x          ; set min sprite number mummy moves left
; --------------------------------------------------------------------------------------------------------------------- ;
; set new mummy PosX in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
SetMummyPosX                ldy #CC_Mummy_Sprt_PosX         ; get offset mummy castle data PosX
                            lda CC_WA_Sprite_PosX,x         ; get actual mummy PosX
                            sta (CCZ_MummyDataPtr),y        ; set new mummy PosX in castle data
                            
                            ldy #CC_Mummy_Sprt_PosY         ; get offset mummy castle data PosY
                            lda CC_WA_Sprite_PosY,x         ; get actual mummy PosY
                            sta (CCZ_MummyDataPtr),y        ; set new mummy PosY in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
; get new mummy move step sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
GetMummySpriteData_Move     jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
                            
MummySpriteMoveX            jmp RoomSpriteHandler.RTS_RoomSpriteHandler ; back to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MummyTrapTouch            Does    : check if mummy is on open trap door or touched a trap door switch
;                           Expects : .X=offset mummy sprite work area
;                                   : .Y=offset work area trap door
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MummyTrapTouch             .block                           ; 
                            sty TabWrkMummy_Trap_WA_Off     ; save offset trap work area
; --------------------------------------------------------------------------------------------------------------------- ;
; check if work area is trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Type,y        ; get work area type
                            cmp #CC_WA_ItemDef_Type_TrapDoor; test trap door
                            bne TestMummyTrapSwitch         ; check: EQ - no: continue with trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
; check if mummy is on trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get mummy PosX
                            adc CC_WA_Sprite_Width,x        ; 
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; sub trap door PosX
                            cmp #$04                        ; test trap door width
                            bcs TestMummyTrapSwitch         ; check: GE - yes: not on trap door - continue with switch
; --------------------------------------------------------------------------------------------------------------------- ;
; set trap door castle data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkTrap_CastleDataPtr_Lo ; 
                            adc CC_WA_Item_Trap_DataOff,y   ; 
                            sta CCZ_TrapDataPtr_Lo          ; 
                            
                            lda TabWrkTrap_CastleDataPtr_Hi ; 
                            adc #$00                        ; add carry
                            sta CCZ_TrapDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check trap door mode in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TrapDoor_Mode           ; get offset trap door mode
                            lda (CCZ_TrapDataPtr),y         ; get trap door mode
                            bit TabFlagTrapDoor_Open        ; test flag trap door open
                            beq TestMummyTrapSwitch         ; check: open - no: closed - continue with switch
; --------------------------------------------------------------------------------------------------------------------- ;
; set castle data pointer for this mummy
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkMummy_DataPtr_Lo      ; 
                            adc CC_WA_Sprite_Mummy_DataOff,x; add this mummy castle data offset
                            sta CCZ_TrapDataPtr_Lo          ; 
                            
                            lda TabWrkMummy_DataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_TrapDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark mummy as gone if trap door was open
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Mummy_Status            ; get offset mummy status
                            lda #CC_Mummy_Status_Gone       ; get flag mummy gone
                            sta (CCZ_TrapDataPtr),y         ; mark mummy gone in castle data
                            
                            jmp MummyTrapTouchX             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test if mummy touches a trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
TestMummyTrapSwitch         ldy TabWrkMummy_Trap_WA_Off     ; restore offset trap work area
                            
                            lda #TabWrkSprt_Flag_Hit_No     ; 
                            sta TabWrkSprt_Flag_Hit         ; set flag this sprite is still not hurt by a collision
; --------------------------------------------------------------------------------------------------------------------- ;
; check if work area is trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Type,y        ; get work area type
                            cmp #CC_WA_ItemDef_Type_TrapCtrl; test trap door switch
                            bne MummyTrapTouchX             ; check: EQ - no: noting to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; was trap door switch - check if mummy touches it
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            adc CC_WA_Sprite_Width,x        ; 
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; 
                            cmp #$04                        ; test trap switch width
                            bcs MummyTrapTouchX             ; check: GE - yes: not on trap switch - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; save trap castle data offset if this mummy touched a trap switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Trap_DataOff,y   ; get offset this trap door in castle data
                            sta CC_WA_Sprite_Mummy_SwDataOff,x ; set in this mummy sprite work area
                            
MummyTrapTouchX             jmp RoomPlayerMoveHandler.RTS_RoomPlayerMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MummySpriteCollide        Does    : Mummy collides with another sprite
;                           Expects : .Y=offset sprite work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MummySpriteCollide         .block                           ; 
                            lda CC_WA_Sprite_Type,y         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            beq SetFlagMummyIsAlive         ; check: Player - yes
                            
                            cmp #CC_WA_Sprite_Type_Frank    ; test frankenstein
                            bne MarkMummyGone               ; check: EQ - no: does not survive a spark of gun beam
; --------------------------------------------------------------------------------------------------------------------- ;
; mummy survives a contact with a player or a frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagMummyIsAlive         lda #TabWrkSprt_Flag_Dead_No    ; 
                            sta TabWrkSprt_Flag_Dead        ; set flag mummy is still alive
                            
                            jmp MummySpriteCollideX         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; this mummy had an accident - set this mummy castle data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
MarkMummyGone               clc                             ; 
                            lda TabWrkMummy_DataPtr_Lo      ; 
                            adc CC_WA_Sprite_Mummy_DataOff,x; add this mummy castle data offset
                            sta CCZ_MummyDataPtr_Lo         ; 
                            
                            lda TabWrkMummy_DataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_MummyDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; flag mummy as gone in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Mummy_Status            ; get offset mummy status in castle data
                            lda #CC_Mummy_Status_Gone       ; mark mummy as a goner
                            sta (CCZ_MummyDataPtr),y        ; get new mummy status in castle data
                            
MummySpriteCollideX         jmp RoomSpriteKillHandler.RTS_RoomSprtSprtCollHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MummySprite_WA_Handler    Does    : init or read mummy sprite position from mummy sprite work area
;                           Expects : .A=flag $ff - get actual mummy sprite position from work area
;                                   :         $00 - init mummy sprite work area
;                                   : .X=offset mummy work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MummySprite_WA_Handler     .block                           ; 
                            pha                             ; 
                            sta TabFlagMummy_WA             ; save mummy work area action flag
                            tya                             ; 
                            pha                             ; 
                            txa                             ; .A = offset mummy work area
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; set offset mummy work area
                            
                            jsr SpriteGetFree_WA_Block      ; find and initialize the next free sprite work area block
; --------------------------------------------------------------------------------------------------------------------- ;
; mark new sprite work area as mummy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Sprite_Type_Mummy    ; get initial value
                            sta CC_WA_Sprite_Type,x         ; init work area type mummy
                            
                            lda #$ff                        ; get initial value
                            sta CC_WA_Sprite_Mummy_WA_Off,x ; init this mummy sprite work area offset 
                            sta CC_WA_Sprite_Mummy_SwDataOff,x ; init this mummy trap castle data offset
                            
                            lda CC_WA_Item_Mummy_DataOff,y  ; get mummy data offset from mummy work area
                            sta CC_WA_Sprite_Mummy_DataOff,x; ini this mummy castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set mummy data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc TabWrkMummy_DataPtr_Lo      ; 
                            sta CCZ_MummyDataPtr_Lo         ; 
                            
                            lda TabWrkMummy_DataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_MummyDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set mummy sprite dimensions
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$05                        ; 
                            sta CC_WA_Sprite_Width,x        ; 
                            
                            lda #$11                        ; 
                            sta CC_WA_Sprite_Height,x       ; 
                            
                            lda #$ff                        ; 
                            sta CC_WA_Sprite_Num,x          ; init sprite mummy number
; --------------------------------------------------------------------------------------------------------------------- ;
; check flag for the desired action
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabFlagMummy_WA             ; get mummy work area action flag
                            bne GetMummyPosition            ; check: read - yes: get mummy position from castle data
; --------------------------------------------------------------------------------------------------------------------- ;
; init mummy sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Sprite_Mummy_Mode_In ; 
                            sta CC_WA_Sprite_Mummy_Mode,x   ; 
                            
                            lda #$ff                        ; get initial value
                            sta CC_WA_Sprite_Mummy_BirthStep,x ; 
                            
                            lda #$04                        ; 
                            sta CC_WA_Sprite_SeqNum,x       ; sprite sequence number
                            
                            ldy #CC_Mummy_Tomb_PosX         ; get offset tomb PosX
                            clc                             ; 
                            lda (CCZ_MummyDataPtr),y        ; get tomb PosX
                            adc #$04 * $03 + $01            ; add room triple draw grid width plus a bit
                            sta CC_WA_Sprite_PosX,x         ; set mummy sprite PosX
                            
                            clc                             ; 
                            ldy #CC_Mummy_Tomb_PosY         ; get offset tomb PosY
                            lda (CCZ_MummyDataPtr),y        ; get tomb PosY
                            adc #$08                        ; add room draw grid height
                            sta CC_WA_Sprite_PosY,x         ; set mummy sprite PosY
                            
                            jmp MummySprite_WA_HandlerX     ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get actual mummy sprite position
; --------------------------------------------------------------------------------------------------------------------- ;
GetMummyPosition            lda #CC_WA_Sprite_Mummy_Mode_Out; 
                            sta CC_WA_Sprite_Mummy_Mode,x   ; 
                            
                            ldy #CC_Mummy_Sprt_PosX         ; get offset mummy sprite PosX
                            lda (CCZ_MummyDataPtr),y        ; get mummy sprite PosX
                            sta CC_WA_Sprite_PosX,x         ; set actual mummy sprite PosX
                            
                            ldy #CC_Mummy_Sprt_PosY         ; get offset mummy sprite PosY
                            lda (CCZ_MummyDataPtr),y        ; get mummy sprite PosY
                            sta CC_WA_Sprite_PosY,x         ; set actual mummy sprite PosY
                            
                            lda #$02                        ; 
                            sta CC_WA_Sprite_SeqNum,x       ; sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
MummySprite_WA_HandlerX     pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagMummy_WA             .byte $b3 ; 
TabFlagMummy_WA_Init            = $00 ; init mummy sprite work area
TabFlagMummy_WA_Read            = $ff ; get actual mummy sprite postion from mummy data
; --------------------------------------------------------------------------------------------------------------------- ;
TabMummy_BirthStep_SprtNum  = *      ; 
                            .byte SpriteNum_MummyOut_01 ; 
                            .byte SpriteNum_MummyOut_02 ; 
                            .byte SpriteNum_MummyOut_03 ; 
                            .byte SpriteNum_MummyOut_04 ; 
                            .byte SpriteNum_MummyOut_05 ; 
                            .byte SpriteNum_MummyOut_06 ; 
                            .byte SpriteNum_MummyOut_06 ; 
                            
                            .byte $ff ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabMummy_BirthStep_PosX      = *      ; 
                            .byte $00 ; 
                            .byte $fe ; 
                            .byte $fe ; 
                            .byte $fe ; 
                            .byte $fe ; 
                            .byte $fe ; 
                            .byte $fe ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabMummy_BirthStep_PosY      = *      ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $02 ; 
                            .byte $02 ; 
                            .byte $02 ; 
                            .byte $02 ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkMummy_Trap_WA_Off     .byte $ba ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RayGunBeamSpriteMove      Does    : move a laser beam left of right
;                           Expects : .X=offset beam sprite work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RayGunBeamSpriteMove       .block                           ; 
                            lda CC_WA_Sprite_Flag,x         ; 
                            bit TabFlagSprt_Moves           ; test flag sprite to be moved in RoomSpriteHandler
                            beq MoveBeam                    ; check: move - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; flag this ray gun beam as inactive
; --------------------------------------------------------------------------------------------------------------------- ;
                            eor TabFlagSprt_Moves           ; flip flag sprite to be moved in RoomSpriteHandler
                            
                            ora TabFlagSprt_Disable         ; insert flag sprite to be disabled in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; set flag sprite to be disabled
; --------------------------------------------------------------------------------------------------------------------- ;
; get castle data pointer for this ray gun beam
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Gun_DataOff,x  ; 
                            clc                             ; 
                            adc TabWrkGun_DataPtr_Lo        ; 
                            sta CCZ_RayGunDataPtr_Lo        ; 
                            
                            lda TabWrkGun_DataPtr_Hi        ; 
                            adc #$00                        ; add carry
                            sta CCZ_RayGunDataPtr_Hi        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; flag this ray gun beam as inactive in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Gun_Laser               ; 
                            lda #$ff                        ; init all flags
                            eor TabFlagGun_Fires            ; flip flag active shot
                            and (CCZ_RayGunDataPtr),y       ; clear all but existing flags 
                            sta (CCZ_RayGunDataPtr),y       ; set new flags in castle data
                            
                            jmp RayGunBeamSpriteMoveX       ; all done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; try to move this ray gun beam
; --------------------------------------------------------------------------------------------------------------------- ;
MoveBeam                    bit TabFlagSprt_WA_Init         ; test flag sprite work area initialized
                            beq StepBeam_Le_Ri              ; check: init - no: bypass flip init flag
                            
                            eor TabFlagSprt_WA_Init         ; flip flag sprite work area initialized
                            sta CC_WA_Sprite_Flag,x         ; mark sprite work area as used
                            
StepBeam_Le_Ri              clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            adc CC_WA_Sprite_Beam_ShootStep,x ; add actual laser beam shoot step
                            sta CC_WA_Sprite_PosX,x         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; ckeck if laser beam PosX is in display screen range
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$b0                        ; test with max PosX right
                            bcs SetFlagBeamMoving           ; check: GE - yes: beam has not passed the right boundary
                            
                            cmp #$08                        ; test with min PosX
                            bcs RayGunBeamSpriteMoveX       ; check: GE - yes: beam has not passed the left boundary
; --------------------------------------------------------------------------------------------------------------------- ;
; beam sprite in in screen range - mark him as moving
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagBeamMoving           lda CC_WA_Sprite_Flag,x         ; 
                            ora TabFlagSprt_Moves           ; insert flag sprite to be moved in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; 
                            
RayGunBeamSpriteMoveX       jmp RoomSpriteHandler.RTS_RoomSpriteHandler ; back to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RayGunBeamItemCollide     Does    : ray gun beam collides with a room item
;                           Expects : .X=offset beam sprite work area
;                                   : .Y=offset collision item work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RayGunBeamItemCollide      .block                           ; 
                            lda CC_WA_ItemDef_Type,y        ; get collision item work area type
                            cmp #CC_WA_ItemDef_Type_LightOrb; test collided with light orb
                            beq RayGunBeamItemCollideX      ; check: EQ - yes: beam will be deacivated on return
                            
                            cmp #CC_WA_ItemDef_Type_Frank   ; test collided with frankenstein
                            beq RayGunBeamItemCollideX      ; check: EQ - yes: beam will be deacivated on return
                            
                            cmp #CC_WA_ItemDef_Type_Gun     ; test collided with light gun
                            bne FlagBeamActive              ; check: EQ - no: all other - flag beam as activate on return
; --------------------------------------------------------------------------------------------------------------------- ;
; test if beam hits his own laser head
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Gun_DataOff,x  ; test offset this ray gun in castle data
                            cmp CC_WA_Item_Gun_DataOff,y    ; test with offset colliding ray gun in castle data
                            bne RayGunBeamItemCollideX      ; check: EQ - no: beam will be deacivated on return
; --------------------------------------------------------------------------------------------------------------------- ;
; keep this beam active on return
; --------------------------------------------------------------------------------------------------------------------- ;
FlagBeamActive              lda #TabWrkSprt_Flag_Hit_No     ; 
                            sta TabWrkSprt_Flag_Hit         ; set flag this sprite is still not hurt by a collision
                            
RayGunBeamItemCollideX      jmp RoomPlayerMoveHandler.RTS_RoomPlayerMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RayGunBeamFire            Does    : fire a ray gun laser beam
;                           Expects : .A=actual laser head action flag
;                                   : .X=offset ray gun work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RayGunBeamFire             .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init shoot sound effect according to laser head action
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; get actual laser head action flags
                            
                            clc                             ; 
                            lda CC_WA_Item_Gun_DataOff,y    ; 
                            adc #$07                        ; 
                            and #$f8                        ; #####...
                            lsr a                           ; .#####..
                            adc #$2c                        ; 
                            sta TabSFX_GunShot_Tone         ; 
                            
                            lda #NumSfx_GunShot             ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
; get new work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr SpriteGetFree_WA_Block      ; find and initialize the next free sprite work area block
; --------------------------------------------------------------------------------------------------------------------- ;
; init this new work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Sprite_Type_Beam     ; get type ray gun beam
                            sta CC_WA_Sprite_Type,x         ; init work area type ray gun beam
                            
                            lda CC_WA_ItemDef_PosX,y        ; 
                            sta CC_WA_Sprite_PosX,x         ; 
                            
                            clc                             ; 
                            lda CC_WA_ItemDef_PosY,y        ; 
                            adc #$05                        ; 
                            sta CC_WA_Sprite_PosY,x         ; 
                            
                            lda #SpriteNum_GunBeam          ; 
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            lda CC_WA_Item_Gun_DataOff,y    ; 
                            sta CC_WA_Sprite_Gun_DataOff,x  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test laser head shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Gun_Laser               ; get offset laser status
                            lda (CCZ_RayGunDataPtr),y       ; get laser status
                            bit TabFlagGun_Laser_Dir        ; test shoot direction
                            beq SetGunLaserBeamDir_Ri       ; check: right - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; set move laser beam left
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            sbc #$08                        ; 
                            sta CC_WA_Sprite_PosX,x         ; 
                            
                            lda #+$00 - $04                 ; get shoot left ($fc = -4)
                            sta CC_WA_Sprite_Beam_ShootStep,x ; set laser beam shoot step left
                            jmp GetSpriteData               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set move laser beam right
; --------------------------------------------------------------------------------------------------------------------- ;
SetGunLaserBeamDir_Ri       clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            adc #$08                        ; 
                            sta CC_WA_Sprite_PosX,x         ; 
                            
                            lda #+$00 + $04                 ; get shoot right
                            sta CC_WA_Sprite_Beam_ShootStep,x ; set laser beam shoot step right
; --------------------------------------------------------------------------------------------------------------------- ;
; get the requested sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteData               jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; FrankSpriteMove           Does    : get frankenstein out of his coffin or let him follow the nearest player
;                           Expects : .X=offset frankenstein sprite work area
;                                   : .Y=offset frankenstein work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
FrankSpriteMove            .block                           ; 
                            lda CC_WA_Sprite_Flag,x         ; get frankenstein sprite flag
                            bit TabFlagSprt_Moves           ; test flag sprite to be moved in RoomSpriteHandler
                            beq FrankMove                   ; check: moves - yes
                            
                            eor TabFlagSprt_Moves           ; flip flag sprite to be moved in RoomSpriteHandler
                            
                            ora TabFlagSprt_Disable         ; insert flag sprite to be disabled in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,x         ; set flag sprite to be disabled
                            
                            jmp FrankSpriteMoveX            ; exit - nothing more to do
; --------------------------------------------------------------------------------------------------------------------- ;
; try to move this frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
FrankMove                   bit TabFlagSprt_WA_Init         ; test flag sprite work area initialized
                            beq SetFrankDataPtr             ; check: init - no: bypass set init flag
                            
                            eor TabFlagSprt_WA_Init         ; flip flag sprite work area initialized
                            sta CC_WA_Sprite_Flag,x         ; mark sprite work area as used
; --------------------------------------------------------------------------------------------------------------------- ;
; set frankenstein data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
SetFrankDataPtr             clc                             ; 
                            lda TabWrkFrank_CastleDataPtr_Lo; 
                            adc CC_WA_Sprite_Frank_DataOff,x; 
                            sta CCZ_FrankDataPtr_Lo         ; 
                            
                            lda TabWrkFrank_CastleDataPtr_Hi; 
                            adc #$00                        ; add carry
                            sta CCZ_FrankDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check frankenstein coffin
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Frank_Mode,x   ; get this frankenstein mode
                            bit TabFlagFrank_Coffin_Empty   ; test flag frankenstein still in coffin
                            bne CheckFrankTrapSwitchStatus  ; check: empty - yes: test trap switch
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game is in demo mode - frankenstein does not move then
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            cmp #TabFlagDataBufAdr_Load     ; test flag castle data game memory
                            bne IniPlayerNumCoffin          ; check: game data available - yes
                            
                            jmp FrankSpriteMoveX            ; frankenstein does not move in demo mode
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a player has reached the coffin row
; --------------------------------------------------------------------------------------------------------------------- ;
IniPlayerNumCoffin          lda #$01                        ; start with player #2
                            sta TabWrkFrank_Player_Num      ; init actual player number
                            
GetNextPlayerNumCoffin      ldy TabWrkFrank_Player_Num      ; get actual player number
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne SetNextPlayerNumCoffin      ; check: arrived - no: try next player
                            
                            lda TabWrkPlayer_Sprite_WA,y    ; get offset this player sprite work area
                            tay                             ; set as sprite work area offset
                            
                            sec                             ; 
                            lda CC_WA_Sprite_PosY,x         ; get this frankenstein PosY
                            sbc CC_WA_Sprite_PosY,y         ; sub this player PosY
                            cmp #$04                        ; test frankenstein row range
                            bcs SetNextPlayerNumCoffin      ; check: GE - yes: not in range - try next player
; --------------------------------------------------------------------------------------------------------------------- ;
; player is on frankenstein coffin row - test his coffin side
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get this frankenstein PosX
                            sbc CC_WA_Sprite_PosX,y         ; sub this player PosY
                            bcc CheckCoffinOpen_Ri          ; check: on right side of coffin - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; player is on left side of coffin
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Frank_Mode,x   ; get this frankenstein mode
                            bit TabFlagFrank_CoffinDir      ; test coffin dir right
                            beq SetNextPlayerNumCoffin      ; check: right - yes: behind coffin - try next player
                            
                            jmp SetFlagCoffinEmpty          ; player passed the coffin open side - get frankenstein out
; --------------------------------------------------------------------------------------------------------------------- ;
; player is on right side of coffin
; --------------------------------------------------------------------------------------------------------------------- ;
CheckCoffinOpen_Ri          lda CC_WA_Sprite_Frank_Mode,x   ; get this frankenstein mode
                            bit TabFlagFrank_CoffinDir      ; test coffin dir right
                            beq SetFlagCoffinEmpty          ; check: right - yes: in front of coffin
; --------------------------------------------------------------------------------------------------------------------- ;
; player on wrong side of coffin - try next player
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextPlayerNumCoffin      dec TabWrkFrank_Player_Num      ; dec actual player number - set player #1
                            bpl GetNextPlayerNumCoffin      ; check: min - no: continue with next player
                            
                            jmp FrankSpriteMoveX            ; no player passed a coffin on the correct side - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; a player passed the coffins open side - get frankenstein out
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagCoffinEmpty          ora TabFlagFrank_Coffin_Empty   ; insert flag empty coffin
                            sta CC_WA_Sprite_Frank_Mode,x   ; set new sprite mode flag
                            
                            ldy #CC_Frank_Coffin            ; get offset frankenstein coffin flag
                            sta (CCZ_FrankDataPtr),y        ; set new coffin flag in castle data
                            
                            lda #$80                        ; get initial value
                            sta CC_WA_Sprite_Frank_CtrlTabOff,x ; reset control bit table offset
                            
                            lda #NumSfx_FrankOut            ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
; check if frankenstein has touched a trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
CheckFrankTrapSwitchStatus  lda CC_WA_Sprite_Frank_SwDataOff,x ; get this frank trap door switch work area offset
                            cmp #$ff                        ; test initial value
                            beq SetFrankStatus              ; check: EQ - yes: still init value - trap switch not touched
; --------------------------------------------------------------------------------------------------------------------- ;
; switch a trap switch only if frankenstein has left the switch inbetween - avoid constant switching
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp CC_WA_Sprite_TrapSw_DataOff,x ; test with trap castle data offset
                            beq SetFrankStatus              ; check: still same - yes: avoid constant switching
                            
                            jsr RoomItemTrapDoorHandler     ; flip the trap door mode - paint the trap door switch - mark move control data
                            
SetFrankStatus              sta CC_WA_Sprite_TrapSw_DataOff,x ; set trap castle data offset - make same to avoid constant switching
                            
                            lda #$ff                        ; get initial value
                            sta CC_WA_Sprite_Frank_SwDataOff,x ; init this frank trap door switch work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get pointer to move contol data memory
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameSpriteMoveCtrlPtrSet    ; prepare and set sprite move control memory pointer
                            
                            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; get a move control value
                            and CC_WA_Sprite_Frank_CtrlVal,x; isolate this frankenstein move ctrl value bits
                            sta TabWrkFrank_MoveCtrl_Val    ; save actual move ctrl value bits
                            
                            lda #$ff                        ; get initial value
                            sta CC_WA_Sprite_Frank_CtrlVal,x; ini this frankenstein move ctrl value bits
                            
                            lda TabWrkFrank_MoveCtrl_Val    ; get actual move ctrl value bits
                            bne IniCtrlBitTabOff            ; check: empty - no: search appropriate value
                            
                            lda #$80                        ; get initial value
                            sta CC_WA_Sprite_Frank_CtrlTabOff,x ; reset control bit table offset
                            
                            jmp CheckMoveCtrlFloorStart     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init the move control entry search
; --------------------------------------------------------------------------------------------------------------------- ;
IniCtrlBitTabOff            ldy #TabSpriteMove_Le           ; init move direction bit table offset to max - move left
                            
                            lda #$00                        ; get number player #1
                            sta TabWrkFrank_Player_Num      ; init actual player number
; --------------------------------------------------------------------------------------------------------------------- ;
; search the move control values for FloorEnd / LadderTop / FloorStart / Ladder
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextCtrlBitTabVal        lda TabSpriteMove,y             ; get sprite move direction bit table value for this frankenstein
                            bit TabWrkFrank_MoveCtrl_Val    ; test FloorEnd / LadderTop / FloorStart / Ladder
                            beq SetNextBitTabOff            ; check: found - no: set next move control test flag offset
; --------------------------------------------------------------------------------------------------------------------- ;
; a frankenstein move control value found for this player - continue with next player
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkFrank_Player_Num      ; inc actual player number - set player #2
                            
                            sty TabWrkFrank_MoveCtrlTab_Off ; save control bit table offset
                            
SetNextBitTabOff            dey                             ; set next control bit table offset
                            dey                             ; 
                            bpl GetNextCtrlBitTabVal        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set this frankenstein move control table offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkFrank_Player_Num      ; get actual player number
                            cmp #$01                        ; test player #2
                            bne CheckMaxPlayerNum           ; check: EQ - no
                            
                            lda TabWrkFrank_MoveCtrlTab_Off ; get move control bit table offset found
                            sta CC_WA_Sprite_Frank_CtrlTabOff,x ; set this frankenstein move control bit table offset
                            
                            jmp CheckMoveCtrlFloorStart     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; frankenstein only changes his move direction in case of a FloorEnd / FloorStart / Ladder - try to find one
; --------------------------------------------------------------------------------------------------------------------- ;
CheckMaxPlayerNum           cmp #$02                        ; test max player number
                            bne IniTabEntry                 ; check: EQ - no
                            
                            lda TabWrkFrank_MoveCtrlTab_Off ; get control bit table offset
                            sec                             ; 
                            sbc #TabSpriteMove_Do           ; sub move direction bit table offset for move down
                            and #TabSpriteMove_Len          ; limit to move direction bit table max
                            tay                             ; set as offset
                            
                            lda TabSpriteMove,y             ; get move direction bit table value for this frankenstein
                            bit TabWrkFrank_MoveCtrl_Val    ; test FloorEnd / LadderTop / FloorStart / Ladder
                            beq IniTabEntry                 ; 
                            
                            ldy CC_WA_Sprite_Frank_CtrlTabOff,x ; get this frankenstein move control bit table offset
                            bmi IniTabEntry                 ; check: init value - yes: 
                            
                            lda TabSpriteMove,y             ; get move direction bit table value for this frankenstein
                            bit TabWrkFrank_MoveCtrl_Val    ; test FloorEnd / LadderTop / FloorStart / Ladder
                            beq IniTabEntry                 ; 
                            
                            jmp CheckMoveCtrlFloorStart     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize the search distance table - a frankenstein follows the nearest player
; --------------------------------------------------------------------------------------------------------------------- ;
IniTabEntry                 lda #$ff                        ; get initial value
                            ldy #TabWrkFrank_Dist_Max_Len   ; get max distance table length
IniNextTabEntry             sta TabWrkFrank_Dist_Max,y      ; 
                            
                            dey                             ; dec offset
                            bpl IniNextTabEntry             ; check: 
; --------------------------------------------------------------------------------------------------------------------- ;
; find the max distance between the two playeres and this frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get player number #2
                            sta TabWrkFrank_Player_Num      ; init actual player number
; --------------------------------------------------------------------------------------------------------------------- ;
FindNextPlayerMaxDist       ldy TabWrkFrank_Player_Num      ; get actual player number
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne SetNextPlayerNum            ; check: player i room - no: try next player
                            
                            lda TabWrkPlayer_Sprite_WA,y    ; get offset this player sprite work area
                            tay                             ; set offset this player sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; test if player is left or right of frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CC_WA_Sprite_PosX,y         ; get this player sprite PosX
                            sbc CC_WA_Sprite_PosX,x         ; sub this frankenstein sprite PosX
                            bcs GetTabOff_Le                ; check: positive - yes: frankenstein is left of player
                            
                            eor #$ff                        ; negative - build ones complement - make positive
                            adc #$01                        ; 
                            
                            ldy #TabWrkFrank_Off_Max_Ri     ; get table offset right
                            jmp CheckTabVal_Le_Ri           ; 
                            
GetTabOff_Le                ldy #TabWrkFrank_Off_Max_Le     ; get table offset left
                            
CheckTabVal_Le_Ri           cmp TabWrkFrank_Dist_Max,y      ; test with old max distance
                            bcs CheckPlayer_Up_Do           ; check: GE - yes: old distance still greater
                            
                            sta TabWrkFrank_Dist_Max,y      ; set new max distance left/right for this player
; --------------------------------------------------------------------------------------------------------------------- ;
; test if player is above or below of frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
CheckPlayer_Up_Do           ldy TabWrkFrank_Player_Num      ; get actual player number
                            lda TabWrkPlayer_Sprite_WA,y    ; get offset this player sprite work area
                            tay                             ; set offset this player sprite work area
                            
                            sec                             ; 
                            lda CC_WA_Sprite_PosY,y         ; get this player sprite PosX
                            sbc CC_WA_Sprite_PosY,x         ; sub this frankenstein sprite PosX
                            bcs GetTabOff_Up                ; check: positive - yes: - frankenstein is above player
                            
                            eor #$ff                        ; negative - build ones complement - make positive
                            adc #$01                        ; 
                            
                            ldy #TabWrkFrank_Off_Max_Do     ; get table offset below
                            jmp CheckTabVal_Up_Do           ; 
                            
GetTabOff_Up                ldy #TabWrkFrank_Off_Max_Up     ; get table offset above
                            
CheckTabVal_Up_Do           cmp TabWrkFrank_Dist_Max,y      ; test with old max distance
                            bcs SetNextPlayerNum            ; check: GE - yes: old distance still greater
                            
                            sta TabWrkFrank_Dist_Max,y      ; set new max distance above/below for this player
                            
SetNextPlayerNum            dec TabWrkFrank_Player_Num      ; dec actual player number - set player #1
                            bpl FindNextPlayerMaxDist       ; check: min - no: continue with next player
; --------------------------------------------------------------------------------------------------------------------- ;
; init max distance search result value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; 
                            sta TabWrkFrank_Dist_Found      ; init max distance value result
; --------------------------------------------------------------------------------------------------------------------- ;
; init actual distance search result values
; --------------------------------------------------------------------------------------------------------------------- ;
IniNextMaxDistWrkVal        lda #$00                        ; 
                            sta TabWrkFrank_Dist_Work       ; init actual distance found
                            
                            lda #$ff                        ; 
                            sta TabWrkFrank_Dist_Work_Flag  ; init max distance value found table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; look for the next maximun distance entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabWrkFrank_Dist_Max_Len   ; get max distance table length
GetNextMaxDistTabVal        lda TabWrkFrank_Dist_Max,y      ; get next max table distance
                            cmp TabWrkFrank_Dist_Found      ; test with max distance value result
                            bcs DecMaxDistTabOff            ; check: GE - yes: no new max found
                            
                            cmp TabWrkFrank_Dist_Work       ; test with actual distance found
                            bcc DecMaxDistTabOff            ; check: LT - yes: no new max found
                            
                            sta TabWrkFrank_Dist_Work       ; set actual max distance value found
                            sty TabWrkFrank_Dist_Work_Flag  ; flag actual max distance value found
                            
DecMaxDistTabOff            dey                             ; 
                            bpl GetNextMaxDistTabVal        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; check if lookup was successful
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkFrank_Dist_Work_Flag  ; get flag max distance value found
                            cmp #$ff                        ; test still initial value
                            bne CheckMoveCtrlEntry          ; check: NE - yes: lookup was successful
; --------------------------------------------------------------------------------------------------------------------- ;
; nothing of interest found
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$80                        ; get initial value
                            sta CC_WA_Sprite_Frank_CtrlTabOff,x ; init this frankenstein move control bit table offset
                            
                            jmp CheckMoveCtrlFloorStart     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; to change his move direction a frankenstein only cares for FloorStart / FloorEnd / Ladder
; --------------------------------------------------------------------------------------------------------------------- ;
CheckMoveCtrlEntry          asl a                           ; *2 - each move control entry is two byte long
                            tay                             ; 
                            
                            lda TabSpriteMove,y             ; get move direction bit table value for this frankenstein
                            bit TabWrkFrank_MoveCtrl_Val    ; test FloorEnd / LadderTop / FloorStart / Ladder
                            bne SetMoveCtrlOff              ; check: found - yes: lookup was successful
                            
                            lda TabWrkFrank_Dist_Work       ; get actual max distance value found
                            sta TabWrkFrank_Dist_Found      ; set new max distance value result
                            
                            jmp IniNextMaxDistWrkVal        ; coninue search with new max distance
; --------------------------------------------------------------------------------------------------------------------- ;
; save the move control entry offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetMoveCtrlOff              tya                             ; 
                            sta CC_WA_Sprite_Frank_CtrlTabOff,x ; set this frankenstein move control bit table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; check move control floor start
; --------------------------------------------------------------------------------------------------------------------- ;
CheckMoveCtrlFloorStart     lda CC_WA_Sprite_Frank_CtrlTabOff,x ; get this frankenstein move control bit table offset
                            and #TabSpriteMove_Ri           ; isolate move move direction bit table bit for move right
                            beq CheckMoveFrank_Exit         ; check: FloorStart - no
; --------------------------------------------------------------------------------------------------------------------- ;
; this frankenstein is on floor start
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CC_WA_Sprite_PosY,x         ; 
                            sbc TabWrkDrawGrid_PosY_Off     ; sub sprite max y-offset in draw grid ($00-$07)
                            sta CC_WA_Sprite_PosY,x         ; 
                            
                            inc CC_WA_Sprite_Num,x          ; 
                            
                            lda CC_WA_Sprite_Frank_CtrlTabOff,x ; get this frankenstein move control table offset
                            cmp #TabSpriteMove_Ri           ; test move move direction bit table bit for move right
                            beq StepFrank_Ri                ; check: FloorStart - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; step this frankenstein left and set next sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CC_WA_Sprite_PosX,x         ; 
                            
                            lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_FrankMove_Le_Min ; test min left
                            bcc GetFrankSprtNum_Le_Min      ; check: LT - yes
                            
                            cmp #SpriteNum_FrankMove_Le_Max + $01 ; test max left
                            bcc GetFrankSprtData            ; check: LT - yes
                            
GetFrankSprtNum_Le_Min      lda #SpriteNum_FrankMove_Le_Min ; 
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            jmp GetFrankSprtData            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; step this frankenstein right and set next sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
StepFrank_Ri                inc CC_WA_Sprite_PosX,x         ; 
                            
                            lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_FrankMove_Ri_Min ; test min right
                            bcc GetFrankSprtNum_Ri_Min      ; check: LT yes
                            
                            cmp #SpriteNum_FrankMove_Ri_Max + $01 ; test max right
                            bcc GetFrankSprtData            ; check: LT - yes
                            
GetFrankSprtNum_Ri_Min      lda #SpriteNum_FrankMove_Ri_Min ; test min right
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            jmp GetFrankSprtData            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if frankenstein is movable
; --------------------------------------------------------------------------------------------------------------------- ;
CheckMoveFrank_Exit         lda CC_WA_Sprite_Frank_CtrlTabOff,x ; 
                            bmi UpdateFrankCastleData       ; check: initial value - yes: update variable castle data - exit
                            
                            sec                             ; 
                            lda CC_WA_Sprite_PosX,x         ; 
                            sbc TabWrkDrawGrid_PosX_Off     ; sub sprite max x-offset in draw grid ($00-$03)
                            sta CC_WA_Sprite_PosX,x         ; 
                            
                            inc CC_WA_Sprite_PosX,x         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check move control ladder or pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; get move control value
                            and #CC_MoveCtrl_Up             ; isolate a possible move up
                            bne CheckLadderMoveDir          ; check: ladder - yes
                            
                            lda #SpriteNum_FrankSlidePole   ; 
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            clc                             ; 
                            lda CC_WA_Sprite_PosY,x         ; 
                            adc #$02                        ; 
                            sta CC_WA_Sprite_PosY,x         ; 
                            
                            jmp GetFrankSprtData            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; frankenstein climbs a ladder up or down
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLadderMoveDir          lda CC_WA_Sprite_Frank_CtrlTabOff,x ; 
                            bne MoveFrankLadder_Do          ; check: move down - yes
                            
                            sec                             ; let frankenstein climb a ladder upwards
                            lda CC_WA_Sprite_PosY,x         ; 
                            sbc #$02                        ; step up
                            sta CC_WA_Sprite_PosY,x         ; 
                            jmp CalcFrankLadderSpriteNum    ; 
                            
MoveFrankLadder_Do          clc                             ; let frankenstein climb a ladder downwards
                            lda CC_WA_Sprite_PosY,x         ; 
                            adc #$02                        ; step down
                            sta CC_WA_Sprite_PosY,x         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate frankenstein climb sprite number from his PosY
; --------------------------------------------------------------------------------------------------------------------- ;
CalcFrankLadderSpriteNum    lda CC_WA_Sprite_PosY,x         ; get this frankenstein PosY
                            and #$06                        ; .....##. - isolate PosY bits
                            lsr a                           ; ......## - SpriteNum_FrankClimb_01 ... SpriteNum_FrankClimb_04
                            
                            clc                             ; 
                            adc #SpriteNum_FrankClimb_Min   ; add minimum value to isolated number
                            sta CC_WA_Sprite_Num,x          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get frankenstein sprite data for the desired move
; --------------------------------------------------------------------------------------------------------------------- ;
GetFrankSprtData            jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
; --------------------------------------------------------------------------------------------------------------------- ;
; update this frankenstein castle data variable part and exit
; --------------------------------------------------------------------------------------------------------------------- ;
UpdateFrankCastleData       lda CC_WA_Sprite_Frank_CtrlTabOff,x ; 
                            ldy #CC_Frank_CtrlTabOff        ; 
                            sta (CCZ_FrankDataPtr),y        ; set move control table offset in castle data
                            
                            lda CC_WA_Sprite_PosX,x         ; 
                            ldy #CC_Frank_Sprite_PosX       ; 
                            sta (CCZ_FrankDataPtr),y        ; set frankenstein PosX in castle data
                            
                            lda CC_WA_Sprite_PosY,x         ; 
                            ldy #CC_Frank_Sprite_PosY       ; 
                            sta (CCZ_FrankDataPtr),y        ; set frankenstein PosY in castle data
                            
                            lda CC_WA_Sprite_Num,x          ; 
                            ldy #CC_Frank_Sprite_Num        ; 
                            sta (CCZ_FrankDataPtr),y        ; set frankenstein sprite number in castle data
                            
FrankSpriteMoveX            jmp RoomSpriteHandler.RTS_RoomSpriteHandler ; back to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; FrankTrapTouch            Does    : check if frank is on open trap door or touched a trap door switch
;                           Expects : .X=offset mummy sprite work area
;                                   : .Y=offset work area trap door
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
FrankTrapTouch             .block                           ; 
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get frank PosX
                            adc CC_WA_Sprite_Width,x        ; 
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; 
                            cmp #$04                        ; test trap switch width
                            bcc TestFrankTrapType           ; check: LT - yes: on trap door/swich - handle it
                            
SetFlagFrankNotOnItem       lda #TabWrkSprt_Flag_Hit_No     ; 
                            sta TabWrkSprt_Flag_Hit         ; set flag this sprite is still not hurt by a collision
                            
                            jmp FrankTrapTouchX             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; decide whether frank is on a trap door or touches a trap switch
; --------------------------------------------------------------------------------------------------------------------- ;
TestFrankTrapType           lda CC_WA_ItemDef_Type,y        ; get work area type
                            cmp #CC_WA_ItemDef_Type_TrapDoor; test trap door
                            beq FrankTrapDoor               ; check: EQ - yes: continue with trap door
; --------------------------------------------------------------------------------------------------------------------- ;
; frank possibly touched a trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkSprt_Flag_Hit_No     ; 
                            sta TabWrkSprt_Flag_Hit         ; set flag this sprite is still not hurt by a collision
                            
                            lda CC_WA_ItemDef_Type,y        ; get work area type
                            cmp #CC_WA_ItemDef_Type_TrapCtrl; test trap door switch
                            bne FrankTrapTouchX             ; check: EQ - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; save trap castle data offset if this frankenstein touched a trap switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Trap_DataOff,y   ; get offset this trap door in castle data
                            sta CC_WA_Sprite_Frank_SwDataOff,x ; set in this frankenstein trap switch data offset
                            
                            jmp FrankTrapTouchX             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer trap door castle data
; --------------------------------------------------------------------------------------------------------------------- ;
FrankTrapDoor               clc                             ; 
                            lda TabWrkTrap_CastleDataPtr_Lo ; 
                            adc CC_WA_Item_Trap_DataOff,y   ; offset this trap door in castle data
                            sta CCZ_TrapDataPtr_Lo          ; 
                            
                            lda TabWrkTrap_CastleDataPtr_Hi ; 
                            adc #$00                        ; add carry
                            sta CCZ_TrapDataPtr_Hi          ; 
                            
                            ldy #$00                        ; get offset trap door status
                            lda (CCZ_TrapDataPtr),y         ; get trap door status
                            bit TabFlagTrapDoor_Open        ; test flag trap door open
                            beq SetFlagFrankNotOnItem       ; check: EQ - yes: frank cannot pass an open trap door
; --------------------------------------------------------------------------------------------------------------------- ;
; frank is on an open trap door - mark him as dead in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkFrank_CastleDataPtr_Lo; 
                            adc CC_WA_Sprite_Frank_DataOff,x; offset this frankenstein in castle data
                            sta CCZ_TrapDataPtr_Lo          ; 
                            
                            lda TabWrkFrank_CastleDataPtr_Hi; 
                            adc #$00                        ; add carry
                            sta CCZ_TrapDataPtr_Hi          ; 
                            
                            ldy #CC_Frank_Coffin            ; get offset status frankenstein coffin
                            lda TabFlagFrank_Coffin_Empty   ; get flag coffin empty
                            eor #$ff                        ; flip all bits
                            and (CCZ_TrapDataPtr),y         ; insert this coffin status bits from castle data
                            
                            ora TabFlagFrank_Coffin_Dead    ; mark this frankenstein as dead
                            sta (CCZ_TrapDataPtr),y         ; set new coffin status in castle data
                            sta CC_WA_Sprite_Frank_Mode,x   ; mark this frankenstein sprite as dead
                            
FrankTrapTouchX             jmp RoomPlayerMoveHandler.RTS_RoomPlayerMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; FrankSpriteCollide        Does    : frankenstein collides with another sprite - gets killed by sparks and beams
;                           Expects : .X=offset frankenstein sprite work area
;                                   : .Y=offset touching sprite work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
FrankSpriteCollide         .block                           ; 
                            lda CC_WA_Sprite_Frank_Mode,x   ; get this frankenstein mode
                            bit TabFlagFrank_Coffin_Empty   ; test empty coffin
                            beq GoFrankSpriteCollide_Exit   ; check: still in - yes: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; only sparks and ray gun beams can kill a frankenstein - sort out the rest
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,y         ; get colliding sprite type
                            beq GoFrankSpriteCollide_Exit   ; check: player - yes: nothing to do - exit
                            
                            cmp #CC_WA_Sprite_Type_Force    ; test force field
                            beq GoFrankSpriteCollide_Exit   ; check: EQ - yes: nothing to do - exit
                            
                            cmp #CC_WA_Sprite_Type_Mummy    ; test mummy
                            beq GoFrankSpriteCollide_Exit   ; check: EQ - yes: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; a frankenstein-frankenstein collision gets special care
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #CC_WA_Sprite_Type_Frank    ; test frankenstein
                            beq FrankMeetsFrank             ; check: EQ - yes: invert move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; was spark or beam - mark this frankenstein as dead
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkFrank_CastleDataPtr_Lo; set this frankenstein castle data pointer
                            adc CC_WA_Sprite_Frank_DataOff,x; 
                            sta CCZ_FrankDataPtr_Lo         ; 
                            
                            lda TabWrkFrank_CastleDataPtr_Hi; 
                            adc #$00                        ; add carry
                            sta CCZ_FrankDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark this frankenstein as dead in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Frank_Coffin            ; get offset coffin in this frankenstein castle data
                            lda TabFlagFrank_Coffin_Empty   ; get initial value
                            eor #$ff                        ; flip all bits
                            and (CCZ_FrankDataPtr),y        ; insert actual bits
                            ora TabFlagFrank_Coffin_Dead    ; set dead flag
                            sta (CCZ_FrankDataPtr),y        ; set new frankenstein coffin flags in castle data
                            
                            jmp FrankSpriteCollideX         ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; this frankenstein collided with a mate - both will turn their move direction
; --------------------------------------------------------------------------------------------------------------------- ;
FrankMeetsFrank             lda CC_WA_Sprite_Num,x          ; get this frankenstein sprite number
                            cmp #SpriteNum_FrankClimb_Min - $01 ; test min climb number
                            bcc TestFrank_Floor             ; check: LT - yes: no climb - test walk
                            
                            cmp #SpriteNum_FrankClimb_Max + $01 ; test max climb number
                            bcs TestFrank_Floor             ; check: GE - yes: no climb - test walk
                            
                            lda CC_WA_Sprite_Num,y          ; get colliding frankenstein sprite number
                            cmp #SpriteNum_FrankClimb_Min - $01 ; test test min climb number
                            bcc FrankSpriteCollide_Exit     ; check: LT - yes: 
                            
                            cmp #SpriteNum_FrankClimb_Max + $01 ; test test max climb number
                            bcs FrankSpriteCollide_Exit     ; check: GE - yes: 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if both frankensteins touch on a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PosY,x         ; get this frankenstein PosY
                            cmp CC_WA_Sprite_PosY,y         ; test with colliding frankenstein PosY
                            beq FrankSpriteCollide_Exit     ; check: EQ - yes: exit
                            bcs TurnFrankOnLadder           ; check: GT - yes: 
                            
                            lda CC_WA_Sprite_Frank_CtrlVal,x; 
                            and #~CC_MoveCtrl_Down          ; clear a possible move down
                            sta CC_WA_Sprite_Frank_CtrlVal,x; 
                            
                            jmp FrankSpriteCollide_Exit     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; fake a move control gap to invert this frankenstein ladder move direction
; --------------------------------------------------------------------------------------------------------------------- ;
TurnFrankOnLadder           lda CC_WA_Sprite_Frank_CtrlVal,x; 
                            and #~CC_MoveCtrl_Up            ; clear a possible move up - force turn
                            sta CC_WA_Sprite_Frank_CtrlVal,x; 
                            
GoFrankSpriteCollide_Exit   jmp FrankSpriteCollide_Exit     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test this frankenstein 
; --------------------------------------------------------------------------------------------------------------------- ;
TestFrank_Floor             lda CC_WA_Sprite_Num,x          ; get this frankenstein sprite number
                            cmp #SpriteNum_FrankMove_Min    ; test min move sprite number
                            bcc FrankSpriteCollide_Exit     ; check: LT - yes: no frankenstein move sprite - exit
                            
                            cmp #SpriteNum_FrankMove_Max + $01 ; test max move sprite number
                            bcs FrankSpriteCollide_Exit     ; check: GE - yes: no frankenstein move sprite - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; test colliding frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Num,y          ; get colliding frankenstein sprite number
                            cmp #SpriteNum_FrankMove_Min    ; test min move sprite number
                            bcc FrankSpriteCollide_Exit     ; check: LT - yes: no frankenstein move sprite - exit
                            
                            cmp #SpriteNum_FrankMove_Max + $01 ; test max move sprite number
                            bcs FrankSpriteCollide_Exit     ; check: GE - yes: no frankenstein move sprite - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if both frankensteins collide on a floor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PosX,x         ; get this frankenstein PosX
                            cmp CC_WA_Sprite_PosX,y         ; test with colliding frankenstein PosX
                            bcs TurnFrankOnFloor_Le         ; check: GE - yes: 
; --------------------------------------------------------------------------------------------------------------------- ;
; fake a move control gap to invert this frankenstein floor move direction to the left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Frank_CtrlVal,x; 
                            and #~CC_MoveCtrl_Right         ; clear clear a possible move right - force turn left
                            sta CC_WA_Sprite_Frank_CtrlVal,x; 
                            
                            jmp FrankSpriteCollide_Exit     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; fake a move control gap to invert this frankenstein floor move direction to right
; --------------------------------------------------------------------------------------------------------------------- ;
TurnFrankOnFloor_Le         lda CC_WA_Sprite_Frank_CtrlVal,x; 
                            and #~CC_MoveCtrl_Left          ; clear a possible move left - force turn right
                            sta CC_WA_Sprite_Frank_CtrlVal,x; 
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare exit
; --------------------------------------------------------------------------------------------------------------------- ;
FrankSpriteCollide_Exit     lda #TabWrkSprt_Flag_Dead_No    ; 
                            sta TabWrkSprt_Flag_Dead        ; set flag frankenstein is still alive
                            
FrankSpriteCollideX         jmp RoomSpriteKillHandler.RTS_RoomSprtSprtCollHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; FrankSprite_WA_Handler    Does    : init or read frankenstein sprite position from frankenstein sprite work area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
FrankSprite_WA_Handler     .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Frank_Coffin            ; get offset frankenstein coffin
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein coffin from castle data
                            bit TabFlagFrank_Coffin_Dead    ; test frankenstein death
                            bne FrankSprite_WA_HandlerX     ; check: dead - yes: nothing to do - exit
                            
                            jsr SpriteGetFree_WA_Block      ; find and initialize the next free sprite work area block
; --------------------------------------------------------------------------------------------------------------------- ;
; mark new sprite work area as frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Sprite_Type_Frank    ; get frankenstein
                            sta CC_WA_Sprite_Type,x         ; init work area type frankenstein
                            
                            lda TabWrkFrank_CastleData_Off  ; get actual frankenstein castle data offset
                            sta CC_WA_Sprite_Frank_DataOff,x; set this frankenstein castle data offset
                            
                            ldy #$00                        ; 
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta CC_WA_Sprite_Frank_Mode,x   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check frankenstein status
; --------------------------------------------------------------------------------------------------------------------- ;
                            bit TabFlagFrank_Coffin_Empty   ; test coffin empty
                            bne IniFrankMoves               ; check: empty - no: frankenstein is roaming around
; --------------------------------------------------------------------------------------------------------------------- ;
; frankenstein is still in his coffin
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Frank_Coffin_PosX       ; get offset coffin PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get coffin PosX from castle data
                            sta CC_WA_Sprite_PosX,x         ; set frankenstein PosX
                            
                            ldy #$02                        ; get offset coffin PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get coffin PosY from castle data
                            clc                             ; 
                            adc #$07                        ; add correction value
                            sta CC_WA_Sprite_PosY,x         ; set frankenstein PosY
                            
                            lda #SpriteNum_FrankInCoffin    ; 
                            sta CC_WA_Sprite_Num,x          ; 
                            
                            jmp IniFrankSprite              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; frankenstein has left his coffin
; --------------------------------------------------------------------------------------------------------------------- ;
IniFrankMoves               ldy #CC_Frank_Sprite_PosX       ; get offset frankenstein sprite PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein sprite PosX from castle data
                            sta CC_WA_Sprite_PosX,x         ; set frankenstein sprite PosX
                            
                            ldy #CC_Frank_Sprite_PosY       ; get offset frankenstein sprite PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein sprite PosY from castle data
                            sta CC_WA_Sprite_PosY,x         ; set frankenstein sprite PosY
                            
                            ldy #CC_Frank_Sprite_Num        ; get offset frankenstein sprite number
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein sprite number from castle data
                            sta CC_WA_Sprite_Num,x          ; set frankenstein sprite number
                            
                            ldy #CC_Frank_CtrlTabOff        ; get offset frankenstein sprite move control table offset
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein sprite move control table offset from catle data
                            sta CC_WA_Sprite_Frank_CtrlTabOff,x ; set frankenstein sprite move control table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get frankenstein sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
IniFrankSprite              lda #$03                        ; 
                            sta CC_WA_Sprite_Width,x        ; 
                            
                            lda #$11                        ; 
                            sta CC_WA_Sprite_Height,x       ; 
                            
                            jsr SpriteDataUncompress        ; uncompress sprite data and set sprite attributes
; --------------------------------------------------------------------------------------------------------------------- ;
; init frankenstein work fields 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; get initial value
                            sta CC_WA_Sprite_Frank_CtrlVal,x; 
                            sta CC_WA_Sprite_TrapSw_DataOff,x ; set trap castle data offset if a trap switch was touched
                            sta CC_WA_Sprite_RoomIO_Block_Off,x ; set offset room In/Out block
                            
                            lda #$02                        ; 
                            sta CC_WA_Sprite_SeqNum,x       ; init sprite sequence number
                            sta CC_WA_Sprite_SeqNum_Sav,x   ; init sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
FrankSprite_WA_HandlerX     pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkFrank_Player_Num      .byte $85 ; actual player number
TabWrkFrank_MoveCtrlTab_Off .byte $a0 ; control bit table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; store max distance values found between player and frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkFrank_Dist_Max        = * ; 
TabWrkFrank_Off_Max_Do      = * - TabWrkFrank_Dist_Max ; 
                            .byte $a5 ; $00 - max distance of frankenstein below player
TabWrkFrank_Off_Max_Le      = * - TabWrkFrank_Dist_Max ; 
                            .byte $c4 ; $01 - max distance of frankenstein left  player
TabWrkFrank_Off_Max_Up      = * - TabWrkFrank_Dist_Max ; 
                            .byte $85 ; $02 - max distance of frankenstein above player
TabWrkFrank_Off_Max_Ri      = * - TabWrkFrank_Dist_Max ; 
                            .byte $c1 ; $03 - max distance of frankenstein right player
                            
TabWrkFrank_Dist_Max_Len    = * - TabWrkFrank_Dist_Max - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkFrank_Dist_Found      .byte $ba ; max distance value result
TabWrkFrank_Dist_Work       .byte $c9 ; actual max distance value found
TabWrkFrank_Dist_Work_Flag  .byte $a0 ; flag max distance value found
TabWrkFrank_MoveCtrl_Val    .byte $85 ; move control value for FloorEnd / LadderTop / FloorStart / Ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; SpriteGetFree_WA_Block    Does    : find and initialize the next free sprite work area block
;                           Expects : 
;                           Returns : .X=Sprite WA offset
;                                   : .C=0 - A free WA was found and initialized
;                                   : .C=1 - No free WA block found
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteGetFree_WA_Block     .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; init WA block offset
GetNextWA_SpriteFlag        lda CC_WA_Sprite_Flag,x         ; get sprite work ara status flag
                            bit TabFlagSprt_WA_Free         ; test flag sprite work area is free again
                            bne Ini_WA_Block                ; check: is this sprite WA free - yes: handle it
; --------------------------------------------------------------------------------------------------------------------- ;
; max $08 WA blocks of $20 bytes each are possible ($00, $20, $40, $60, $80, $a0, $c0, $e0)
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; 
                            clc                             ; 
                            adc #CC_WA_Sprite_Len           ; advance WA block offset
                            tax                             ; set WA block offset
                            bne GetNextWA_SpriteFlag        ; check: max number of WA blocks - no: continue
                            
                            sec                             ; set error flag: No free WA block found
                            jmp SpriteGetFree_WA_BlockX     ; exit error
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize the work area block found
; --------------------------------------------------------------------------------------------------------------------- ;
Ini_WA_Block                ldy #CC_WA_Sprite_Len           ; get WA byte count
                            lda #$00                        ; get initial value
IniNext_WA_BlockByte        sta CC_WA_Sprite,x              ; init sprite work area
                            
                            inx                             ; inc WA block offset
                            dey                             ; get WA byte count
                            bne IniNext_WA_BlockByte        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; 
                            sec                             ; 
                            sbc #CC_WA_Sprite_Len           ; remove the init advancement
                            tax                             ; set return value
                            
                            lda TabFlagSprt_WA_Init         ; get flag sprite work area initialized
                            sta CC_WA_Sprite_Flag,x         ; mark sprite work area as initialized
                            
                            lda #$01                        ; get initial value
                            sta CC_WA_Sprite_SeqNum_Sav,x   ; init sprite sequence number 
                            sta CC_WA_Sprite_SeqNum,x       ; init sprite sequence number
                            
                            clc                             ; clear error flag: a free WA was found and initialized
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteGetFree_WA_BlockX     pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomItemHandler           Does    : Loop through the object work areas and check for actions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemHandler            .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta TabWrkItem_Action_WA_Num    ; init actual action work area number
                            
TryNextItem_WA              lda TabWrkItem_Action_WA_Num    ; get actual action work area number
                            cmp TabItem_WA_UseCount         ; test with actual work area use count
                            bcc WorkArea                    ; check: LT - yes: handle this work area
                            
                            jmp RoomItemHandlerX            ; all done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; handle this work area
; --------------------------------------------------------------------------------------------------------------------- ;
WorkArea                    asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - CC_WA_ItemDef_Len
                            tax                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; check if subroutine needs to be called
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            bit TabItem_WA_Flag_Ready       ; test flag ready to be dispatched
                            beq Get_WA_Status_Move          ; check: ready - no: skip subroutine call
; --------------------------------------------------------------------------------------------------------------------- ;
; set up for room item handler address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Type,x        ; get actual item type number
                            asl a                           ; *2
                            asl a                           ; *4 - item handling routines table block length
                            tay                             ; set as auto move routines address table offset
                            
                            lda TabMoveHandler_Item + $00,y ; 
                            sta smRoomItemAutoMoveAdr_Lo    ; set address room item auto move handler Lo
                            
                            lda TabMoveHandler_Item + $01,y ; 
                            sta smRoomItemAutoMoveAdr_Hi    ; set address room item auto move handler Hi
                            
                            beq Flip_WA_Status              ; check: routine available - no: bypass item auto handler call
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch the selected room item automove handler
; --------------------------------------------------------------------------------------------------------------------- ;
smRoomItemAutoMoveAdr       = * + $01                       ; self modified auto move handler address
smRoomItemAutoMoveAdr_Lo      = smRoomItemAutoMoveAdr + $00 ; self modified auto move handler address
smRoomItemAutoMoveAdr_Hi      = smRoomItemAutoMoveAdr + $01 ; 
                            jmp smRoomItemAutoMoveAdr       ; call the desired room item auto move handler
; --------------------------------------------------------------------------------------------------------------------- ;
; common RTS point to the room item auto move handler
; --------------------------------------------------------------------------------------------------------------------- ;
RTS_RoomItemHandler         jmp Get_WA_Status               ; bypass flip work area status
; --------------------------------------------------------------------------------------------------------------------- ;
; mark this routine as inactive - do not dispatch again
; --------------------------------------------------------------------------------------------------------------------- ;
Flip_WA_Status              lda CC_WA_ItemDef_Status,x      ; get work area status
                            eor TabItem_WA_Flag_Ready       ; flip flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; set work area status
; --------------------------------------------------------------------------------------------------------------------- ;
; check it the item was picked up - get rid of its work area then by overwriting it with the last one in list
; --------------------------------------------------------------------------------------------------------------------- ;
Get_WA_Status               lda CC_WA_ItemDef_Status,x      ; 
                            
Get_WA_Status_Move          bit TabItem_WA_Flag_Gone        ; test flag CC_WA_ItemDef_Status_Gone
                            beq SetNext_WA_Num              ; check: EQ - no: bypass copy
; --------------------------------------------------------------------------------------------------------------------- ;
; a room item was picked up - clear it in the room and free its work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDelete              ; wipe out an item from the room display and deactivate its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; fill the now free picked item work areas with the data of the max work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabItem_WA_UseCount         ; discount work area for the item that was picked up
                            
                            lda TabItem_WA_UseCount         ; get actual work area use count
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - CC_WA_ItemDef_Len
                            sta sm_WA_ChkMaxUseOff          ; set source work area check offset value
; --------------------------------------------------------------------------------------------------------------------- ;
; a copy is only needed if picked and max work areas are not equal
; --------------------------------------------------------------------------------------------------------------------- ;
sm_WA_ChkMaxUseOff          = * + $01                       ; self modified check max work area offset
                            cpx #$00                        ; test picked work area offset with max work area offset
                            beq RoomItemHandlerX            ; check: EQ - yes: bypass copy source to target work area
; --------------------------------------------------------------------------------------------------------------------- ;
; close the opened item pick gap - overwrite both picked item work areas with data from the max work areas
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; set as target work area offset
                            
                            lda #CC_WA_ItemDef_Len          ; get work area length
                            sta TabWrkItem_Copy_WA_Len      ; init actual work area length
MoveNext_WA_Byte            lda CC_WA_ItemDef,y             ; get status source work area byte
                            sta CC_WA_ItemDef,x             ; set status target work area byte
                            
                            lda CC_WA_Item,y                ; get source work area byte
                            sta CC_WA_Item,x                ; set target work area byte
                            
                            inx                             ; inc source work area offset
                            iny                             ; inc target work area offset
                            
                            dec TabWrkItem_Copy_WA_Len      ; dec actual work area length
                            bne MoveNext_WA_Byte            ; check: 
; --------------------------------------------------------------------------------------------------------------------- ;
; try to continue with the next work area
; --------------------------------------------------------------------------------------------------------------------- ;
SetNext_WA_Num              inc TabWrkItem_Action_WA_Num    ; inc actual work area number to next entry
                            jmp TryNextItem_WA              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemHandlerX            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkItem_Copy_WA_Len      .byte $d8 ; 
TabWrkItem_Action_WA_Num    .byte $84 ; actual action work area number
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemDoorOpen              Does    : open a door
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset item work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemDoorOpen               .block                           ; 
                            lda CC_WA_Item_Door_Status,x    ; get door status
                            bne LiftGrate                   ; check: shut - no: lift the grate
; --------------------------------------------------------------------------------------------------------------------- ;
; door is still shut
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Item_Door_Status_Open; get flag door is open
                            sta CC_WA_Item_Door_Status,x    ; set flag door is open in work area
                            
                            lda #CC_WA_Item_Door_GrateLift_Ini ; get initial value
                            sta CC_WA_Item_Door_GrateLift,x ; init grate lifting process counter
; --------------------------------------------------------------------------------------------------------------------- ;
; get door data offset for the selected door
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Door_Num,x       ; get door number
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - castle data CC_Door_Item_Len
; --------------------------------------------------------------------------------------------------------------------- ;
; set door data pointer for the selected door
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc TabWrkDoor_DataPtr_Lo       ; add door data start Lo
                            sta CCZ_DoorDataPtr_Lo          ; 
                            
                            lda TabWrkDoor_DataPtr_Hi       ; get add door data start Hi
                            adc #$00                        ; add carry
                            sta CCZ_DoorDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark this room door as open in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_MapWall            ; get offset door map wall
                            lda (CCZ_DoorDataPtr),y         ; get door map wall
                            ora #CC_Door_MapWall_Open       ; insert flag Door Bell was pressed
                            sta (CCZ_DoorDataPtr),y         ; mark door as open
                            
                            ldy #CC_Door_TargetDoorNum      ; get offset target door number
                            lda (CCZ_DoorDataPtr),y         ; get target door number
                            pha                             ; save target door number
                            
                            ldy #CC_Door_TargetRoomNum      ; get offset target room number
                            lda (CCZ_DoorDataPtr),y         ; get target room number
                            jsr CastleRoomDataPointerSet    ; set the room data pointer to the requested entry in the target data store
; --------------------------------------------------------------------------------------------------------------------- ;
; mark target room door as open in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore target door number
                            jsr CastleDoorDataPointerSet    ; set the door address pointer to the requested door data area / set the door count
                            
                            ldy #CC_Door_MapWall            ; get offset door map wall
                            lda (CCZ_DoorDataPtr),y         ; get door map wall
                            ora #CC_Door_MapWall_Open       ; insert flag Door Bell was pressed
                            sta (CCZ_DoorDataPtr),y         ; mark door as open
; --------------------------------------------------------------------------------------------------------------------- ;
; lift the grate a bit
; --------------------------------------------------------------------------------------------------------------------- ;
LiftGrate                   sec                             ; 
                            lda #$10                        ; 
                            sbc CC_WA_Item_Door_GrateLift,x ; 
                            sta TabSFX_OpenDoor_Tone        ; 
                            
                            lda #NumSfx_OpenDoor            ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
                            
                            lda CC_WA_Item_Door_GrateLift,x ; 
                            beq MarkGrate_Open              ; check: min - yes: door is open
                            
                            dec CC_WA_Item_Door_GrateLift,x ; 
                            
                            clc                             ; 
                            adc CC_WA_ItemDef_PosY,x        ; add item PosY
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda CC_WA_ItemDef_PosX,x        ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the entrance before redraw the lifted grate
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_Blank              ; get clear entrance item
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
                            jmp ItemDoorOpenX               ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; mark opening process as complete
; --------------------------------------------------------------------------------------------------------------------- ;
MarkGrate_Open              lda CC_WA_ItemDef_Status,x      ; 
                            eor TabItem_WA_Flag_Ready       ; flip flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; color the now visible exit passage ground with target room color
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabDataDoorOpen_Color_Len  ; 
                            lda CC_WA_Item_Door_TargColor,x ; 
SetNextOpenGroundColor      sta TabDataDoorOpen_Color,y     ; 
                            
                            dey                             ; 
                            bpl SetNextOpenGroundColor      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the exit passage ground item
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_DoorOpen           ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda CC_WA_ItemDef_PosX,x        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda CC_WA_ItemDef_PosY,x        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            
ItemDoorOpenX               jmp RoomItemHandler.RTS_RoomItemHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerRoomLeave           Does    : exit a player through an open castle room door
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset item work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerRoomLeave            .block                           ; 
                            sty TabWrkDoor_WA_Off           ; save door work area offset
                            
                            lda CC_WA_Item_Door_Status,y    ; get door status
                            beq Exit                        ; check: CC_WA_Item_Door_Status_Shut - yes: 
                            
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            beq DoorLeave                   ; check: CC_WA_Sprite_Type_Player - yes: leave him
                            
Exit                        jmp PlayerRoomLeaveX            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; exit player through door passage on move UP_RIGHT
; --------------------------------------------------------------------------------------------------------------------- ;
DoorLeave                   lda CC_WA_Sprite_Move_Subst,x   ; get move substitition value from TabJoy_Move_Subst
                            cmp #CC_WA_Sprite_Move_Subst_UR ; test move UP_RIGHT
                            bne PlayerRoomLeaveX            ; check: EQ - no: nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; check if selected player has finished his arrival
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_Sprite_PlayerNum,x    ; get player number 
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne PlayerRoomLeaveX            ; check: arrived - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set inital values for exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_GameDataVar_Flag_IO_Start ; get flag player enters/leaves a room
                            sta CC_GameDataVar_Flag,y       ; set flag this player leaves a room
                            
                            lda #TabPlayer_RoomIO_Off_Leave ; get offset player leaves a room block
                            sta CC_WA_Sprite_RoomIO_Block_Off,x ; init offset leave room In/Out block
                            
                            lda #$03                        ; get initial value
                            sta CC_WA_Sprite_SeqNum,x       ; sprite sequence number
; --------------------------------------------------------------------------------------------------------------------- ;
; get door data offset for the selected door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkDoor_WA_Off           ; restore door work area offset
                            lda CC_WA_Item_Door_Num,y       ; get door number
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - castle data CC_Door_Item_Len
; --------------------------------------------------------------------------------------------------------------------- ;
; set door data pointer for the selected door
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc TabWrkDoor_DataPtr_Lo       ; 
                            sta CCZ_DoorDataPtr_Lo          ; 
                            lda TabWrkDoor_DataPtr_Hi       ; 
                            adc #$00                        ; add carry
                            sta CCZ_DoorDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set player sprite start position values
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_PosY               ; get offset door PosY
                            clc                             ; 
                            lda (CCZ_DoorDataPtr),y         ; get door PosY
                            adc #$0f                        ; add exit animation start PosY
                            sta CC_WA_Sprite_PosY,x         ; set work area sprite PosY
                            
                            ldy #CC_Door_PosX               ; get offset door PosX
                            clc                             ; 
                            lda (CCZ_DoorDataPtr),y         ; get door PosX
                            adc #$06                        ; add exit animation start PosX
                            sta CC_WA_Sprite_PosX,x         ; set work area sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; check door type for exit door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_Type               ; get offset door type
                            lda (CCZ_DoorDataPtr),y         ; get door type
                            beq SetCastleData               ; check: CC_Door_Type_Normal - yes: bypass exit door marking
; --------------------------------------------------------------------------------------------------------------------- ;
; was exit door - mark player exited
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_Sprite_PlayerNum,x    ; get player number
                            lda #CC_GameDataVar_Exit_Yes    ; get flag player has successfully exited the castle
                            sta CC_GameDataVar_Exit,y       ; set flag player exit status in castle data variables
; --------------------------------------------------------------------------------------------------------------------- ;
; set target room number and target door number in castle game data
; --------------------------------------------------------------------------------------------------------------------- ;
SetCastleData               ldy #CC_Door_TargetDoorNum      ; get offset target door number
                            lda (CCZ_DoorDataPtr),y         ; get target door number
                            sta TabWrkDoor_Target_Door_Num  ; set target door number
                            
                            ldy #CC_Door_TargetRoomNum      ; get offset target room number
                            lda (CCZ_DoorDataPtr),y         ; get target room number
                            sta TabWrkDoor_Target_Room_Num  ; set target room number
; --------------------------------------------------------------------------------------------------------------------- ;
; get room data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr CastleRoomDataPointerSet    ; set the room data pointer to the requested entry in the target data store
; --------------------------------------------------------------------------------------------------------------------- ;
; mark door as open
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Room_Map_Status         ; get offset room map status
                            lda (CCZ_RoomListDataPtr),y     ; get room map status
                            ora TabFlagRoom_Visited         ; set flag CC_Room_Map_Status_Visited
                            sta (CCZ_RoomListDataPtr),y     ; set room map status to visited - will now be drawn on map
                            
                            ldy CC_WA_Sprite_PlayerNum,x    ; get player number
                            lda TabWrkDoor_Target_Room_Num  ; get target room number
                            sta CC_GameDataVar_TargRoom,y   ; set player target room number in castle data variables
                            
                            lda TabWrkDoor_Target_Door_Num  ; get target door number
                            sta CC_GameDataVar_TargDoor,y   ; set player target door number in castle data variables
                            
PlayerRoomLeaveX            ldy TabWrkDoor_WA_Off           ; restore save door work area offset
                            jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; DrawDoor                  Does    : draw the castle room doors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawDoor                   .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get nummber of the doors in the room
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_Count              ; 
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDoor_Count_Max        ; save max number of room doors 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer behind room door count
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne SavRoomDataPtrStart         ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; save data pointer door
; --------------------------------------------------------------------------------------------------------------------- ;
SavRoomDataPtrStart         lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabWrkDoor_DataPtr_Lo       ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabWrkDoor_DataPtr_Hi       ; 
                            
                            lda #$00                        ; get initial value
                            sta TabWrkDoor_Count            ; init actual door number count
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a door still needs to be painted
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextDoorCount            lda TabWrkDoor_Count            ; set actual door number count
                            cmp TabWrkDoor_Count_Max        ; test with max number of room doors 
                            bne RoomDoor                    ; check: EQ - no: draw this door
                            
                            jmp DrawDoorX                   ; done  - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set draw parms for this door
; --------------------------------------------------------------------------------------------------------------------- ;
RoomDoor                    ldy #CC_Door_Type               ; get offset door type
                            lda (CCZ_DrawItemDataPtr),y     ; get door type
                            tax                             ; set as offset
                            
                            lda TabDoor_Type_ItemNum,x      ; get door item number from table (normal/exit)
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            ldy #CC_Door_PosX               ; get offset door PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get door PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Door_PosY               ; get offset door PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get door PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this door type
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; get freshly initialized work areas for this door
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the door frame PosX/PosY to the entrance PosX/PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set entrance draw item type_0 parm: PosX
                            
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08 * $02                  ; add room double draw grid height - step two room grid positions down
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set entrance draw item type_0 parm: PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; fill the work area for this door
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDoor_Count            ; get actual door number count
                            sta CC_WA_Item_Door_Num,x       ; set work area door number
                            
                            lda #CC_WA_ItemDef_Type_Door    ; 
                            sta CC_WA_ItemDef_Type,x        ; save work area door type (normal/exit)
; --------------------------------------------------------------------------------------------------------------------- ;
; get the required info from the doors target room
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_TargetRoomNum      ; get offset target room number
                            lda (CCZ_DrawItemDataPtr),y     ; get target room number
                            jsr CastleRoomDataPointerSet    ; set the room data pointer to the requested entry in the target data store
                            
                            ldy #CC_Room_Map_Status         ; get offset target room map status byte
                            lda (CCZ_RoomListDataPtr),y     ; get target room map status byte
                            and #CC_Room_Map_Status_Color   ; isolate target room map color
                            sta CC_WA_Item_Door_TargColor,x ; save target room color
; --------------------------------------------------------------------------------------------------------------------- ;
; shift color to left nibble                                ; ....####
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl a                           ; ...####.
                            asl a                           ; ..####..
                            asl a                           ; .####...
                            asl a                           ; ####....
                            ora CC_WA_Item_Door_TargColor,x ; re-insert color to the right nibble
                            sta CC_WA_Item_Door_TargColor,x ; set hires color byte
; --------------------------------------------------------------------------------------------------------------------- ;
; get door status
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_MapWall            ; get offset target wall number
                            lda (CCZ_DrawItemDataPtr),y     ; get target wall number
                            and #CC_Door_MapWall_Open       ; isolate flag target door open status
                            bne IniOpenEntranceColor        ; check: open - yes: draw open door target room colored ground
; --------------------------------------------------------------------------------------------------------------------- ;
; closed door - init a grate
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_DoorGrate          ; get item number grate - closed flag set at init
                            jmp SetDoorEntranceItem         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; open door - init colored ground - set open status 1st
; --------------------------------------------------------------------------------------------------------------------- ;
IniOpenEntranceColor        lda #CC_WA_Item_Door_Status_Open; 
                            sta CC_WA_Item_Door_Status,x    ; set flag open door
                            
                            ldy #TabDataDoorOpen_Color_Len  ; init colored ground length
                            lda CC_WA_Item_Door_TargColor,x ; get color
SetNextOpenEntranceColor    sta TabDataDoorOpen_Color,y     ; set ground color
                            
                            dey                             ; dec color length
                            bpl SetNextOpenEntranceColor    ; check: min - no: continue
                            
                            lda #ItemNum_DoorOpen           ; get item number open door ground
; --------------------------------------------------------------------------------------------------------------------- ;
; set the desired door entrance (open/closed by a grate)
; --------------------------------------------------------------------------------------------------------------------- ;
SetDoorEntranceItem         sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the selected entrance from work area settings
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room item data pointer to next door item
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_Door_Item_Len           ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc SetNextDoorNumber           ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
SetNextDoorNumber           inc TabWrkDoor_Count            ; inc actual door number count
                            jmp GetNextDoorCount            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawDoorX                   pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDoor_Count            .byte $a0 ; actual door number count
TabWrkDoor_Count_Max        .byte $a0 ; max number of room doors 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDoor_Type_ItemNum        = *       ; 
                            .byte ItemNum_DoorNormal ; 
                            .byte ItemNum_DoorExit   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDoor_DataPtr_Lo       .byte $ac ; pointer to door data
TabWrkDoor_DataPtr_Hi       .byte $b4 ; 
TabWrkDoor_WA_Off           .byte $a0 ; offset door work area
TabWrkDoor_Target_Room_Num  .byte $9e ; room exit target room number
TabWrkDoor_Target_Door_Num  .byte $a0 ; room exit target door number
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerDoorBellRing        Does    : a player rings a door bell to open a door
;                           Expects : .X=offset player sprite work area
;                                   : .Y=offset bell work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerDoorBellRing         .block                           ; 
                            stx TabWrkBell_Sprite_WA_Off    ; save offset player sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; only a player can press a door bell
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne PlayerDoorBellRingX         ; check: CC_WA_Sprite_Type_Player - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; did this player press the door bell
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_FireButton,x   ; get status player fire button
                            beq PlayerDoorBellRingX         ; check: CC_WA_Sprite_FireButton_No - yes: not pressed - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; test if player stands in front of the door bell
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get sprite PosX
                            adc CC_WA_Sprite_Width,x        ; add sprite width
                            
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; subtract bell PosX
                            cmp #$0c                        ; test with bell width
                            bcs PlayerDoorBellRingX         ; check: GE - yes: not in front of the bell
; --------------------------------------------------------------------------------------------------------------------- ;
; check if selected player has finished his arrival
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PlayerNum,x    ; get player number
                            tax                             ; set as offset
                            
                            lda CC_GameDataVar_Flag,x       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne PlayerDoorBellRingX         ; check: arrived - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; look for the door this bell will open
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; init work area offset
GetNext_WA_Type             lda CC_WA_ItemDef_Type,x        ; get item type
                            bne Inc_WA_Off                  ; check: CC_WA_ItemDef_Type_Door - no: try next work area
                            
                            lda CC_WA_Item_Door_Num,x       ; get door number
                            cmp CC_WA_Item_Bell_Door_Num,y  ; test with bell door number
                            beq MarkDoor                    ; the bells door number found
; --------------------------------------------------------------------------------------------------------------------- ;
; advance offset to next work area
; --------------------------------------------------------------------------------------------------------------------- ;
Inc_WA_Off                  clc                             ; 
                            txa                             ; 
                            adc #CC_WA_ItemDef_Len          ; add work area length
                            tax                             ; 
                            
                            jmp GetNext_WA_Type             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark door as open if it is still shut
; --------------------------------------------------------------------------------------------------------------------- ;
MarkDoor                    lda CC_WA_Item_Door_Status,x    ; get flag door status
                            bne PlayerDoorBellRingX         ; check: CC_WA_Item_Door_Status_Shut - no: bypass ready flag
                            
                            lda CC_WA_ItemDef_Status,x      ; 
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
                            
PlayerDoorBellRingX         ldx TabWrkBell_Sprite_WA_Off    ; restore offset player sprite work area
                            jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; DrawBell                  Does    : draw the castle room door bells
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawBell                   .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_BellCount               ; get offset room bells count
                            lda (CCZ_DrawItemDataPtr),y     ; get room bells count
                            sta TabWkrBell_Count            ; set actual room bells count
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer behind room bells count
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne DrawNextDoorBell            ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this door bell
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextDoorBell            lda TabWkrBell_Count            ; get actual room bells count
                            beq DrawBellX                   ; check: min - yes: done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get and mark a new work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_Bell    ; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as door bell
; --------------------------------------------------------------------------------------------------------------------- ;
; init item draw parms
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_BellPosX                ; get offset door bell PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_BellPosY                ; get offset door bell PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_DoorBell           ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; set target door number in new work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_BellTargetDoorNum       ; get offset target door number
                            lda (CCZ_DrawItemDataPtr),y     ; get target door number from room data
                            sta CC_WA_Item_Door_Num,x       ; set target door number in new work area
; --------------------------------------------------------------------------------------------------------------------- ;
; get first active work area of type door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset item type
ChkNext_WA_Door             lda CC_WA_ItemDef_Type,y        ; get actual status work area type
                            bne RTS_ItemManualMoveHandler   ; check: EQ CC_WA_ItemDef_Type_Door - no: continue with next WA
; --------------------------------------------------------------------------------------------------------------------- ;
; look for matching door number for the correct bell color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Door_Num,y       ; get actual door number
                            cmp CC_WA_Item_Bell_Door_Num,x  ; test with bell door number
                            bne RTS_ItemManualMoveHandler   ; check: EQ - no: try next work area
                            
                            lda CC_WA_Item_Door_TargColor,y ; get target room color
                            jmp IniDoorBellColor            ; color door bell with it
; --------------------------------------------------------------------------------------------------------------------- ;
; advane work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
RTS_ItemManualMoveHandler   tya                             ; get work area offset 
                            clc                             ; 
                            adc #CC_WA_ItemDef_Len          ; add work area length
                            tay                             ; 
                            
                            jmp ChkNext_WA_Door             ; continue search matching target door
; --------------------------------------------------------------------------------------------------------------------- ;
; color door bell with the color of the taget room
; --------------------------------------------------------------------------------------------------------------------- ;
IniDoorBellColor            ldy #TabDataDoorBellColor_Len   ; init door bell color len
SetNextBellColor            sta TabDataDoorBellColor_01,y   ; 
                            
                            dey                             ; dec door bell color len
                            bpl SetNextBellColor            ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set door bell center color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr a                           ; shift left nibble to right
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            ora #WHITE << $04               ; insert white to left nibble
                            sta TabDataDoorBellColor_02     ; set fix white door bell center color
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next bell data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_DoorBellItem_Len        ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc SetNextDoorBell             ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
SetNextDoorBell             dec TabWkrBell_Count            ; dec actual room bells count
                            jmp DrawNextDoorBell            ; continue with next door bell
; --------------------------------------------------------------------------------------------------------------------- ;
DrawBellX                   pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWkrBell_Count            .byte $a0 ; 
TabWrkBell_Sprite_WA_Off    .byte $ff ; offset player sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemLightPole             Does    : handle the lightning machine pole movement
;                           Expects : .X=offset light machine work area active orb
;                                   : .Y=offset bell work area
;                           Returns : 
;                           Remark  : is constantly called with the rotated next active orb work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
ItemLightPole              .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set lightning machine data pointer for the selected lightning machine
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkLight_DataPtr_Lo      ; 
                            adc CC_WA_Item_Light_Orb_DataOff,x ; add offset lightning machine orb in castle data
                            sta CCZ_LightPoleDataPtr_Lo     ; 
                            
                            lda TabWrkLight_DataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_LightPoleDataPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check sprite init flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Light_Sprt_Init,x; get orb mode
                            cmp #CC_WA_Item_Light_Sprt_Init_Yes ; test flag orb switched on
                            beq CheckLightMode              ; check: EQ - yes: orb is switched on
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize spark sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Item_Light_Sprt_Init_Yes ; get flag sprite work area initialized
                            sta CC_WA_Item_Light_Sprt_Init,x; 
                            
                            jsr LightSpriteInitSpark_WA     ; get and initialize a spark sprite work area
                            jmp IniPoleMotionColor          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test lighning machine mode
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLightMode              ldy #CC_LightMach_Mode          ; get offset lightning machine mode
                            lda (CCZ_LightPoleDataPtr),y    ; get lightning machine mode
                            bit TabFlagLight_Orb_On         ; test flag orb switched on
                            bne CheckWait_IRQ               ; check: orb on - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; orb is switched off
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Item_Light_Sprt_Init_No ; 
                            sta CC_WA_Item_Light_Sprt_Init,x; set flag light machine spar needs an init
                            
                            lda CC_WA_ItemDef_Status,x      ; 
                            eor TabItem_WA_Flag_Ready       ; flip flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
                            
                            lda #HR_GREEN_GREEN             ; get color for inactive pole
                            sta TabDataLightMachPoleColor_1 ; 
                            sta TabDataLightMachPoleColor_2 ; 
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            ldy #CC_LightMach_Pole_PosX     ; get offset pole PosX
                            lda (CCZ_LightPoleDataPtr),y    ; get pole PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_LightMach_Pole_PosY     ; get offset pole PosY
                            lda (CCZ_LightPoleDataPtr),y    ; get pole PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_LightPoleColor     ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            ldy #CC_LightMach_Pole_Len      ; get offset pole length
                            lda (CCZ_LightPoleDataPtr),y    ; get pole length
                            sta TabWrkLight_Pole_Move_Len   ; set actual pole length
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the inactive lighning machine pole
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextPolePiece_Inact     lda TabWrkLight_Pole_Move_Len   ; get actual pole length
                            beq IniSprt_WA_Search           ; check: min - yes
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; set next inactive lighning machine pole PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            dec TabWrkLight_Pole_Move_Len   ; dec actual pole length
                            jmp DrawNextPolePiece_Inact     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; search relative lighning machine orb work area
; --------------------------------------------------------------------------------------------------------------------- ;
IniSprt_WA_Search           ldy #$00                        ; init work area offset
TestNextSprt_WA             lda CC_WA_Sprite_Type,y         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            cmp #CC_WA_Sprite_Type_Spark    ; test lightning machine spark
                            bne Set_Next_WA_Off             ; check: EQ - no: try next work area
                            
                            lda CC_WA_Sprite_Flag,y         ; get sprite flag
                            bit TabFlagSprt_WA_Free         ; test flag sprite work area is free again
                            bne Set_Next_WA_Off             ; check: free - yes: try next work area
                            
                            lda CC_WA_Sprite_Light_DataOff,y; get sprite work area offset 
                            cmp CC_WA_Item_Light_Orb_DataOff,x ; test with offset lightning machine orb in castle data
                            beq SetLightSprtFlag            ; check: EQ - yes: found
; --------------------------------------------------------------------------------------------------------------------- ;
; advance sprite work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
Set_Next_WA_Off             tya                             ; 
                            clc                             ; 
                            adc #CC_WA_Sprite_Len           ; add sprite work area length
                            tay                             ; 
                            
                            jmp TestNextSprt_WA             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; lighning machine orb work area found
; --------------------------------------------------------------------------------------------------------------------- ;
SetLightSprtFlag            lda CC_WA_Sprite_Flag,y         ; get sprite flag
                            ora TabFlagSprt_Moves           ; insert flag sprite to be moved in RoomSpriteHandler
                            sta CC_WA_Sprite_Flag,y         ; set sprite flag
                            
                            jmp ItemLightPoleX              ; return to caller
; --------------------------------------------------------------------------------------------------------------------- ;
CheckWait_IRQ               lda TabWrkIRQ_Delay             ; get delay time value
                            and #$03                        ; isolate wait time
                            beq IniPoleMotionColor          ; check: used up - yes: continue coloring
                            
                            jmp ItemLightPoleX              ; return to caller
; --------------------------------------------------------------------------------------------------------------------- ;
; rotate the active lightning pole color
; --------------------------------------------------------------------------------------------------------------------- ;
IniPoleMotionColor          inc CC_WA_Item_Light_Pole_Step,x ; inc pole motion count
                            
                            lda CC_WA_Item_Light_Pole_Step,x ; get pole motion count
                            cmp #TabWrkLight_Pole_MoveStep_2 + $01 ; test max
                            bcc SetPoleMotionCount          ; check: LT - yes: bypass init
                            
                            lda #TabWrkLight_Pole_MoveStep_0 ; get initial value
                            sta CC_WA_Item_Light_Pole_Step,x ; init pole motion count
                            
SetPoleMotionCount          sta TabWrkLight_Pole_MoveStep    ; set rotated motion step
                            
                            ldy #CC_LightMach_Pole_PosX     ; get offset pole PosX
                            lda (CCZ_LightPoleDataPtr),y    ; get pole PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_LightMach_Pole_PosY     ; get offset pole PosY
                            lda (CCZ_LightPoleDataPtr),y    ; get pole PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_LightPoleColor     ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            ldy #CC_LightMach_Pole_Len      ; get offset pole length
                            lda (CCZ_LightPoleDataPtr),y    ; get pole length
                            sta TabWrkLight_Pole_Move_Len   ; set actual pole length
; --------------------------------------------------------------------------------------------------------------------- ;
; color the light machine pole if switched on
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextPolePiece_Act       lda TabWrkLight_Pole_Move_Len   ; 
                            beq ItemLightPoleX              ; check: ZERO - yes: nothing to do - return to caller
                            
                            lda TabWrkLight_Pole_MoveStep   ; get rotated motion step
                            beq LightPole_Step_0            ; check: TabWrkLight_Pole_MoveStep_0 - yes
                            
                            cmp #TabWrkLight_Pole_MoveStep_1; test step #1
                            beq LightPole_Step_1            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; active lighning machine pole step #2
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_BLUE_BLUE               ; 
                            sta TabDataLightMachPoleColor_1 ; 
                            
                            lda #WHITE                      ; 
                            sta TabDataLightMachPoleColor_2 ; 
                            
                            jmp DrawSelPolePiece_Act        ; draw the selecte lighning machine pole step
; --------------------------------------------------------------------------------------------------------------------- ;
; active lighning machine pole step #0
; --------------------------------------------------------------------------------------------------------------------- ;
LightPole_Step_0            lda #HR_WHITE_BLUE              ; 
                            sta TabDataLightMachPoleColor_1 ; 
                            
                            lda #BLUE                       ; 
                            sta TabDataLightMachPoleColor_2 ; 
                            
                            jmp DrawSelPolePiece_Act        ; draw the selecte lighning machine pole step
; --------------------------------------------------------------------------------------------------------------------- ;
; active lighning machine pole step #1
; --------------------------------------------------------------------------------------------------------------------- ;
LightPole_Step_1            lda #HR_BLUE_WHITE              ; 
                            sta TabDataLightMachPoleColor_1 ; 
                            
                            lda #BLUE                       ; 
                            sta TabDataLightMachPoleColor_2 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the selecte lighning machine pole step
; --------------------------------------------------------------------------------------------------------------------- ;
DrawSelPolePiece_Act        jsr RoomItemDraw                ; draw the selected room item
                            
                            inc TabWrkLight_Pole_MoveStep   ; inc rotated motion step
                            
                            lda TabWrkLight_Pole_MoveStep   ; get rotated motion step
                            cmp #TabWrkLight_Pole_MoveStep_2 + $01 ; test max
                            bcc StepNextPoleAct_Do          ; check: LT - yes: set next active pole PosY
                            
                            lda #TabWrkLight_Pole_MoveStep_0; 
                            sta TabWrkLight_Pole_MoveStep   ; init rotated motion step
; --------------------------------------------------------------------------------------------------------------------- ;
; set next active lighning machine pole PosY
; --------------------------------------------------------------------------------------------------------------------- ;
StepNextPoleAct_Do          clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            dec TabWrkLight_Pole_Move_Len   ; dec actual pole length
                            jmp DrawNextPolePiece_Act       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemLightPoleX              jmp RoomItemHandler.RTS_RoomItemHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkLight_Pole_Move_Len   .byte $a5 ; 
TabWrkLight_Pole_MoveStep   .byte $a0 ; 
TabWrkLight_Pole_MoveStep_0     = $00 ; 
TabWrkLight_Pole_MoveStep_1     = $01 ; 
TabWrkLight_Pole_MoveStep_2     = $02 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawLightningMachine      Does    : draw the castle room lightning machines
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawLightningMachine       .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; save the data pointer of this lightning machine
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabWrkLight_DataPtr_Lo      ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabWrkLight_DataPtr_Hi      ; 
                            
                            lda #CC_LightMach_Off_Orb_00    ; get initial value
                            sta TabWrkLight_Orb_WA          ; init actual offset orb working area
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this lightning machine
; --------------------------------------------------------------------------------------------------------------------- ;
GetNext_LM_Mode             ldy #CC_LightMach               ; get offset lighting machine status
                            lda (CCZ_DrawItemDataPtr),y     ; get lighting machine status
                            bit TabFlagLight_EoD            ; test CC_LightMach_EoD
                            beq RoomLightMach               ; check: CC_LightMach_EoD - no: handle lightning machine
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte EndOfLightMacData and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawLightningMachineX       ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this lightning machine
; --------------------------------------------------------------------------------------------------------------------- ;
RoomLightMach               jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda TabWrkLight_Orb_WA          ; get actual offset orb working area
                            sta CC_WA_Item_Light_Orb_DataOff,x ; set offset this lightning machine orb in castle data
                            
                            ldy #CC_LightMach_Mode          ; get offset mode
                            lda (CCZ_DrawItemDataPtr),y     ; get mode
                            bit TabFlagLight_Switch         ; test switch
                            beq DrawOrbPole                 ; check: switch - no: is orb
; --------------------------------------------------------------------------------------------------------------------- ;
; switch frame: int draw item parms and draw
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_LightMach_Switch_PosX   ; get offest switch PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get switch PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_LightMach_Switch_PosY   ; get offest switch PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get switch PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_LightSwitch        ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the switch frame PosX/PosY to the knob PosX/PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc #$04                        ; sub room draw grid width - step one room grid position left
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item type_0 parm: PosX
                            
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            lda #CC_WA_ItemDef_Type_LightCtrl ; 
                            sta CC_WA_ItemDef_Type,x        ; set sub_type switch in new work area
                            
                            ldy #$00                        ; get offset mode
                            lda (CCZ_DrawItemDataPtr),y     ; get light mach mode
                            bit TabFlagLight_Switch_Up      ; test switch position up
                            bne GetItemSwitch_Up            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; switch is down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_LightSwitch_Do     ; 
                            jmp SetSwitchItemSel            ; set the selected switch item parm
; --------------------------------------------------------------------------------------------------------------------- ;
; switch is up
; --------------------------------------------------------------------------------------------------------------------- ;
GetItemSwitch_Up            lda #ItemNum_LightSwitch_Up     ; 
                            
SetSwitchItemSel            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            jmp SetNextLightMachOrb_WA_Off  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; light orb pole: int draw item parms and draw
; --------------------------------------------------------------------------------------------------------------------- ;
DrawOrbPole                 lda #CC_WA_ItemDef_Type_LightOrb; 
                            sta CC_WA_ItemDef_Type,x        ; set sub_type orb in new work area
                            
                            ldy #CC_LightMach_Pole_PosX     ; get offest orb PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get orb PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_LightMach_Pole_PosY     ; get offest orb PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get orb PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_LightPole          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            ldy #CC_LightMach_Pole_Len      ; get offset orb pole length
                            lda (CCZ_DrawItemDataPtr),y     ; get orb pole length
                            sta TabWrkLight_Draw_Pole_Len   ; set actual orb pole length
                            sta CC_WA_Item_Light_Pole_Len,x ; set new work area orb pole length
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the pole item pieces
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextOrbPole             lda TabWrkLight_Draw_Pole_Len   ; get actual orb pol length
                            beq DrawNextOrb                 ; check: min - yes: care for the orb at end of pole
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pole PosY to next orb pole row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            dec TabWrkLight_Draw_Pole_Len   ; discount orb pole length
                            jmp DrawNextOrbPole             ; continue draw orb pole
; --------------------------------------------------------------------------------------------------------------------- ;
; light orb: retreat the orb PosX one grid position - init draw item parms and draw the orb
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextOrb                 sec                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            sbc #$04                        ; sub room draw grid width - step one room grid position left
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item type_0 parm: PosX
                            
                            lda #ItemNum_LightOrb           ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            
                            ldy #CC_LightMach_Mode          ; get offset orb mode
                            lda (CCZ_DrawItemDataPtr),y     ; get orb mode
                            bit TabFlagLight_Orb_On         ; test orb switched on
                            beq SetNextLightMachOrb_WA_Off  ; check: EQ - no: bypass set flag
; --------------------------------------------------------------------------------------------------------------------- ;
; insert flag work area inactive
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set next orb number
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextLightMachOrb_WA_Off  clc                             ; 
                            lda TabWrkLight_Orb_WA          ; get actual offset orb working area
                            adc #CC_WA_Item_Len             ; add work area length
                            sta TabWrkLight_Orb_WA          ; set new actual offset orb working area
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next lightning machine data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_LightMachItem_Len       ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc TryNextLightMach            ; check: overflow
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
TryNextLightMach            jmp GetNext_LM_Mode             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawLightningMachineX       pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkLight_Orb_WA          .byte $95 ; offset orb working area
TabWrkLight_Draw_Pole_Len   .byte $80 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerLightSwitch         Does    : a player switches a lighning machine orb on/off
;                           Expects : .X=offset sprite work area
;                                   : .Y=relative offset lightning machine switch work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerLightSwitch          .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; only players can switch a lighning machine switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne GoPlayerLightSwitchX        ; check: CC_WA_Sprite_Type_Player - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; test if sprite touches the lighning machine switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get player sprite PosX
                            adc CC_WA_Sprite_Width,x        ; add player sprite width
                            
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; sub switch PosX
                            cmp #$04                        ; test lightning maachine switch width
                            bcs GoPlayerLightSwitchX        ; check: GE - yes: not on ywitch - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; switch a switch only by moving the joystick up or down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Move_Subst,x   ; 
                            beq Was_Up_Do                   ; check: CC_WA_Sprite_Move_Subst_Up - yes: was up
                            
                            cmp #CC_WA_Sprite_Move_Subst_D  ; test move down
                            beq Was_Up_Do                   ; chech: EQ - yes: was down
                            
GoPlayerLightSwitchX        jmp PlayerLightSwitchX          ; ignore all other moves
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
Was_Up_Do                   lda #TabWrkLight_Switch_Orb_Off_Min ; get initial value
                            sta TabWrkLight_Switch_Orb_Off  ; init offset switch orb selection releative work area list (max $04)
; --------------------------------------------------------------------------------------------------------------------- ;
; set lightning machine data pointer for the selected lightning machine
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkLight_DataPtr_Lo      ; 
                            adc CC_WA_Item_Light_Orb_DataOff,y ; add offset lightning machine orb in castle data
                            sta CCZ_LightSwitchDataPtr_Lo   ; 
                            
                            lda TabWrkLight_DataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_LightSwitchDataPtr_Hi   ; 
                            
                            sty TabWrkLight_Switch_Off      ; save light switch work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
; test switch position
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_LightMach_Mode          ; get offset switch mode
                            lda (CCZ_LightSwitchDataPtr),y  ; get switch mode
                            bit TabFlagLight_Switch_Up      ; test switch up
                            bne LightSwitch_Up              ; check: EQ - yes: up
; --------------------------------------------------------------------------------------------------------------------- ;
; switch is down - only move up is allowed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Move_Subst,x   ; 
                            bne GoPlayerLightSwitchX        ; check: CC_WA_Sprite_Move_Subst_D - yes: not allowed - exit
                            
                            jmp SwitchTheSwitch             ; flag the selected switch position
; --------------------------------------------------------------------------------------------------------------------- ;
; switch is up - only move down is allowed
; --------------------------------------------------------------------------------------------------------------------- ;
LightSwitch_Up              lda CC_WA_Sprite_Move_Subst,x   ; 
                            beq GoPlayerLightSwitchX        ; CC_WA_Sprite_Move_Subst_Up - yes: not allowed - exit
                            
SwitchTheSwitch             lda (CCZ_LightSwitchDataPtr),y  ; 
                            eor TabFlagLight_Switch_Up      ; flip switch position
                            sta (CCZ_LightSwitchDataPtr),y  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; go throught the lightning machine data and work area entries to update the switch status
; --------------------------------------------------------------------------------------------------------------------- ;
CheckNextSwitchListEntry    lda TabWrkLight_Switch_Orb_Off  ; get offset switch orb selection releative work area list (max $04)
                            cmp #TabWrkLight_Switch_Orb_Off_Max + $01 ; test max
                            bcs GoSetSwitchSfx              ; check: GE - yes: EndOfSwitchOrbList
; --------------------------------------------------------------------------------------------------------------------- ;
; point to next switch entry in lighning machine orb switch list
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda #CC_LightMach_Switch_Orb    ; get offset orb switch selection list
                            adc TabWrkLight_Switch_Orb_Off  ; add offset switch orb selection releative work area list (max $04)
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; check end of switch list
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CCZ_LightSwitchDataPtr),y  ; 
                            cmp #CC_LightMach_Off_Orb_None  ; test no orb selected
                            bne SetLightMacDataPtr          ; check: EQ - no: handle it
                            
GoSetSwitchSfx              jmp SetSwitchSfx                ; end of switch list reached - set the matching sfx
; --------------------------------------------------------------------------------------------------------------------- ;
; set lightning machine data pointer to the selected orb data entry
; --------------------------------------------------------------------------------------------------------------------- ;
SetLightMacDataPtr          sta TabWrkLight_Switch_Orb_Rel  ; set actual switch entry offset in lighning machine orb switch list
                            
                            clc                             ; 
                            adc TabWrkLight_DataPtr_Lo      ; 
                            sta CCZ_LightOrbDataPtr_Lo      ; 
                            
                            lda TabWrkLight_DataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_LightOrbDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; flip lightning machine mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_LightMach_Mode          ; get offset lightning machine mode
                            lda (CCZ_LightOrbDataPtr),y     ; get lightning machine mode
                            eor TabFlagLight_Orb_On         ; flip lightning machine mode
                            sta (CCZ_LightOrbDataPtr),y     ; aet new lightning machine mode
                            
                            ldy #$00                        ; 
CheckNextOrb_WA             lda CC_WA_ItemDef_Type,y        ; get work area type
                            cmp #CC_WA_ItemDef_Type_LightOrb; test type orb
                            bne SetNextOrb_WA_Entry         ; check: EQ - no: try next work area
                            
                            lda CC_WA_Item_Light_Orb_DataOff,y ; 
                            cmp TabWrkLight_Switch_Orb_Rel  ; test with actual switch entry offset in lighning machine orb switch list
                            beq SetFlagOrb_WA_Inact         ; check: EQ - yes: mark it
                            
SetNextOrb_WA_Entry         tya                             ; 
                            clc                             ; 
                            adc #CC_WA_ItemDef_Len          ; add work area length
                            tay                             ; 
                            
                            jmp CheckNextOrb_WA             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark this work area as inactive
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagOrb_WA_Inact         lda CC_WA_ItemDef_Status,y      ; 
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,y      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set next entry number in lighning machine orb switch list
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkLight_Switch_Orb_Off  ; inc offset switch orb selection releative work area list (max $04)
                            jmp CheckNextSwitchListEntry    ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set the switch sound effect for the selected switch position
; --------------------------------------------------------------------------------------------------------------------- ;
SetSwitchSfx                ldy #CC_LightMach_Mode          ; get offset lightning machine mode
                            lda (CCZ_LightSwitchDataPtr),y  ; get lightning machine mode from room data
                            bit TabFlagLight_Orb_On         ; test flag orb switched on
                            bne SetSitch_Up                 ; check: orb on - no
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare switch down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$2f                        ; 
                            sta TabSFX_LightSwitch_Tone     ; set sfx
                            
                            lda #ItemNum_LightSwitch_Do     ; get item number
                            jmp DrawSwitchItem              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare switch up
; --------------------------------------------------------------------------------------------------------------------- ;
SetSitch_Up                 lda #$23                        ; 
                            sta TabSFX_LightSwitch_Tone     ; set sfx
                            
                            lda #ItemNum_LightSwitch_Up     ; get item number
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the selected switch item
; --------------------------------------------------------------------------------------------------------------------- ;
DrawSwitchItem              sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            ldy TabWrkLight_Switch_Off      ; get light switch work area offset
                            lda CC_WA_ItemDef_PosX,y        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda CC_WA_ItemDef_PosY,y        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            stx TabWrkLight_Sprt_WA_Off     ; save sprite work area offset
                            
                            ldx TabWrkLight_Switch_Off      ; get light switch work area offset
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            
                            ldx TabWrkLight_Sprt_WA_Off     ; restore sprite work area offset
                            ldy TabWrkLight_Switch_Off      ; get light switch work area offset
                            
                            lda #NumSfx_LightSwitch         ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
                            
PlayerLightSwitchX          jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkLight_Switch_Orb_Off  .byte $99 ; offset switch orb selection releative work area list (max $04)
TabWrkLight_Switch_Orb_Off_Min  = $00 ; 
TabWrkLight_Switch_Orb_Off_Max  = $03 ; 
TabWrkLight_Switch_Off      .byte $80 ; switch work area offset
TabWrkLight_Sprt_WA_Off     .byte $a0 ; sprite work area offset
TabWrkLight_Switch_Orb_Rel  .byte $c8 ; switch entry offset in lighning machine orb switch list
TabWrkLight_DataPtr_Lo      .byte $a0 ; save lighning machine data pointer lo
TabWrkLight_DataPtr_Hi      .byte $ce ; save lighning machine data pointer hi
TabFlagLight_Switch         .byte $80 ; flag: switch
TabFlagLight_Switch_Up          = *   ; flag: switch points upwards
TabFlagLight_Orb_On         .byte $40 ; flag: orb switched on
TabFlagLight_EoD            .byte $20 ; flag: end of lighning machine data
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemForceFieldClose       Does    : handle the closing of a force field
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset item work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemForceFieldClose        .block                           ; 
                            dec CC_WA_ItemForce_PingTime,x  ; dec time between two field closing pings
                            bne ItemForceFieldCloseX        ; check: min - no: nothing to do - exit
                            
                            dec CC_WA_ItemForce_CloseStep,x ; dec force field close step count
                            
                            ldy CC_WA_ItemForce_CloseStep,x ; get force field close step count
                            lda TabForce_TimePing_Tone,y    ; get next step ping tone from table
                            sta TabSFX_ForcePing_Tone       ; set new step ping tone
                            
                            lda #NumSfx_ForceFieldPing      ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
; refill the force field button center bottom up 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; init offset force field switch interior fill step
FillNextForceButtonFiller   tya                             ; get actual force field switch interior fill step
                            cmp CC_WA_ItemForce_CloseStep,x ; test with force field close step count
                            bcc GetForceButtonFill_Clear    ; check: LT - yes: get clear filler value for the remaining steps
                            
                            lda #$55                        ; get fill value for the close steps
                            jmp SetForceButtonFill          ; 
                            
GetForceButtonFill_Clear    lda #$00                        ; get clear value for the remaining steps
                            
SetForceButtonFill          sta TabDataForceFieldTime,y     ; set the selected force field switch interior value
                            
                            iny                             ; inc actual force field switch interior fill step
                            cpy #TabDataForceFieldTime_Len  ; test max
                            bcc FillNextForceButtonFiller   ; check: LT: yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the force field button interior
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_PosX,x        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda CC_WA_ItemDef_PosY,x        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_ForceFieldTimer    ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; check if force field is closed completely
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemForce_CloseStep,x ; get force field close step count
                            beq ItemForceFieldClose_Exit    ; check: min - yes: 
                            
                            lda #CC_WA_ItemForce_PingTime_Ini ; get initial value
                            sta CC_WA_ItemForce_PingTime,x  ; init wait time between each ping
                            
                            jmp ItemForceFieldCloseX        ; exit
; --------------------------------------------------------------------------------------------------------------------- ;
; force field is closed again - set indicator flags
; --------------------------------------------------------------------------------------------------------------------- ;
ItemForceFieldClose_Exit    lda CC_WA_ItemDef_Status,x      ; 
                            eor TabItem_WA_Flag_Ready       ; flip flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
                            
                            ldy CC_WA_ItemForce_Num,x       ; get offset force field number
                            lda #TabWrkForce_Mode_Shut      ; get flag force field closed
                            sta TabWrkForce_Mode,y          ; set new force field mode in mode table
                            
ItemForceFieldCloseX        jmp RoomItemHandler.RTS_RoomItemHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerForceFieldSwitch    Does    : 
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset item work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerForceFieldSwitch     .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; only a player can press a force field switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne PlayerForceFieldSwitchX     ; check: CC_WA_Sprite_Type_Player - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check fire button status
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_FireButton,x   ; get status fire button
                            beq PlayerForceFieldSwitchX     ; check: pressed - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; init ping tone and ping
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0c                        ; get initial value
                            sta TabSFX_ForcePing_Tone       ; init force field ping tone
                            
                            lda #NumSfx_ForceFieldPing      ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
; reset force field status
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,y      ; 
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,y      ; 
                            
                            lda #CC_WA_ItemForce_PingTime_Ini ; get initial value
                            sta CC_WA_ItemForce_PingTime,y  ; init wait time between pings
; --------------------------------------------------------------------------------------------------------------------- ;
; init force field switch values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabDataForceFieldTime_Len  ; get initial value
                            sta CC_WA_ItemForce_CloseStep,y ; init force field close step count
                            
                            lda #$55                        ; get closed fill value
                            sta TabDataForceFieldTimeTick_8 ; fill switch button interior
                            sta TabDataForceFieldTimeTick_7 ; 
                            sta TabDataForceFieldTimeTick_6 ;  
                            sta TabDataForceFieldTimeTick_5 ; 
                            sta TabDataForceFieldTimeTick_4 ; 
                            sta TabDataForceFieldTimeTick_3 ; 
                            sta TabDataForceFieldTimeTick_2 ; 
                            sta TabDataForceFieldTimeTick_1 ; 
                            
                            lda CC_WA_ItemDef_PosX,y        ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            lda CC_WA_ItemDef_PosY,y        ; 
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda CC_WA_ItemDef_ItemNum,y     ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
                            
                            lda CC_WA_ItemForce_Num,y       ; get offset force field number
                            tay                             ; set as table offset
                            lda #TabWrkForce_Mode_Open      ; get flag force field open
                            sta TabWrkForce_Mode,y          ; set new force field mode in mode table
                            
PlayerForceFieldSwitchX     jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawForceField            Does    : draw the castle room force fields
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawForceField             .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta TabWrkForce_Num             ; init actual force field number
                            
GetNextForceFieldSwitchPosX ldy #CC_ForceField              ; get offset force field data status
                            lda (CCZ_DrawItemDataPtr),y     ; get force field data status
                            bne ForceFieldDraw              ; check: flag CC_ForceField_EoD - no: handle force field
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte EndOfPoleData and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawForceFieldX             ; exit - all done
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this force filed
; --------------------------------------------------------------------------------------------------------------------- ;
ForceFieldDraw              jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_ForceField ; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as force field
; --------------------------------------------------------------------------------------------------------------------- ;
; draw force field switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_ForceField_Switch_PosX  ; get offset switch PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_ForceField_Switch_PosY  ; get offset switch PosY
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_ForceFieldSwitch   ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; draw force field timer - advance the switch frame PosX/PosY to the timer PosX/PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc #$04                        ; sub room draw grid width - step one room grid position left
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item type_0 parm: PosX
                            
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            lda #ItemNum_ForceFieldTimer    ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; fully color the timer switch interior
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabDataForceFieldTime_Len - $01 ; 
                            lda #$55                        ; 
FillNextTimeTick            sta TabDataForceFieldTime,y     ; 
                            
                            dey                             ; 
                            bpl FillNextTimeTick            ; check: 
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            
                            lda TabWrkForce_Num             ; get actual force field number
                            sta CC_WA_ItemForce_Num,x       ; set new force field number in work area
; --------------------------------------------------------------------------------------------------------------------- ;
; close the force field
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; set actual force field number as mode table offset
                            lda #TabWrkForce_Mode_Shut      ; get flag force field shut
                            sta TabWrkForce_Mode,y          ; mark force field shut in mode table
                            
                            jsr ForceSpriteInitField_WA     ; alloc and init a force field sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; draw force field head
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_ForceField_Emitter_PosX ; 
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_ForceField_Emitter_PosY ; 
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_ForceFieldHead     ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; set next force field number
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkForce_Num             ; inc actual force field number
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next force field data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_ForceFieldItem_Len      ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc TryNextForceField           ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
TryNextForceField           jmp GetNextForceFieldSwitchPosX ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawForceFieldX             pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkForce_Num             .byte $ba ; actual force file number
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkForce_Mode            = *       ; table for the actual mode of all possible force fields
TabWrkForce_Mode_Open           = $00 ; 
TabWrkForce_Mode_Shut           = $01 ; 
                            .byte $a0 ; $00
                            .byte $a4 ; $01
                            .byte $b2 ; $02
                            .byte $fe ; $03
                            .byte $a0 ; $04
                            .byte $a0 ; $05
; --------------------------------------------------------------------------------------------------------------------- ;
TabForce_TimePing_Tone      = *       ; 
                            .byte $3a ; 
                            .byte $39 ; 
                            .byte $37 ; 
                            .byte $35 ; 
                            .byte $33 ; 
                            .byte $32 ; 
                            .byte $30 ; 
                            .byte $2e ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemMummyAnkhFlash        Does    : handle the mummy ankh flashes
;                           Expects : .X=offset mummy work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemMummyAnkhFlash         .block                           ; 
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$03                        ; isolate mummy delay count
                            bne ItemMummyAnkhFlashX         ; check: EQ - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; dec and check ankh flash timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CC_WA_Item_Mummy_AnkhTimer,x ; discount ankh timer value
                            bne GetAnkhColor                ; check: min - no: get actual color
; --------------------------------------------------------------------------------------------------------------------- ;
; deactivate flash ankh processing
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            eor TabItem_WA_Flag_Ready       ; flip flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
                            
                            jmp GetAnkhColor_Blue           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetAnkhColor                lda CC_WA_Item_Mummy_Ankh_Color,x ; get actual ankh color
                            cmp #HR_BLUE_BLUE               ; test blue
                            bne GetAnkhColor_Blue           ; check: EQ - no: get ankh color blue
                            
                            lda #HR_WHITE_WHITE             ; get ankh color white
                            jmp IniAnkhColorLen             ; 
                            
GetAnkhColor_Blue           lda #HR_BLUE_BLUE               ; get ankh color blue
; --------------------------------------------------------------------------------------------------------------------- ;
; recolor ankh item
; --------------------------------------------------------------------------------------------------------------------- ;
IniAnkhColorLen             ldy #TabDataMummyAnkhColor_Len  ; get ankh color offset
SetNextAnkhColor            sta TabDataMummyAnkhColor,y     ; 
                            
                            dey                             ; dec ankh color offset
                            bpl SetNextAnkhColor            ; check: min: no - continue
; --------------------------------------------------------------------------------------------------------------------- ;
; save actual color value
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta CC_WA_Item_Mummy_Ankh_Color,x ; store selected ankh color
; --------------------------------------------------------------------------------------------------------------------- ;
; redraw ankh item
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_PosX,x        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda CC_WA_ItemDef_PosY,x        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda CC_WA_ItemDef_ItemNum,x     ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            
ItemMummyAnkhFlashX         jmp RoomItemHandler.RTS_RoomItemHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerMummyAnkhTouch      Does    : a player touches a mummy ankh
;                           Expects : .X=offset player sprite work area
;                                   : .Y=offset this mummy work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerMummyAnkhTouch       .block                           ; 
                            stx TabWrkMummy_Sprt_WA_Off     ; save offset player sprite work area
                            sty TabWrkMummy_Item_WA_Off     ; save offset mummy work area
; --------------------------------------------------------------------------------------------------------------------- ;
; only players can bring a mummy to live
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne GoPlayerMummyAnkhTouchX     ; check: player - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player sprite touches the ankh
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get player PosX
                            adc CC_WA_Sprite_Width,x        ; 
                            
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; sub ankh PosX
                            cmp #$08                        ; test ankh width
                            bcs GoPlayerMummyAnkhTouchX     ; check: GE - yes: not on ankh position - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set this mummy castle data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkMummy_DataPtr_Lo      ; 
                            adc CC_WA_Item_Mummy_DataOff,y  ; add this mummy castle data offset
                            sta CCZ_MummyDataPtr_Lo         ; 
                            
                            lda TabWrkMummy_DataPtr_Hi      ; 
                            adc #$00                        ; add carry
                            sta CCZ_MummyDataPtr_Hi         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if mummy still rests in his tomb
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Mummy_Status            ; get offset mummy status
                            lda (CCZ_MummyDataPtr),y        ; get mummy status from castle data
                            cmp #CC_Mummy_Status_In         ; test with flag mummy still in his tomb
                            beq SetMummyStatusOut           ; check: in tomb - yes: get him out
                            
GoPlayerMummyAnkhTouchX     jmp PlayerMummyAnkhTouchX       ; mummy is already out - nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; switch mummy status
; --------------------------------------------------------------------------------------------------------------------- ;
SetMummyStatusOut           lda #CC_Mummy_Status_Out        ; get flag mummy has left the tomb
                            ldy #CC_Mummy_Status            ; get offset mummy status
                            sta (CCZ_MummyDataPtr),y        ; set new mummy status in castle data
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize tomb open wall and mummy sprite positions
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldy #CC_Mummy_Tomb_PosX         ; get offset tomb wall PosX
                            lda (CCZ_MummyDataPtr),y        ; get tomb wall PosX
                            adc #$04                        ; add open wall column offset
                            
                            ldy #CC_Mummy_Sprt_PosX         ; get offset sprite PosX
                            sta (CCZ_MummyDataPtr),y        ; set sprite PosX
                            
                            clc                             ; 
                            ldy #CC_Mummy_Tomb_PosY         ; get offset tomb wall PosY
                            lda (CCZ_MummyDataPtr),y        ; get tomb wall PosY
                            adc #$07                        ; add open wall row offset
                            
                            ldy #CC_Mummy_Sprt_PosY         ; get offset sprite PosY
                            sta (CCZ_MummyDataPtr),y        ; set sprite PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; mark mummy work area as ready to be dispatched
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkMummy_Item_WA_Off     ; get offset mummy work area
                            lda CC_WA_ItemDef_Status,y      ; get work area status
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,y      ; set new work area status
; --------------------------------------------------------------------------------------------------------------------- ;
; init ankh flash values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Item_Mummy_AnkhTimer_Ini ; get initial value
                            sta CC_WA_Item_Mummy_AnkhTimer,y; ini ankh flash timer
                            
                            lda #HR_BLUE_BLUE               ; get initial value
                            sta CC_WA_Item_Mummy_Ankh_Color,y ; init ankh flash color
; --------------------------------------------------------------------------------------------------------------------- ;
; set the open tomb item position to the the 2nd tomb brick row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Mummy_Tomb_PosX         ; get offset mummy tomb PosX
                            lda (CCZ_MummyDataPtr),y        ; get mummy tomb PosX
                            
                            clc                             ; 
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            ldy #CC_Mummy_Tomb_PosY         ; get offset mummy tomb PosY
                            lda (CCZ_MummyDataPtr),y        ; get mummy tomb PosY
                            
                            clc                             ; 
                            adc #$08                        ; add room draw grid height - step one room grid position down
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the 2nd mummy tomb wall - prepare for open tomb item
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$03                        ; get initial value
                            sta TabWrkMummy_TombWall_Cols   ; init tomb wall column counter
                            
                            lda #ItemNum_MummyWall          ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the mummy tomb wall row
; --------------------------------------------------------------------------------------------------------------------- ;
ClearNextMummyWallBrick     jsr RoomItemDraw                ; draw the selected room item
                            
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            dec TabWrkMummy_TombWall_Cols   ; dec tomb wall column counter
                            bne ClearNextMummyWallBrick     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; draw one mummy tomb open wall item into selected tomb wall row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_MummyTombOpen      ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            sec                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            sbc #$04 * $03                  ; sub room triple draw grid width - step three room grid position left
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda TabWrkDraw_T1_Parm_ItemPosY ; get draw item type_1 parm: PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; init the mummy sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkMummy_Item_WA_Off     ; get offset mummy work area
                            lda #TabFlagMummy_WA_Init       ; get flag init mummy sprite work area
                            jsr MummySprite_WA_Handler      ; init mummy sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; restore the parms and exit
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerMummyAnkhTouchX       ldx TabWrkMummy_Sprt_WA_Off     ; 
                            ldy TabWrkMummy_Item_WA_Off     ; 
                            jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkMummy_Sprt_WA_Off     .byte $ff ; 
TabWrkMummy_Item_WA_Off     .byte $a0 ; 
TabWrkMummy_TombWall_Cols   .byte $b5 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawMummy                 Does    : draw a mummy tomb and ankh
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawMummy                  .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta TabWrkMummy_Castle_Data_Off ; init actual mummy castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; save data pointer mummy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabWrkMummy_DataPtr_Lo      ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabWrkMummy_DataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw mummy tomb and ankh
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextMummy               ldy #CC_Mummy_Status            ; get offset mummy status
                            lda (CCZ_DrawItemDataPtr),y     ; get mummy status from castle data
                            cmp #CC_Mummy_EoD               ; test flag CC_Mummy_EoD
                            bne MummyIni_WA                 ; check: end of mummy data - no: handle mummy
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte CC_Mummy_EoD and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawMummyX                  ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get and init mummy work area
; --------------------------------------------------------------------------------------------------------------------- ;
MummyIni_WA                 jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_Mummy   ; get offset work area type
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as mummy
; --------------------------------------------------------------------------------------------------------------------- ;
; draw mummy ankh
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Mummy_Ankh_PosX         ; get offset ankh PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get ankh PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Mummy_Ankh_PosY         ; get offset ankh PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get ankh PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_MummyAnkh          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda TabWrkMummy_Castle_Data_Off ; get actual mummy castle data offset
                            sta CC_WA_Item_Mummy_DataOff,x  ; set this mummy castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; init ankh item color and draw ankh item
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabDataMummyAnkhColor_Len  ; 
                            lda #HR_BLUE_BLUE               ; get ankh color
                            sta CC_WA_Item_Mummy_Ankh_Color,x ; set new work area ankh color
SetNextAnkhColor            sta TabDataMummyAnkhColor,y     ; 
                            
                            dey                             ; dec color length
                            bpl SetNextAnkhColor            ; check: min - no: continue
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; draw mummy tomb wall - 3 rows with 5 bricks each
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkMummy_Wall_RowNum_Max; get initial value
                            sta TabWrkMummy_Wall_RowNum     ; set mummy tomb wall row count
                            
                            ldy #CC_Mummy_Tomb_PosY         ; get offset mummy tomb PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get mummy tomb PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_MummyWall          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
IniNextMummyTombWallRow     lda #TabWrkMummy_Wall_BrickNum_Max ; get initial value
                            sta TabWrkMummy_Wall_BrickNum   ; set actual mummy tomb wall number of bricks per row
                            
                            ldy #CC_Mummy_Tomb_PosX         ; get offset tomb wall PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get tomb wall PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; draw a tomb wall brick
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextMummyTombWallBrick  jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the tomb wall PosX to next wall column
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc #$04                        ; sub room draw grid width - step one room grid position left
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item type_0 parm: PosX
                            
                            dec TabWrkMummy_Wall_BrickNum   ; dec actual mummy tomb wall number of bricks per row
                            bne DrawNextMummyTombWallBrick  ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the tomb wall PosY to next wall row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            dec TabWrkMummy_Wall_RowNum     ; dec mummy tomb wall row count
                            bne IniNextMummyTombWallRow     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; check if mummy has already left his tomb
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Mummy_Status            ; get offset mummy status
                            lda (CCZ_DrawItemDataPtr),y     ; get mummy status
                            cmp #CC_Mummy_Status_In         ; test mummy still in tomb
                            beq AdvanceMummyDataPtr         ; check: EQ - yes: set data pointer to next mummy entry
; --------------------------------------------------------------------------------------------------------------------- ;
; mummy has left the tomb - prepare draw open wall - advance mummy wall pointer to tomb opening
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Mummy_Tomb_PosX         ; get offset tomb wall PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get tomb wall PosX
                            
                            clc                             ; 
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set new draw item type_1 parm: PosX
                            
                            ldy #CC_Mummy_Tomb_PosY         ; get offset mummy tomb PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get mummy tomb PosY
                            
                            clc                             ; 
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; carve an open hole into the tomb wall - delete the bricks
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_MummyWall          ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #TabWrkMummy_Wall_RowNum_Max; 
                            sta TabWrkMummy_Wall_RowNum     ; set mummy tomb wall row count
                            
DelNextMummyTombWallBrick   jsr RoomItemDraw                ; draw the selected room item
                            
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set new draw item type_1 parm: PosX
                            
                            dec TabWrkMummy_Wall_RowNum     ; dec mummy tomb wall row count
                            bne DelNextMummyTombWallBrick   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill the now open hole with tomb ground
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            sec                             ; 
                            sbc #$04 * TabWrkMummy_Wall_RowNum_Max ; sub triple room draw grid width - step three room grid position left
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item type_0 parm: PosX item type_0
                            
                            lda TabWrkDraw_T1_Parm_ItemPosY ; get draw item type_1 parm: PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_MummyTombOpen      ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; check if mummy has already left its tomb
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Mummy_Status            ; get offset mummy status
                            lda (CCZ_DrawItemDataPtr),y     ; get mummy status
                            cmp #CC_Mummy_Status_Out        ; test with fla mummy has left
                            bne AdvanceMummyDataPtr         ; check: EQ - no: bypass sprite setup
                            
                            lda #TabFlagMummy_WA_Read       ; get flag read mummy sprite postion from mummy data
                            jsr MummySprite_WA_Handler      ; read mummy sprite position from mummy sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next mummy data entry
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceMummyDataPtr         lda CCZ_DrawItemDataPtr_Lo      ; 
                            clc                             ; 
                            adc #CC_MummyItem_Len           ; add mummy data length
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc AdvanceMummy_WA_Off         ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance mummy castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceMummy_WA_Off         clc                             ; 
                            lda TabWrkMummy_Castle_Data_Off ; get actual mummy castle data offset
                            adc #CC_MummyItem_Len           ; add work area lenght
                            sta TabWrkMummy_Castle_Data_Off ; set new actual mummy castle data offset
                            
                            jmp DrawNextMummy               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawMummyX                  pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkMummy_DataPtr_Lo      .byte $a0 ; 
TabWrkMummy_DataPtr_Hi      .byte $cc ; 
TabWrkMummy_Castle_Data_Off .byte $a5 ; mummy castle data offset
TabWrkMummy_Wall_RowNum     .byte $90 ; mummy tomb wall row count
TabWrkMummy_Wall_RowNum_Max     = $03 ; 
TabWrkMummy_Wall_BrickNum   .byte $a0 ; mummy tomb wall number of bricks per row
TabWrkMummy_Wall_BrickNum_Max   = $05 ;
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerKeyPick             Does    : a player picks up a key
;                           Expects : .X=offset player sprite work area
;                                   : .Y=offset key work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerKeyPick              .block                           ; 
                            sty TabWrkKey_WA_Off_Save       ; save offset key work area
; --------------------------------------------------------------------------------------------------------------------- ;
; only players can pick up a key ...
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne PlayerKeyPickX              ; check: CC_WA_Sprite_Type_Player - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; ... but only if is in the room ... 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_Sprite_PlayerNum,x    ; 
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne PlayerKeyPickX              ; check: arrived - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; ... and only if he wants it
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_FireButton,x   ; 
                            beq PlayerKeyPickX              ; check: pressed - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; ini key pick sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #NumSfx_KeyPick             ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
; mark key as gone
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkKey_WA_Off_Save       ; restore offset key work area
                            lda CC_WA_ItemDef_Status,y      ; get key status
                            ora TabItem_WA_Flag_Gone        ; insert flag CC_WA_ItemDef_Status_Gone
                            sta CC_WA_ItemDef_Status,y      ; set new key status
; --------------------------------------------------------------------------------------------------------------------- ;
; init key room data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkKey_DataPtr_Lo        ; 
                            adc CC_WA_Item_Key_DataOff,y    ; 
                            sta CCZ_KeyDataPtr_Lo           ; 
                            
                            lda TabWrkKey_DataPtr_Hi        ; 
                            adc #$00                        ; add carry
                            sta CCZ_KeyDataPtr_Hi           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear key in room data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Key_Status              ; get offset key status
                            lda #CC_Key_Status_Avail_No     ; get status key was taken
                            sta (CCZ_KeyDataPtr),y          ; set new status in room data
                            
                            ldy #CC_Key_Color               ; get offset key color
                            lda (CCZ_KeyDataPtr),y          ; get key color
                            sta TabWrkKey_Color             ; set picked key color
                            
                            lda CC_WA_Sprite_PlayerNum,x    ; get player number
                            beq UpdatePickeKeyList_P1       ; check: player #1 - yes: handle him
; --------------------------------------------------------------------------------------------------------------------- ;
; insert picked key into list of collected keys for player #2
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_GameDataVar_Keys_Got_P2  ; get player #2 picked key count from castle data variables
                            
                            inc CC_GameDataVar_Keys_Got_P2  ; inc player #2 picked key count
                            
                            lda TabWrkKey_Color             ; get picked key color
                            sta CC_GameDataVar_Keys_Buf_P2,y; set picked key color in player #2 castle variables key buffer
                            
                            jmp PlayerKeyPickX              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; insert picked key into list of collected keys for player #1
; --------------------------------------------------------------------------------------------------------------------- ;
UpdatePickeKeyList_P1       ldy CC_GameDataVar_Keys_Got_P1  ; get player #1 picked key count from castle data variables
                            
                            inc CC_GameDataVar_Keys_Got_P1  ; inc player #1 picked key count
                            
                            lda TabWrkKey_Color             ; get picked key color
                            sta CC_GameDataVar_Keys_Buf_P1,y; set picked key color in player #1 castle variables key buffer
                            
PlayerKeyPickX              jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawKey                   Does    : draw the castle room keys of the different colors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawKey                    .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; save data pointer key
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabWrkKey_DataPtr_Lo        ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabWrkKey_DataPtr_Hi        ; 
                            
                            lda #$00                        ; get initial value
                            sta TabWrkKey_Data_Off          ; init actual key castle data offset
                            
DrawNextKey                 ldy #CC_Key                     ; get offset key data
                            lda (CCZ_DrawItemDataPtr),y     ; get key data status flag
                            bne KeyDraw                     ; check: CC_Key_EoD - no: handle key
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer behind flag CC_Key_EoD and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawKeyX                    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this key
; --------------------------------------------------------------------------------------------------------------------- ;
KeyDraw                     ldy #CC_Key_Status              ; get offset key status
                            lda (CCZ_DrawItemDataPtr),y     ; get key status
                            beq AdvanceKeyDataOff           ; check: taken - yes: simply set key data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; key is still available
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_Key     ; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as key
                            
                            ldy #CC_Key_PosX                ; get offset key PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Key_PosY                ; get offset key PosY
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            ldy #CC_Key_Status              ; get offset key status for shape and color
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda TabWrkKey_Data_Off          ; get actual key castle data offset
                            sta CC_WA_Item_Key_DataOff,x    ; set key castle data offset
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; advance offset to key data
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceKeyDataOff           clc                             ; 
                            lda TabWrkKey_Data_Off          ; get actual key castle data offset
                            adc #CC_KeyItem_Len             ; add key daat length
                            sta TabWrkKey_Data_Off          ; set new actual key castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next key data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_KeyItem_Len             ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc DrawNextKey                 ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jmp DrawNextKey                 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawKeyX                    pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkKey_Color             = *       ; picked key color
TabWrkKey_Data_Off          .byte $a0 ; key castle data offset
TabWrkKey_DataPtr_Lo        .byte $98 ; pointer to key in castle room data
TabWrkKey_DataPtr_Hi        .byte $a0 ; 
TabWrkKey_WA_Off_Save       .byte $a0 ; save key work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerDoorUnLock          Does    : a player unlocks a door with the appropriate key
;                           Expects : .X=offset player sprite work area
;                                   : .Y=offset lock work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerDoorUnLock           .block                           ; 
                            stx TabWrkLock_Sprite_WA_Off    ; save player sprite work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
; only a player can unlock a door ...
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne PlayerDoorUnLockX           ; check: CC_WA_Sprite_Type_Player - no
; --------------------------------------------------------------------------------------------------------------------- ;
; ... but only if he has arrived in the room ... 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PlayerNum,x    ; get player number
                            tax                             ; set as offset
                            lda CC_GameDataVar_Flag,x       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne PlayerDoorUnLockX           ; check: arrived - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; ... and only if he wants it
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkLock_Sprite_WA_Off    ; get player sprite work area offset
                            lda CC_WA_Sprite_FireButton,x   ; 
                            beq PlayerDoorUnLockX           ; check: pressed - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; search the picked up key buffer for the required key
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Lock_Color,y     ; get lock color
                            jsr RoomLockSearchKey           ; search the players pocket for a matching key to open the desired lock
                            bcs PlayerDoorUnLockX           ; check: found - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; search matching door work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; init offset work area
GetNext_WA_Type             lda CC_WA_ItemDef_Type,x        ; get work area type
                            bne SetNext_WA_Off              ; check: door - no: try next work area
; --------------------------------------------------------------------------------------------------------------------- ;
; a door work area was found - check if it matches
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Door_Num,x       ; get room door number
                            cmp CC_WA_Item_Lock_Door_Num,y  ; test with lock door number
                            beq CheckDoorStatus             ; check: EQ - yes: matching door found
; --------------------------------------------------------------------------------------------------------------------- ;
; advance work area offset to next work area
; --------------------------------------------------------------------------------------------------------------------- ;
SetNext_WA_Off              txa                             ; get work area offset
                            clc                             ; 
                            adc #CC_WA_ItemDef_Len          ; add work area length
                            tax                             ; set work area offset
                            jmp GetNext_WA_Type             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the matching door is already open
; --------------------------------------------------------------------------------------------------------------------- ;
CheckDoorStatus             lda CC_WA_Item_Door_Status,x    ; get room door status
                            bne PlayerDoorUnLockX           ; check: CC_WA_Item_Door_Status_Open - yes: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; update door work area status to open the door
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
                            
PlayerDoorUnLockX           ldx TabWrkLock_Sprite_WA_Off    ; restore player sprite work area offset
                            jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawLock                  Does    : draw the castle room locks of the different colors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawLock                   .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this lock
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextLock                ldy #CC_Lock                    ; get offset lock data
                            lda (CCZ_DrawItemDataPtr),y     ; get lock data status flag
                            beq DrawNextLock_Exit           ; check: CC_Lock_EoD - yes:
; --------------------------------------------------------------------------------------------------------------------- ;
; get and init lock work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_Lock    ; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as lock
                            
                            ldy #CC_Lock_PosX               ; get offset lock PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Lock_PosY               ; get offset lock PosY
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; color the lock item with the selected color
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Lock_Color              ; get offset lock color
                            lda (CCZ_DrawItemDataPtr),y     ; get lock color
                            asl a                           ; shift color to left nibble
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
                            ora (CCZ_DrawItemDataPtr),y     ; insert color to right nibble - make it a hires color
                            
                            ldy #TabDataLockColor_Len       ; init lock hires color length
SetNextLockItemColor        sta TabDataLockColor,y          ; 
                            
                            dey                             ; dec lock hires color length
                            bpl SetNextLockItemColor        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the now correctly colored lock
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_Lock               ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            ldy #CC_Lock_Color              ; get offset lock color
                            lda (CCZ_DrawItemDataPtr),y     ; get lock color
                            sta CC_WA_Item_Lock_Color,x     ; set lock color in new work area
                            
                            ldy #CC_Lock_TargetDoorNum      ; get offset lock target door number
                            lda (CCZ_DrawItemDataPtr),y     ; get lock target door number
                            sta CC_WA_Item_Lock_Door_Num,x  ; set lock target door number in new work area
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next lock data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_LockItem_Len            ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc DrawNextLock                ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
                            jmp DrawNextLock                ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer behind EndOfLockData and exit
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextLock_Exit           inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne DrawNextLockX               ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextLockX               pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkLock_Sprite_WA_Off    .byte $c2 ; player sprite work area offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RayGunAimLaserHead        Does    : aim the ray gun laser head preferably to the nearest player
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset ray gun work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RayGunAimLaserHead         .block                           ; 
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$03                        ; isolate ray gun delay count
                            beq RayGunAim                   ; check: EQ - yes: time to aim
                            
ItemRayGunAimLaser_Exit     jmp RayGunAimLaserHeadX         ; nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set ray gun data pointer for the selected ray gun
; --------------------------------------------------------------------------------------------------------------------- ;
RayGunAim                   clc                             ; 
                            lda TabWrkGun_DataPtr_Lo        ; 
                            adc CC_WA_Item_Gun_DataOff,x    ; add actual ray gun castle data offset
                            sta CCZ_RayGunDataPtr_Lo        ; 
                            
                            lda TabWrkGun_DataPtr_Hi        ; 
                            adc #$00                        ; add carry
                            sta CCZ_RayGunDataPtr_Hi        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the laser work area has to be initialized
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            bit TabItem_WA_Flag_Init        ; test flag CC_WA_ItemDef_Status_Init
                            beq CheckDemo                   ; check: init - no: let the laser follow a player
                            
                            jmp IniDrawLaserMove            ; continously draw the moving laser
; --------------------------------------------------------------------------------------------------------------------- ;
; if in demo mode the flag castle data load memory points to CC_MemLoadLevelDataBuf
; --------------------------------------------------------------------------------------------------------------------- ;
CheckDemo                   lda TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            cmp #TabFlagDataBufAdr_Load     ; test flag castle data game memory
                            beq ItemRayGunAimLaser_Exit     ; check: demo - yes: exit - no playser available - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; check if a player has halted the laser by standing in front of the control switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Gun_Laser               ; get offset laser status
                            lda (CCZ_RayGunDataPtr),y       ; get laser status
                            bit TabFlagGun_Laser_Halt       ; test flag CC_Gun_Laser_Move_Halt
                            bne CheckLaserMove_Up           ; check: stop - yes: test moves and color the control switch
; --------------------------------------------------------------------------------------------------------------------- ;
; continue letting the laser follow the selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; get initial value of -1
                            sta TabWrkGun_LaserDistY        ; init actual laser PosY distance to actual player PosY
                            
                            lda #CC_Gun_Laser_Move_None     ; get initial value
                            sta TabWrkGun_Laser_MoveDir     ; init laser move direction
                            
                            lda #$01                        ; get player number
                            sta TabWrkGun_PlayerNum         ; start following player #2
; --------------------------------------------------------------------------------------------------------------------- ;
; decide which player the laser will follow
; --------------------------------------------------------------------------------------------------------------------- ;
TestNextPlayer              ldy TabWrkGun_PlayerNum         ; get actual player number to follow
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne SetNextPlayerNum            ; check: alive - no: try next player
                            
                            lda TabWrkPlayer_Sprite_WA,y    ; get this players work area offset
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate the laser distance from the actual player
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda CC_WA_Sprite_PosY,y         ; get actual player PosY
                            sbc CC_WA_ItemDef_PosY,x        ; sub actual laser PosY
                            bcs CheckLaserDist              ; check: GE - yes: laser below player - bypass ones complement creation
; --------------------------------------------------------------------------------------------------------------------- ;
; create ones complement - make positive
; --------------------------------------------------------------------------------------------------------------------- ;
                            eor #$ff                        ; 
                            adc #$01                        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check laser distance to the selected player - move laser to the nearest player (lowest distance)
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLaserDist              cmp TabWrkGun_LaserDistY        ; test actual laser PosY distance to actual player PosY
                            bcs SetNextPlayerNum            ; check: GE - yes: continue with next player
                            
                            sta TabWrkGun_LaserDistY        ; set actual laser PosY distance to actual player PosY
                            
                            lda CC_WA_Sprite_PosY,y         ; get actual player PosY
                            cmp #$c8                        ; test max screen PosY
                            bcs SetLaserMove_Up             ; check: GE - yes: move laser up
                            
                            cmp CC_WA_ItemDef_PosY,x        ; test with laser PosY
                            bcs SetLaserMove_Do             ; check: GE - Yes: move laser down
                            
SetLaserMove_Up             lda TabFlagGun_Laser_Move_Up    ; 
                            sta TabWrkGun_Laser_MoveDir     ; set actual laser move direction
                            
                            jmp SetNextPlayerNum            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetLaserMove_Do             lda TabFlagGun_Laser_Move_Do    ; 
                            sta TabWrkGun_Laser_MoveDir     ; set actual laser move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; continue with next player
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextPlayerNum            dec TabWrkGun_PlayerNum         ; set player #1 to follow
                            bpl TestNextPlayer              ; check: all players handled - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; update the laser data status
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; ########
                            eor TabFlagGun_Laser_Move_Up    ; #####.## - isolate laser move bits
                            eor TabFlagGun_Laser_Move_Do    ; #####..#
                            
                            ldy #CC_Gun_Laser               ; get offset laser status
                            and (CCZ_RayGunDataPtr),y       ; isolate laser status bits
                            ora TabWrkGun_Laser_MoveDir     ; insert actual laser move direction
                            sta (CCZ_RayGunDataPtr),y       ; set new laser status
; --------------------------------------------------------------------------------------------------------------------- ;
; test if laser moves up on the pole
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLaserMove_Up           ldy #CC_Gun_Laser               ; get offset laser status
                            lda (CCZ_RayGunDataPtr),y       ; get laser status
                            bit TabFlagGun_Laser_Move_Up    ; test move up
                            beq CheckLaserMove_Do           ; check: move up: no: check move down
; --------------------------------------------------------------------------------------------------------------------- ;
; step the laser up on the pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Gun_Laser_PosY          ; get offset laser PosY on pole
                            lda (CCZ_RayGunDataPtr),y       ; get laser PosY on pole
                            
                            ldy #CC_Gun_Pole_PosY           ; get offset top pole PosY
                            cmp (CCZ_RayGunDataPtr),y       ; test laser PosY on pole with top pole PosY
                            beq SetLaserMove_None           ; check: EQ - yes: stop moving
                            
                            sec                             ; 
                            sbc #$01                        ; move laser one PosY up
                            ldy #CC_Gun_Laser_PosY          ; get offset laser PosY on pole
                            sta (CCZ_RayGunDataPtr),y       ; set new laser PosY on pole
                            
                            lda #HR_GREEN_GREY              ; get move up switch color
                            jsr ItemRayGunSwitchColor       ; color the ray gun control switch
                            
                            jmp IniDrawLaserMove            ; continously draw the moving laser
; --------------------------------------------------------------------------------------------------------------------- ;
; test if laser moves down on the pole
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLaserMove_Do           bit TabFlagGun_Laser_Move_Do    ; test flag laser moves down
                            bne MoveLaserMove_Do            ; check: moves down - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; halt the laser on the pole
; --------------------------------------------------------------------------------------------------------------------- ;
SetLaserMove_None           lda #HR_GREY_GREY               ; get halt color
                            jsr ItemRayGunSwitchColor       ; color the ray gun control switch
                            
                            jmp CheckLaser_Halt             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; step the laser down on the pole
; --------------------------------------------------------------------------------------------------------------------- ;
MoveLaserMove_Do            ldy #CC_Gun_Laser_PosY          ; get offset laser PosY on pole
                            lda (CCZ_RayGunDataPtr),y       ; get ray gun PosY on pole
                            cmp CC_WA_Item_Gun_Laser_EndY,x ; test with max PosY on pole
                            bcs SetLaserMove_None           ; check: GE - yes: stop moving
                            
                            clc                             ; 
                            adc #$01                        ; move laser one PosY down
                            sta (CCZ_RayGunDataPtr),y       ; set new laser PosY on pole
                            
                            lda #HR_GREY_RED                ; get move down switch color
                            jsr ItemRayGunSwitchColor       ; color the ray gun control switch
; --------------------------------------------------------------------------------------------------------------------- ;
; continously draw the moving laser
; --------------------------------------------------------------------------------------------------------------------- ;
IniDrawLaserMove            lda CC_WA_ItemDef_PosX,x        ; get gun pole PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Gun_Laser_PosY          ; get offset laser PosY on pole
                            lda (CCZ_RayGunDataPtr),y       ; get gun PosY on pole
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            ldy #CC_Gun_Laser               ; get offset gun status
                            lda (CCZ_RayGunDataPtr),y       ; get gun status
                            bit TabFlagGun_Laser_Dir        ; test gun shoot directory
                            beq GetRayGunMoveTabOff_Ri      ; check: TabFlagGun_Laser_Dir_Ri - yes
                            
                            lda #TabGunLaser_ItemNumOff_Le  ; get offset table gun item numbers for shoot direction left
                            jmp SetRayGunMoveTabOff         ; 
                            
GetRayGunMoveTabOff_Ri      lda #TabGunLaser_ItemNum_Off_Ri ; get offset table gun item numbers for shoot direction right
; --------------------------------------------------------------------------------------------------------------------- ;
; read next selected ray gun laser item number from move item table
; --------------------------------------------------------------------------------------------------------------------- ;
SetRayGunMoveTabOff         sta TabWrkGun_MoveTab_Off       ; set offset table gun item numbers for shoot direction right
                            
                            ldy #CC_Gun_Laser_PosY          ; get offset laser PosY on pole
                            lda (CCZ_RayGunDataPtr),y       ; get gun PosY on pole
                            and #TabGunLaser_ItemNumOff_Le - $01 ; limit to max TabGunLaser_ItemNum offset
                            ora TabWrkGun_MoveTab_Off       ; insert new TabGunLaser_ItemNum
                            
                            tay                             ; set as TabGunLaser_ItemNum table offset
                            lda TabGunLaser_ItemNum,y       ; get next item number for gun shoot direction
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player has stopped the laser
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLaser_Halt             ldy #CC_Gun_Laser               ; get offset laser status
                            lda (CCZ_RayGunDataPtr),y       ; get laser status
                            bit TabFlagGun_Laser_Halt       ; test laser halted
                            beq CheckLaser_Distance         ; check: halted - no: check distance
                            
                            eor TabFlagGun_Laser_Halt       ; flip status flag halted
                            sta (CCZ_RayGunDataPtr),y       ; set new laser status
                            
                            bit TabFlagGun_Laser_Fire       ; test fire
                            bne CheckGun_Fires              ; check: fire - yes: check if a shot is still active
                            
                            jmp RayGunAimLaserHeadX         ; exit - nothing more to do
; --------------------------------------------------------------------------------------------------------------------- ;
; check if laser has reached the targeted players PosY
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLaser_Distance         lda TabWrkGun_LaserDistY        ; get actual laser PosY distance to actual player PosY
                            cmp #$05                        ; test laser has reached player PosY
                            bcs RayGunAimLaserHeadX         ; check: GE - yes: still not reached - do not fire - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; laser has reached the shooting range of $00-$04 - fire - but only if the previous shot is gone
; --------------------------------------------------------------------------------------------------------------------- ;
CheckGun_Fires              ldy #CC_Gun_Laser               ; get offset laser flags
                            lda (CCZ_RayGunDataPtr),y       ; get laser flags
                            bit TabFlagGun_Fires            ; test flag does laser already fire
                            bne RayGunAimLaserHeadX         ; check: fires - yes: do not init a 2nd laser beam
                            
                            jsr RayGunBeamFire              ; fire a ray gun laser beam
; --------------------------------------------------------------------------------------------------------------------- ;
; mark laser is busy firing
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora TabFlagGun_Fires            ; insert flag laser already fires
                            sta (CCZ_RayGunDataPtr),y       ; 
                            
RayGunAimLaserHeadX         jmp RoomItemHandler.RTS_RoomItemHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawRayGun                Does    : draw the castle room ray gun
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawRayGun                 .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; save data pointer ray gun
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabWrkGun_DataPtr_Lo        ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabWrkGun_DataPtr_Hi        ; 
                            
                            lda #$00                        ; get initial value
                            sta TabWrkGun_CastleData_Off    ; init actual ray gun castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this ray gun
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextRayGun              ldy #CC_Gun                     ; get offset ray gun data
                            lda (CCZ_DrawItemDataPtr),y     ; get ray gun data status flag
                            bit TabFlagGun_EoD              ; test CC_Gun_EoD
                            beq RayGunDraw                  ; check: CC_Gun_EoD - no: handle ray gun
                            
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawRayGunX                 ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this ray gun - reset a possibly active shot flag first
; --------------------------------------------------------------------------------------------------------------------- ;
RayGunDraw                  lda #$ff                        ; set all bits
                            eor TabFlagGun_Fires            ; clear bit6
                            and (CCZ_DrawItemDataPtr),y     ; isolate ray gun data bit0 - ray gun direction
                            sta (CCZ_DrawItemDataPtr),y     ; set new ray gun data bit0 - ray gun direction
                            
                            ldy #CC_Gun_Pole_PosX           ; get offset pole PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Gun_Pole_PosY           ; get offset pole PosY
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            ldy #CC_Gun_Laser               ; get offset laser status
                            lda (CCZ_DrawItemDataPtr),y     ; get laser status
                            bit TabFlagGun_Laser_Dir        ; test flag ray gun shoot direction
                            bne GetItemPole_Le              ; check: points right - no
                            
                            lda #ItemNum_GunPole_Ri         ; get item pole right
                            jmp IniPoleItemDrawNum          ; 
                            
GetItemPole_Le              lda #ItemNum_GunPole_Le         ; get item pole left
; --------------------------------------------------------------------------------------------------------------------- ;
; init the pole item number for the chosen shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
IniPoleItemDrawNum          sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; init the pole length
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Gun_Pole_Len            ; get offset ray gun pole length
                            lda (CCZ_DrawItemDataPtr),y     ; get ray gun pole length
                            sta TabWrkGun_Pole_Len          ; set actual ray gun pole length
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the pole
; --------------------------------------------------------------------------------------------------------------------- ;
DrawNextRayGunPoleItem      lda TabWrkGun_Pole_Len          ; get actual ray gun pole length
                            beq SetFlag_WA_Handled          ; check: min - yes: done
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; move pole PosY to next position downwards
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            dec TabWrkGun_Pole_Len          ; dec actual ray gun pole length
                            jmp DrawNextRayGunPoleItem      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag work area ready
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlag_WA_Handled          ldy #CC_Gun_Laser               ; get offset laser status
                            lda (CCZ_DrawItemDataPtr),y     ; get laser status
                            bit TabFlagGun_Laser_WA_Init    ; test work area set up already
                            bne DrawGunOnPole               ; check: WA exists - yes: bypass setup
; --------------------------------------------------------------------------------------------------------------------- ;
; set up work areas
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_Gun     ; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as ray gun
                            
                            lda TabWrkGun_CastleData_Off    ; get actual ray gun castle data offset
                            sta CC_WA_Item_Gun_DataOff,x    ; set this ray gun castle data offset
                            
                            lda CC_WA_ItemDef_Status,x      ; 
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set max move down pole position for the gun
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Gun_Pole_Len            ; get offset ray gun pole length
                            lda (CCZ_DrawItemDataPtr),y     ; get ray gun pole length
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - room draw grid height
                            
                            ldy #CC_Gun_Pole_PosY           ; get offset ray gun pole PosY
                            clc                             ; 
                            adc (CCZ_DrawItemDataPtr),y     ; add ray gun pole PosY for bottom PosY
                            
                            sec                             ; 
                            sbc #Item_RayGun_Rows           ; subtract gun height
                            sta CC_WA_Item_Gun_Laser_EndY,x ; set max position down on the pole for the ray gun
; --------------------------------------------------------------------------------------------------------------------- ;
; check ray gun shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Gun_Laser               ; get offset laser status
                            lda (CCZ_DrawItemDataPtr),y     ; get laser status
                            bit TabFlagGun_Laser_Dir        ; test shoot direction 
                            bne IniGunPoint_Left            ; check: right - no: then left
; --------------------------------------------------------------------------------------------------------------------- ;
; init PosX for ray gun pointing right
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldy #CC_Gun_Pole_PosX           ; get offset pole PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get pole PosX
                            adc #$04                        ; add draw grid width
                            jmp SetGun_WA_PosX              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init PosX for ray gun pointing left
; --------------------------------------------------------------------------------------------------------------------- ;
IniGunPoint_Left            sec                             ; 
                            ldy #CC_Gun_Pole_PosX           ; get offset pole PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get pole PosX
                            sbc #$04 * $02                  ; sub double draw grid width
                            
SetGun_WA_PosX              sta CC_WA_ItemDef_PosX,x        ; 
                            
DrawGunOnPole               jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
; --------------------------------------------------------------------------------------------------------------------- ;
; draw ray gun control switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_ItemDef_Type_GunCtrl ; 
                            sta CC_WA_ItemDef_Type,x        ; 
                            
                            ldy #CC_Gun_Switch_PosX         ; get offset switch PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Gun_Switch_PosY         ; get offset switch PosY
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_GunSwitch          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            
                            lda TabWrkGun_CastleData_Off    ; get actual ray gun castle data offset
                            sta CC_WA_Item_Gun_DataOff,x    ; set this ray gun castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next ray gun data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_GunItem_Len             ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc AdvanceRayGunDataOff        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance offset to ray gun data 
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceRayGunDataOff        clc                             ; 
                            lda TabWrkGun_CastleData_Off    ; get actual ray gun castle data offset
                            adc #CC_GunItem_Len             ; 
                            sta TabWrkGun_CastleData_Off    ; set new actual ray gun castle data offset
                            
                            jmp DrawNextRayGun              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawRayGunX                 pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkGun_DataPtr_Lo        .byte $80 ; 
TabWrkGun_DataPtr_Hi        .byte $b7 ; 
TabWrkGun_LaserDistY        = *       ; actual laser PosY distance to actual player PosY
TabWrkGun_CastleData_Off    .byte $a0 ; actual ray gun castle data offset
TabWrkGun_MoveTab_Off       = *       ; offset for table TabGunLaser_ItemNum
TabWrkGun_Laser_MoveDir     = *       ; actual laser move direction         
TabWrkGun_Pole_Len          .byte $80 ; actual ray gun pole length
TabWrkGun_PlayerNum         .byte $c2 ; actual player number to follow
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagGun_EoD              .byte %10000000 ; $80 - end of ray gun data
TabFlagGun_Fires            .byte %01000000 ; $40 - active shot
TabFlagGun_Laser_Halt       .byte %00100000 ; $20 - a player has stopped the laser
TabFlagGun_Laser_WA_Init    .byte %00010000 ; $10 - laser work area already initialized
TabFlagGun_Laser_Fire       .byte %00001000 ; $08 - a player has pressed the fire button
TabFlagGun_Laser_Move_Up    .byte %00000100 ; $04 - laser moves up
TabFlagGun_Laser_Move_Do    .byte %00000010 ; $02 - laser moves down
TabFlagGun_Laser_Dir        .byte %00000001 ; $01 - laser head point direction
TabFlagGun_Laser_Dir_Le         = %00000001 ;       laser head points left
TabFlagGun_Laser_Dir_Ri         = %00000000 ;       laser head points right
; --------------------------------------------------------------------------------------------------------------------- ;
; gun laser head item numbers for shoot direction right
; --------------------------------------------------------------------------------------------------------------------- ;
TabGunLaser_ItemNum         = *                          ; 
TabGunLaser_ItemNum_Off_Ri  = * - TabGunLaser_ItemNum    ; 
                            .byte ItemNum_GunLaser_Ri_04 ; 
                            .byte ItemNum_GunLaser_Ri_01 ; 
                            .byte ItemNum_GunLaser_Ri_02 ; 
                            .byte ItemNum_GunLaser_Ri_03 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; gun laser head item numbers for shoot direction left
; --------------------------------------------------------------------------------------------------------------------- ;
TabGunLaser_ItemNumOff_Le   = * - TabGunLaser_ItemNum    ; 
                            .byte ItemNum_GunLaser_Le_04 ; 
                            .byte ItemNum_GunLaser_Le_01 ; 
                            .byte ItemNum_GunLaser_Le_02 ; 
                            .byte ItemNum_GunLaser_Le_03 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerRayGunMove          Does    : a player manually moves a ray gun laser head up or down
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset ray gun control work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerRayGunMove           .block                           ; 
                            sty TabWrkGun_Switch_WA_Off     ; save offset ray gun control work area
; --------------------------------------------------------------------------------------------------------------------- ;
; only a player can control a ray gun
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne PlayerRayGunMoveX           ; check: CC_WA_Sprite_Type_Player - no: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player stands in front of a ray gun control switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get player PosX
                            adc CC_WA_Sprite_Width,x        ; add player sprite width
                            
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; sub ray gun control PosX
                            cmp #$08                        ; test with ray gun control width
                            bcs PlayerRayGunMoveX           ; check: GE - no: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the player has arrived in the room
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_Sprite_PlayerNum,x    ; get player number
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne PlayerRayGunMoveX           ; check: arrived - no: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; set ray gun data pointer for the selected ray gun
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkGun_Switch_WA_Off     ; get save offset ray gun control work area
                            clc                             ; 
                            lda TabWrkGun_DataPtr_Lo        ; 
                            adc CC_WA_Item_Gun_DataOff,y    ; add actual ray gun castle data offset
                            sta CCZ_RayGunDataPtr_Lo        ; 
                            
                            lda TabWrkGun_DataPtr_Hi        ; 
                            adc #$00                        ; add carry
                            sta CCZ_RayGunDataPtr_Hi        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test the possible player control moves
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; ########
                            eor TabFlagGun_Laser_Move_Up    ; #####.## - isolate laser move bits
                            eor TabFlagGun_Laser_Move_Do    ; #####..#
                            
                            ldy #CC_Gun_Laser               ; get offset laser status
                            and (CCZ_RayGunDataPtr),y       ; isolate laser status bits
                            
                            ldy CC_WA_Sprite_Move_Subst,x   ; get player move direction
                            bne TestGunMove_Do              ; check: CC_WA_Sprite_Move_Subst_Up - no
; --------------------------------------------------------------------------------------------------------------------- ;
; move laser up
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora TabFlagGun_Laser_Move_Up    ; insert move up
                            jmp InsertGunMove_Halt          ; 
                            
TestGunMove_Do              cpy #CC_WA_Sprite_Move_Subst_D  ; test move down
                            bne TestGunMove_Halt            ; check: CC_WA_Sprite_Move_Subst_D - no
; --------------------------------------------------------------------------------------------------------------------- ;
; move laser down
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora TabFlagGun_Laser_Move_Do    ; 
                            jmp InsertGunMove_Halt          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; test if player stays in front of the gun control - halt the laser then
; --------------------------------------------------------------------------------------------------------------------- ;
TestGunMove_Halt            cpy #CC_WA_Sprite_Move_Subst_None ; test flag player does not move
                            bne PlayerRayGunMoveX           ; check: EQ - no: continue moving
; --------------------------------------------------------------------------------------------------------------------- ;
; halt laser
; --------------------------------------------------------------------------------------------------------------------- ;
InsertGunMove_Halt          ora TabFlagGun_Laser_Halt       ; insert move halt
; --------------------------------------------------------------------------------------------------------------------- ;
; set selected status
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Gun_Laser               ; get offset laser status
                            sta (CCZ_RayGunDataPtr),y       ; get new laser status
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player fires the laser
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_FireButton,x   ; get status player fire button
                            beq GetRayLaser_Fire_No         ; check: pressed: no
; --------------------------------------------------------------------------------------------------------------------- ;
; laser fires
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CCZ_RayGunDataPtr),y       ; 
                            ora TabFlagGun_Laser_Fire       ; 
                            jmp SetRayLaser_Fire            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; laser does not fire
; --------------------------------------------------------------------------------------------------------------------- ;
GetRayLaser_Fire_No         lda #$ff                        ; ########
                            eor TabFlagGun_Laser_Fire       ; ####.### - isolate laser fire
                            and (CCZ_RayGunDataPtr),y       ; isolate laser move bits
; --------------------------------------------------------------------------------------------------------------------- ;
; set selected fire mode
; --------------------------------------------------------------------------------------------------------------------- ;
SetRayLaser_Fire            sta (CCZ_RayGunDataPtr),y       ; 
                            
PlayerRayGunMoveX           jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemRayGunSwitchColor     Does    : color the ray gun control switch
;                           Expects : .A=ray gun control switch color
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemRayGunSwitchColor      .block                           ; 
                            pha                             ; 
                            sta TabWrkGun_Switch_Color      ; save actual switch color
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw ray gun control top color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkGun_Switch_Color      ; get switch color
                            sta TabDataRayGunSwitchColor_1  ; set top switch color
                            sta TabDataRayGunSwitchColor_2  ; 
                            
                            ldy #CC_Gun_Switch_PosX         ; get offset gun control PosX
                            lda (CCZ_RayGunDataPtr),y       ; set gun control PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Gun_Switch_PosY         ; get offset gun control PosY
                            lda (CCZ_RayGunDataPtr),y       ; set gun control PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_GunSwitchColor     ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; draw ray gun control bottom color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkGun_Switch_Color      ; ####....
                            asl a                           ; .####... - shift left color nybble to right
                            asl a                           ; ..####..
                            asl a                           ; ...####.
                            asl a                           ; ....####
                            sta TabDataRayGunSwitchColor_1  ; set bottom switch color
                            sta TabDataRayGunSwitchColor_2  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; address ry gun control bottom part
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08 * $02                  ; add room double draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkGun_Switch_WA_Off     .byte $9f ; 
TabWrkGun_Switch_Color      .byte $a7 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemXmitTargetFlash       Does    : handle the xmit booth and target flashing
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset item work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemXmitTargetFlash        .block                           ; 
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$01                        ; isolate flash delay count
                            bne ItemXmitTargetFlashX        ; check: EQ - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get and play a random sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GetNextRandomValue          ; get a random value
                            and #$3f                        ; limit - ..######
                            sta TabSFX_XmitXmit_Tone        ; vary the sound effect
                            
                            lda #NumSfx_XmitXmit            ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
; init xmitter receiver flash color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$03                        ; isolate flash delay count
                            beq GetXmitColor                ; check: ZERO - yes: get actual xmitter booth color
                            
                            lda #WHITE                      ; get initial value
                            jmp ShiftFlashColor             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetXmitColor                lda CC_WA_Item_Xmit_Color,x     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set xmitter receiver color
; --------------------------------------------------------------------------------------------------------------------- ;
ShiftFlashColor             asl a                           ; .####... - shift left color nybble to right
                            asl a                           ; ..####..
                            asl a                           ; ...####.
                            asl a                           ; ....####
                            
                            sta TabDataXmitTargetColor_0    ; 
                            sta TabDataXmitTargetColor_1    ; 
                            sta TabDataXmitTargetColor_2    ; 
                            sta TabDataXmitTargetColor_3    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw xmitter receiver dot
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Xmit_Target_PosX,x ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda CC_WA_Item_Xmit_Target_PosY,x ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_XmitTarget         ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; set xmitter booth color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$03                        ; isolate flash delay count
                            beq GetXmitBoothColor           ; check: ZERO - yes: get actual xmitter booth color
                            
                            lda #BLACK                      ; 
                            jmp GoDrawXmitBoothWall         ; 
                            
GetXmitBoothColor           lda CC_WA_Item_Xmit_Color,x     ; 
                            
GoDrawXmitBoothWall         jsr DrawXmitBoothWall           ; draw and color the xmitter booth back wall
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$03                        ; isolate flash delay count
                            bne ItemXmitTargetFlashX        ; check: ZERO - yes: get actual xmitter color
                            
                            dec CC_WA_Item_Xmit_FlashTime,x ; dec receiver flash time
                            bne ItemXmitTargetFlashX        ; check: ZERO - no: bypass flip dispatch flag
; --------------------------------------------------------------------------------------------------------------------- ;
; flip the subroutine ready to dispatch flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            eor TabItem_WA_Flag_Ready       ; flip flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
                            
ItemXmitTargetFlashX        jmp RoomItemHandler.RTS_RoomItemHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerMatterTargetSelect  Does    : a player selects an xmit taget dot
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset xmitter work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerMatterTargetSelect   .block                           ; 
                            lda CC_WA_ItemDef_Status,y      ; 
                            bit TabItem_WA_Flag_Ready       ; test flag ready to be dispatched in RoomItemHandler
                            bne GoExit                      ; check: already ready: yes: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; only players can switch xmitter target colors
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne GoExit                      ; check: player - no: exit
                            
                            sty TabWrkXmit_WA_Off           ; save offset xmitter work area
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player has arrived in room
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy CC_WA_Sprite_PlayerNum,x    ; get player number
                            lda CC_GameDataVar_Flag,y       ; get this player status flag from castle data variables
                            cmp #CC_GameDataVar_Flag_InRoom ; test flag player has arrived in room
                            bne GoExit                      ; check: 
; --------------------------------------------------------------------------------------------------------------------- ;
; set data pointer for the selected matter xmitter
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkXmit_WA_Off           ; 
                            lda CC_WA_Item_Xmit_Ptr_Lo,y    ; 
                            sta CCZ_XmitterDataPtr_Lo       ; 
                            
                            lda CC_WA_Item_Xmit_Ptr_Hi,y    ; 
                            sta CCZ_XmitterDataPtr_Hi       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check player fire button
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_FireButton,x   ; get ststus fire button
                            bne XmitPlayer                  ; check: pressed - yes: xmit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the booth back wall color has to be changed for a new target
; --------------------------------------------------------------------------------------------------------------------- ;
; only a jostick move up ist working
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Move_Subst,x   ; get player move dir
                            bne GoExit                      ; check: CC_WA_Sprite_Move_Subst_Up - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the action wait timer has the correct value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$0f                        ; ....####
                            bne GoExit                      ; check: ZERO - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; advance xmitter booth color
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Xmit_Booth_Color        ; get offset booth color number 
                            lda (CCZ_XmitterDataPtr),y      ; get booth color number
                            
                            clc                             ; 
                            adc #$01                        ; advance booth color number
                            sta (CCZ_XmitterDataPtr),y      ; set new booth color number
; --------------------------------------------------------------------------------------------------------------------- ;
; set offset to list of booth receiver dots
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl a                           ; *2 - entry length in receiver list
                            adc #CC_Xmit_BoothItem_Len      ; add booth header length
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set default booth color if receiver list is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CCZ_XmitterDataPtr),y      ; get CC_Xmit_Target
                            bne SetBoothColorSfx            ; check: CC_Xmit_Target_EoD - no
                            
                            lda #CC_Xmit_Booth_Color_Red    ; get default boot color
                            
                            ldy #CC_Xmit_Booth_Color        ; get offset booth color
                            sta (CCZ_XmitterDataPtr),y      ; set booth color
; --------------------------------------------------------------------------------------------------------------------- ;
; set booth color switch sound effect according to the selected color number
; --------------------------------------------------------------------------------------------------------------------- ;
SetBoothColorSfx            ldy #CC_Xmit_Booth_Color        ; get offset both color
                            lda (CCZ_XmitterDataPtr),y      ; get booth color
                            
                            clc                             ; 
                            adc #$32                        ; 
                            sta TabSFX_XmitSelect_Tone      ; 
                            
                            lda #NumSfx_XmitSelect          ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the xmitter booth back wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (CCZ_XmitterDataPtr),y      ; get booth color
                            clc                             ; 
                            adc #$02                        ; make it a real color
                            stx TabWrkXmit_Booth_Color      ; save real booth color
                            
                            ldx TabWrkXmit_WA_Off           ; 
                            jsr DrawXmitBoothWall           ; draw and color the xmitter booth back wall
                            
                            ldx TabWrkXmit_Booth_Color      ; 
                            
GoExit                      jmp PlayerMatterTargetSelectX   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; xmit the player to the selected position
; --------------------------------------------------------------------------------------------------------------------- ;
XmitPlayer                  ldy TabWrkXmit_WA_Off           ; get offset xmitter work area
                            lda CC_WA_ItemDef_Status,y      ; 
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,y      ; 
                            
                            lda #CC_WA_Item_Xmit_FlashTime_Ini ; get initial value
                            sta CC_WA_Item_Xmit_FlashTime,y ; init xmit flash timer
                            
                            ldy #CC_Xmit_Booth_Color        ; get offset actual booth color number
                            lda (CCZ_XmitterDataPtr),y      ; get actual booth color number
                            
                            clc                             ; 
                            adc #$02                        ; make it a real color
                            
                            ldy TabWrkXmit_WA_Off           ; get offset xmitter work area
                            sta CC_WA_Item_Xmit_Color,y     ; set color in xmitter work area 
; --------------------------------------------------------------------------------------------------------------------- ;
; get color selected receiver position from xmitter receiver position list
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Xmit_Booth_Color        ; get offset xmitter booth color number
                            lda (CCZ_XmitterDataPtr),y      ; get xmitter booth color number
                            
                            asl a                           ; *2 - entry length in receiver list
                            adc #$03                        ; add booth header length
                            tay                             ; set as offset to CC_Xmit_Target
                            
                            lda (CCZ_XmitterDataPtr),y      ; get CC_Xmit_Target_PosX
                            pha                             ; save CC_Xmit_Target_PosX
                            
                            iny                             ; set offset to CC_Xmit_Target_PosY
                            lda (CCZ_XmitterDataPtr),y      ; get CC_Xmit_Target_PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; set receiver target PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabWrkXmit_WA_Off           ; get offset xmitter work area
                            sta CC_WA_Item_Xmit_Target_PosY,y ; set PosY in xmitter work area
; --------------------------------------------------------------------------------------------------------------------- ;
; set player target PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$07                        ; add correction value
                            sta CC_WA_Sprite_PosY,x         ; set PosY in player sprite work area
; --------------------------------------------------------------------------------------------------------------------- ;
; set receiver target PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore CC_Xmit_Target_PosX
                            sta CC_WA_Item_Xmit_Target_PosX,y ; set PosX in xmitter work area
; --------------------------------------------------------------------------------------------------------------------- ;
; set player target PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta CC_WA_Sprite_PosX,x         ; set PosX in player sprite work area
                            
PlayerMatterTargetSelectX   jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawMatterXmitter         Does    : draw the castle room matter transmitters
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawMatterXmitter          .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw xmitter booth floor
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Xmit_Booth_PosX         ; get offset xmitter booth PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            ldy #CC_Xmit_Booth_PosY         ; get offset xmitter booth PosY
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            
                            clc                             ; 
                            adc #$08 * $03                  ; add triple room draw grid height
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda #ItemNum_Floor              ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #$03                        ; get initial value
                            sta TabWrkXmit_FloorTile_Count  ; init actual floor tile count
DrawNextFloorItemPiece      jsr RoomItemDraw                ; draw the selected room item
                            
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            dec TabWrkXmit_FloorTile_Count  ; dec actual floor tile count
                            bne DrawNextFloorItemPiece      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the xmitter booth
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Xmit_Booth_PosX         ; get offset xmitter booth PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Xmit_Booth_PosY         ; get offset xmitter booth PosY
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_XmitBooth          ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; correct the destroyed floor from booth draw
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc #$04 * $03                  ; sub triple room draw grid width - step three room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set new draw item type_0 parm: PosX
                            
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08 * $03                  ; add room triple draw grid height - step three room grid position down
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            lda #ItemNum_Floor              ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; get xmitter receiver hot spot working area
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_Xmit    ; hot spot to recognize a booth color change attempt
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as receiver hot spot
; --------------------------------------------------------------------------------------------------------------------- ;
; draw xmitter booth hot spot for recognition of change receiver color
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Xmit_Booth_PosX         ; get offset xmitter booth PosX
                            clc                             ; get xmitter booth PosX
                            lda (CCZ_DrawItemDataPtr),y     ; 
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Xmit_Booth_PosY         ; get offset xmitter booth PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get xmitter booth PosY
                            clc                             ; 
                            adc #$08 * $03                  ; add room triple draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_XmitBooth_HotSpot  ; recognizes an attempt to change the receiver target color
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; store xmitter data area pointer in new work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta CC_WA_Item_Xmit_Ptr_Lo,x    ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta CC_WA_Item_Xmit_Ptr_Hi,x    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init xmitter target work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; draw xmitter booth back wall
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Xmit_Booth_Color        ; get offset xmitter booth color number
                            lda (CCZ_DrawItemDataPtr),y     ; get xmitter booth color number
                            clc                             ; 
                            adc #$02                        ; convert color number into a real color value
                            jsr DrawXmitBoothWall           ; draw and color the xmitter booth back wall
; --------------------------------------------------------------------------------------------------------------------- ;
; draw xmitter target dots
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_XmitTarget         ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #RED << $04                 ; get initial value
                            sta TabWrkXmit_Target_Color     ; init actual xmitter target color
                            
DrawNextXmitterTargetDot    ldy #CC_Xmit_Target_PosX        ; get offset xmitter target PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get xmitter target PosX
                            beq DrawMatterXmitter_Exit      ; check: CC_Xmit_Target_EoD - yes: prepare exit
                            
                            lda TabWrkXmit_Target_Color     ; get actual xmitter target color
                            
                            sta TabDataXmitTargetColor_0    ; set new xmitter target color
                            sta TabDataXmitTargetColor_1    ; 
                            sta TabDataXmitTargetColor_2    ; 
                            sta TabDataXmitTargetColor_3    ; 
                            
                            ldy #CC_Xmit_Target_PosX        ; get offset xmitter target dot PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get xmitter target dot PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Xmit_Target_PosY        ; get offset xmitter target dot PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get xmitter target dot PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer to next xmitte target data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_XmitTargetItem_Len      ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc SetNextTarbetColor          ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi        ; 
                            
SetNextTarbetColor          clc                             ; 
                            lda TabWrkXmit_Target_Color     ; get actual xmitter target color
                            adc #WHITE << $04               ; set next color
                            sta TabWrkXmit_Target_Color     ; set new actual xmitter target color
                            
                            jmp DrawNextXmitterTargetDot    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance room data pointer behind xmitter data to next possible item data entry
; --------------------------------------------------------------------------------------------------------------------- ;
DrawMatterXmitter_Exit      clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_Xmit_BoothItem_Len + $01; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc DrawMatterXmitterX          ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawMatterXmitterX          pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawXmitBoothWall         Does    : draw and color the xmitter booth back wall
;                           Expects : .A=xmitter booth back wall color
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawXmitBoothWall          .block                           ; 
                            pha                             ; 
                            sta TabWrkXmit_Booth_Color_Back ; save actual xmitter booth back wall color
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set xmitter booth back wall color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkXmit_Booth_Color_Back ; get actual xmitter booth back wall color
                            asl a                           ; shift to left nibble
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
                            ora #LT_RED                     ; insert 2nd color - set up booth brim hires color
                            sta TabDataXmitBoothBackColor_0 ; 
                            sta TabDataXmitBoothBackColor_1 ; 
                            sta TabDataXmitBoothBackColor_2 ; 
                            lda #LT_GREY                    ; get booth roof color
                            sta TabDataXmitBoothBackColor_3 ; 
                            sta TabDataXmitBoothBackColor_4 ; 
                            sta TabDataXmitBoothBackColor_5 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw xmitter booth back wall top row - step one column right first
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Xmit_Ptr_Lo,x    ; 
                            sta CCZ_XmitterDataPtr_Lo       ; 
                            lda CC_WA_Item_Xmit_Ptr_Hi,x    ; 
                            sta CCZ_XmitterDataPtr_Hi       ; 
                            
                            ldy #CC_Xmit_Booth_PosX         ; get offset booth PosX
                            lda (CCZ_XmitterDataPtr),y      ; get booth PosX
                            clc                             ; 
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Xmit_Booth_PosY         ; get offset booth PosY
                            lda (CCZ_XmitterDataPtr),y      ; get booth PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_XmitBoothBack      ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; draw xmitter booth back wall middle row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            lda #WHITE                      ; 
                            sta TabDataXmitBoothBackColor_3 ; 
                            sta TabDataXmitBoothBackColor_4 ;  
                            sta TabDataXmitBoothBackColor_5 ; 
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; draw xmitter booth back wall bottom row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkXmit_Booth_Color      .byte $a0 ; 
TabWrkXmit_WA_Off           .byte $ff ; 
TabWrkXmit_FloorTile_Count  = *       ; 
TabWrkXmit_Target_Color     .byte $d5 ; actual xmitter target color
TabWrkXmit_Booth_Color_Back .byte $c3 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemTrapDoorMove          Does    : open or close a trap door
;                           Expects : .X=offset trap door work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemTrapDoorMove           .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set trap door castle data pointer of the selected trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Item_Trap_DataOff,x   ; get this trap door castle data offset
                            adc TabWrkTrap_CastleDataPtr_Lo ; add offset this trap door castle data
                            sta CCZ_TrapDataPtr_Lo          ; 
                            
                            lda TabWrkTrap_CastleDataPtr_Hi ; 
                            adc #$00                        ; add carry
                            sta CCZ_TrapDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check trap door status
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Trap_Status,x    ; get trap door status
                            beq TrapDoor_Close              ; check: open - yes: close it
; --------------------------------------------------------------------------------------------------------------------- ;
; open a closed trap door - step bottom up
; --------------------------------------------------------------------------------------------------------------------- ;
; set draw parms for the next opening a trap step
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TrapDoor_PosX           ; get offset trap door PosX
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosX from castle data
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            ldy #CC_TrapDoor_PosY           ; get offset trap door PosY
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosY from castle data
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda CC_WA_Item_Trap_PhaseNum,x  ; get actual trap door open/close step item number
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; set trap open phase step sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ItemTrapSfxHandler          ; set trap door closing phase sound effect
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
; --------------------------------------------------------------------------------------------------------------------- ;
; draw open trap phase by using the actual phase item number to wipe out the floor parts
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; check if trap door is fully opened
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Trap_PhaseNum,x  ; get actual trap door open/close step item number
                            cmp #ItemNum_TrapMov_Max        ; test max - trap part #3b - 2nd top part
                            bne SetNextTrapPhase_Open       ; check: EQ - no: continue with next closing step
; --------------------------------------------------------------------------------------------------------------------- ;
; fully open - draw the open trap door detection item - recognises the sprite-background collision for killings
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldy #CC_TrapDoor_PosX           ; get offset trap door PosX
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosX from castle data
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_TrapDoor_PosY           ; get offset trap door PosY
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosY from castle data
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_TrapOpen_HotSpot   ; get the trap open detection item number
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            jmp ItemTrapDoorMove_Exit       ; done - prepare exit
; --------------------------------------------------------------------------------------------------------------------- ;
; close an open trap door - step top down
; --------------------------------------------------------------------------------------------------------------------- ;
TrapDoor_Close              lda CC_WA_Item_Trap_PhaseNum,x  ; get actual trap door open/close step item number
                            cmp #ItemNum_TrapMov_Max        ; test max - trap part #3b - 2nd top part
                            bne IniTrapCloseParms           ; check: EQ - no: skip deletion
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st delete a possible open door hot spot item by overwiting it with a door max open tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDelete              ; wipe out an item from the room display and deactivate its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; set draw parms for the next closing a trap step
; --------------------------------------------------------------------------------------------------------------------- ;
IniTrapCloseParms           ldy #CC_TrapDoor_PosX           ; get offset trap door PosX
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosX from castle data
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_TrapDoor_PosY           ; get offset trap door PosY
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosY from castle data
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda CC_WA_Item_Trap_PhaseNum,x  ; get actual trap door open/close step item number
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; set open trap phase step sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ItemTrapSfxHandler          ; set trap door closing phase sound effect
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
; --------------------------------------------------------------------------------------------------------------------- ;
; draw next trap open phase step
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; check if trap is fully open
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Item_Trap_PhaseNum,x  ; get actual trap door open/close step item number
                            cmp #ItemNum_TrapMov_Min        ; test min - trap part #1a - 1st bottom part
                            beq ItemTrapDoorMove_Exit       ; check: EQ - yes: fully closed - prepare exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set next trap phase close item number
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec CC_WA_Item_Trap_PhaseNum,x  ; dec actual trap door open/close step item number
                            jmp ItemTrapDoorMoveX           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set next trap phase open item number
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextTrapPhase_Open       inc CC_WA_Item_Trap_PhaseNum,x  ; inc actual trap door open/close step item number
                            jmp ItemTrapDoorMoveX           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare exit
; --------------------------------------------------------------------------------------------------------------------- ;
ItemTrapDoorMove_Exit       lda CC_WA_ItemDef_Status,x      ; 
                            eor TabItem_WA_Flag_Ready       ; flip flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
                            
ItemTrapDoorMoveX           jmp RoomItemHandler.RTS_RoomItemHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemTrapSfxHandler        Does    : vary the trap door open/close sound effect
;                           Expects : .A=trap door open/close step item number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemTrapSfxHandler         .block                           ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc #$48                        ; 
                            sta TabSFX_TrapSwitch_Tone      ; 
                            
                            lda #NumSfx_TrapSwitch          ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawTrapDoor              Does    : draw the castle room trap doors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawTrapDoor               .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; save data pointer trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabWrkTrap_CastleDataPtr_Lo ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabWrkTrap_CastleDataPtr_Hi ; 
                            
                            lda #$00                        ; get initial value
                            sta TabWrkTrap_CastleData_Off   ; init actual trap door data offset
                            
DrawNextTrapDoor            ldy #CC_TrapDoor                ; get offset trap door data
                            lda (CCZ_DrawItemDataPtr),y     ; get trap door data status
                            bit TabFlagTrapDoor_EoD         ; test flag CC_TrapDoor_EoD
                            beq RoomTrapDoor                ; check: CC_TrapDoor_EoD - no: handle trap door
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte EndOfTrapDoorData and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: 
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawTrapDoorX               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this trap door
; --------------------------------------------------------------------------------------------------------------------- ;
RoomTrapDoor                jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_TrapDoor; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as trap door
                            
                            lda TabWrkTrap_CastleData_Off   ; get actual trap door castle data offset
                            sta CC_WA_Item_Trap_DataOff,x   ; set this trap door castle data offset
                            
                            ldy #CC_TrapDoor_Mode           ; get offset trap door mode
                            lda (CCZ_DrawItemDataPtr),y     ; get trap door mode
                            bit TabFlagTrapDoor_Open        ; test flag trap door open
                            bne TrapDoor_Open               ; check: open - yes: draw an open trap door
                            
                            lda #GREY << $04                ; 
                            sta TabDataTrapSwitchColor_Top  ; 
                            
                            lda #HR_GREEN_GREEN             ; 
                            sta TabDataTrapSwitchColor_Bot  ; 
                            
                            jmp TrapDoor_Closed             ; draw a closed trap door
; --------------------------------------------------------------------------------------------------------------------- ;
; draw an open trap door
; --------------------------------------------------------------------------------------------------------------------- ;
TrapDoor_Open               ldy #CC_TrapDoor_PosX           ; get offset trap door PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get trap door PosX
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            ldy #CC_TrapDoor_PosY           ; get offset trap door PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get trap door PosY
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda #ItemNum_TrapOpen           ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the open trap door detection item - recognises the sprite-background collision for killings
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda TabWrkDraw_T1_Parm_ItemPosY ; get draw item type_1 parm: PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_TrapOpen_HotSpot   ; get the trap open detection item number
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; color the open trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #RED << $04                 ; 
                            sta TabDataTrapSwitchColor_Top  ; 
                            
                            lda #HR_GREY_GREY               ; 
                            sta TabDataTrapSwitchColor_Bot  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game move ctrl pointer for the open trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TrapDoor_PosX           ; get offset trap door PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get trap door PosX
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                                                              
                            sec                             ; 
                            sbc #$04                        ; subtract global room row start of $10 ($04*$04 grids)
                            sta TabWrkDrawGrid_Col_Num      ; set trap door draw grid column number
                            
                            ldy #$02                        ; get offset trap door PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get trap door PosY
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw grid height
                            sta TabWrkDrawGrid_Row_Num      ; set trap door draw grid row number
                            
                            jsr GameSetMoveCtrlDataPtr      ; set the room move control data pointer 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark floor as impassable due to an open trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset floor position #1
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #~CC_MoveCtrl_Right         ; clear a possible move right
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            ldy #$04                        ; get offset floor position #2
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #~CC_MoveCtrl_Left          ; clear a possible move left
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw a closed trap door
; --------------------------------------------------------------------------------------------------------------------- ;
TrapDoor_Closed             jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_TrapCtrl; 
                            sta CC_WA_ItemDef_Type,x        ; 
                            
                            ldy #CC_TrapDoor_Switch_PosX    ; get offset trap door switch PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get trap door switch PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_TrapDoor_Switch_PosY    ; get offset trap door switch PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get trap door switch PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_TrapSwitch         ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda TabWrkTrap_CastleData_Off   ; get actual trap door castle data offset
                            sta CC_WA_Item_Trap_DataOff,x   ; set this trap door castle data offset
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the actual trap door data offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkTrap_CastleData_Off   ; get actual trap door castle data offset
                            adc #CC_TrapDoorItem_Len        ; 
                            sta TabWrkTrap_CastleData_Off   ; set new actual trap door castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the room data pointer to next trap door data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_TrapDoorItem_Len        ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc TryNextTrapDoor             ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
TryNextTrapDoor             jmp DrawNextTrapDoor            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawTrapDoorX               pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomItemTrapDoorHandler   Does    : flip the trap door mode - paint the trap door switch - mark move control data
;                           Expects : .A=offset trap door work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemTrapDoorHandler    .block                           ; 
                            pha                             ; 
                            sta TabWrkTrap_WA_Off           ; save offset trap door work area
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; save data pointers
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_TrapDataPtr_Lo          ; 
                            sta TabWrkTrap_Sprt_DataPtr_Lo  ; 
                            lda CCZ_TrapDataPtr_Hi          ; 
                            sta TabWrkTrap_Sprt_DataPtr_Hi  ; 
                            
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            sta TabWrkTrap_MoveCtrl_Ptr_Lo  ; 
                            lda CCZ_MoveCtrlDataPtr_Hi      ; 
                            sta TabWrkTrap_MoveCtrl_Ptr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set castle data pointer for this trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkTrap_CastleDataPtr_Lo ; 
                            adc TabWrkTrap_WA_Off           ; add this trap door work area offset
                            sta CCZ_TrapDataPtr_Lo          ; 
                            
                            lda TabWrkTrap_CastleDataPtr_Hi ; 
                            adc #$00                        ; add carry
                            sta CCZ_TrapDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; flip trap door mode between open/closed and vice versa
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TrapDoor_Mode           ; get offset trap door mode
                            lda (CCZ_TrapDataPtr),y         ; get trap door mode
                            eor TabFlagTrapDoor_Open        ; flip flag trap door open/closed
                            sta (CCZ_TrapDataPtr),y         ; set new trap door mode
; --------------------------------------------------------------------------------------------------------------------- ;
; search this trap door item work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$00                        ; get initial work areat offset
GetNextItem_WA_Type         lda CC_WA_ItemDef_Type,x        ; get next work area type
                            cmp #CC_WA_ItemDef_Type_TrapDoor; test trap door
                            bne SetNex_WA_Off               ; check: trap door - no: try next
                            
                            lda CC_WA_Item_Trap_DataOff,x   ; get work area type
                            cmp TabWrkTrap_WA_Off           ; test with this trap door work area offset
                            beq Trap_WA_Found               ; check: EQ - yes: found the matching work area
                            
SetNex_WA_Off               txa                             ; 
                            clc                             ; 
                            adc #CC_WA_ItemDef_Len          ; add work area length
                            tax                             ; 
                            
                            jmp GetNextItem_WA_Type         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; item work area for this trap door found
; --------------------------------------------------------------------------------------------------------------------- ;
Trap_WA_Found               lda CC_WA_ItemDef_Status,x      ; get this trap door status
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; set flag trap door needs action
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TrapDoor_Mode           ; get offset trap door mode
                            lda (CCZ_TrapDataPtr),y         ; get trap door mode
                            bit TabFlagTrapDoor_Open        ; test flag trap door open
                            bne TrapDoor_Close              ; check: CC_TrapDoor_Mode_Open - yes: close it
; --------------------------------------------------------------------------------------------------------------------- ;
; open trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_Item_Trap_Status_Open; 
                            sta CC_WA_Item_Trap_Status,x    ; set new trap door status
                            
                            lda #ItemNum_TrapMov_Max        ; get max - trap part #3b - 2nd top part
                            sta CC_WA_Item_Trap_PhaseNum,x  ; set actual trap door open/close step item number
; --------------------------------------------------------------------------------------------------------------------- ;
; get trap door switch color for an open trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_GREY_BLACK              ; 
                            sta TabDataTrapSwitchColor_Top  ; 
                            
                            lda #HR_GREEN_GREEN             ; 
                            sta TabDataTrapSwitchColor_Bot  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set control screen data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TrapDoor_PosX           ; get offset trap door PosX
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosX
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                                                              
                            sec                             ; 
                            sbc #$04                        ; subtract global room row start of $10 ($04*$04 grids)
                            sta TabWrkDrawGrid_Col_Num      ; set trap door draw grid column number
                            
                            ldy #CC_TrapDoor_PosY           ; get offset trap door PosY
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosY
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw grid height
                            sta TabWrkDrawGrid_Row_Num      ; set trap door draw grid row number
                            
                            jsr GameSetMoveCtrlDataPtr      ; set the room move control data pointer 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark floor as impassable due to an open trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            ora #CC_MoveCtrl_Right          ; insert a possible move right
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            ldy #$04                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            ora #CC_MoveCtrl_Left           ; insert a possible move left
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            jmp DrawTrapSwitch              ; draw the changed trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
; close trap door
; --------------------------------------------------------------------------------------------------------------------- ;
TrapDoor_Close              lda #CC_WA_Item_Trap_Status_Closed ; 
                            sta CC_WA_Item_Trap_Status,x    ; set new trap door status
                            
                            lda #ItemNum_TrapMov_Min        ; get min - open step #5 - fully open
                            sta CC_WA_Item_Trap_PhaseNum,x  ; actual trap door open/close step item number
; --------------------------------------------------------------------------------------------------------------------- ;
; get trap door switch color for an closed trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_RED_BLACK               ; 
                            sta TabDataTrapSwitchColor_Top  ; 
                            
                            lda #HR_GREY_GREY               ; 
                            sta TabDataTrapSwitchColor_Bot  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set control screen data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TrapDoor_PosX           ; get offset trap door PosX
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosX
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                                                              
                            sec                             ; 
                            sbc #$04                        ; subtract global room row start of $10 ($04*$04 grids)
                            sta TabWrkDrawGrid_Col_Num      ; set trap door draw grid column number
                            
                            ldy #CC_TrapDoor_PosY           ; get offset trap door PosY
                            lda (CCZ_TrapDataPtr),y         ; get trap door PosY
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw grid height
                            sta TabWrkDrawGrid_Row_Num      ; set trap door draw grid row number
                            
                            jsr GameSetMoveCtrlDataPtr      ; set the room move control data pointer 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark floor as passable due to an closed trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #~CC_MoveCtrl_Right         ; clear a possible move right
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            ldy #$04                        ; 
                            lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and #~CC_MoveCtrl_Left          ; clear a possible move left
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw trap door switch
; --------------------------------------------------------------------------------------------------------------------- ;
DrawTrapSwitch              ldy #CC_TrapDoor_Switch_PosX    ; get offset trap door switch PosX
                            lda (CCZ_TrapDataPtr),y         ; get trap door switch PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_TrapDoor_Switch_PosY    ; get offset trap door switch PosY
                            lda (CCZ_TrapDataPtr),y         ; get trap door switch PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_TrapSwitch         ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; restore data pointers
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkTrap_Sprt_DataPtr_Lo  ; 
                            sta CCZ_TrapDataPtr_Lo          ; 
                            lda TabWrkTrap_Sprt_DataPtr_Hi  ; 
                            sta CCZ_TrapDataPtr_Hi          ; 
                            
                            lda TabWrkTrap_MoveCtrl_Ptr_Lo  ; 
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            lda TabWrkTrap_MoveCtrl_Ptr_Hi  ; 
                            sta CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkTrap_CastleData_Off   .byte $a5 ; offset actual trap door castle data
TabWrkTrap_WA_Off           .byte $a0 ; offset trap door work area
TabWrkTrap_Sprt_DataPtr_Lo  .byte $a0 ; 
TabWrkTrap_Sprt_DataPtr_Hi  .byte $a0 ; 
TabWrkTrap_MoveCtrl_Ptr_Lo  .byte $a0 ; 
TabWrkTrap_MoveCtrl_Ptr_Hi  .byte $80 ; 
TabWrkTrap_CastleDataPtr_Lo .byte $a5 ; 
TabWrkTrap_CastleDataPtr_Hi .byte $a0 ; 
                            
TabFlagTrapDoor_EoD         .byte $80 ; flag: end of trap door data
TabFlagTrapDoor_Open        .byte $01 ; flag: trap door is open
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ItemSideWalkMove          Does    : handle the moving side walk
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset item work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ItemSideWalkMove           .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set data pointer for the selected moving side walk
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkWalk_CastleDataPtr_Lo ; 
                            adc CC_WA_Item_Walk_DataOff,x   ; add this side walk castle data offset
                            sta CCZ_WalkDataPtr_Lo          ; 
                            
                            lda TabWrkWalk_CastleDataPtr_Hi ; 
                            adc #$00                        ; add carry
                            sta CCZ_WalkDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player #1 pressed the fire button
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_SideWalk_Mode           ; get offset side walk mode
                            lda (CCZ_WalkDataPtr),y         ; get side walk mode
                            bit TabFlagWalk_Press_P1        ; test flag player #1 pressed fire
                            beq TestFire_P2                 ; check: fire - no: test player #2
                            
                            bit TabFlagWalk_Save_P1         ; test 
                            beq CtrlSideWalkMove            ; check: 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if player #2 pressed the fire button
; --------------------------------------------------------------------------------------------------------------------- ;
TestFire_P2                 bit TabFlagWalk_Press_P2        ; testflag  player #2 pressed fire
                            beq CtrlPlayerFireFlag          ; check: fire - no: control player fire flags
                            
                            bit TabFlagWalk_Save_P2         ; test 
                            bne CtrlPlayerFireFlag          ; check: fire - no: control player fire flags
; --------------------------------------------------------------------------------------------------------------------- ;
; a player pressed fire - update side walk move status
; --------------------------------------------------------------------------------------------------------------------- ;
CtrlSideWalkMove            bit TabFlagWalk_Move            ; test flag side walk move
                            beq SetFlagWalkMove             ; check: move - no: insert flag side walk move
; --------------------------------------------------------------------------------------------------------------------- ;
; switch to opposite move status
; --------------------------------------------------------------------------------------------------------------------- ;
                            eor TabFlagWalk_Move            ; flip flag side walk move (on/off)
                            eor TabFlagWalk_MoveDir         ; flip flag side walk move direction (left/right)
                            sta (CCZ_WalkDataPtr),y         ; set new side walk mode
; --------------------------------------------------------------------------------------------------------------------- ;
; init color to side walk stopped
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_GREY_BLACK              ; get initial value
                            sta TabDataWalkSwitchColor_Le   ; 
                            sta TabDataWalkSwitchColor_Ri   ; 
                            
                            lda #$1e                        ; 
                            sta TabSFX_WalkSwitch_Tone      ; 
                            
                            jmp DrawSideWalkSwitch          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set side walk status move
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagWalkMove             ora TabFlagWalk_Move            ; insert flag side walk move
                            sta (CCZ_WalkDataPtr),y         ; set new flag side walk move
; --------------------------------------------------------------------------------------------------------------------- ;
; set side walk switch colors according to side walk move direction
; --------------------------------------------------------------------------------------------------------------------- ;
                            bit TabFlagWalk_MoveDir         ; test flag side walk move direction
                            beq SetWalkSwitchColor_Le       ; check: move dir left - yes: set switch color walk moves left
; --------------------------------------------------------------------------------------------------------------------- ;
; set color side walk moves right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_GREEN_BLACK             ; 
                            sta TabDataWalkSwitchColor_Le   ; 
                            
                            lda #HR_GREY_BLACK              ; 
                            sta TabDataWalkSwitchColor_Ri   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init switch right sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$18                        ; 
                            sta TabSFX_WalkSwitch_Tone      ; 
                            
                            jmp DrawSideWalkSwitch          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set color side walk moves left
; --------------------------------------------------------------------------------------------------------------------- ;
SetWalkSwitchColor_Le       lda #HR_GREY_BLACK              ; 
                            sta TabDataWalkSwitchColor_Le   ; 
                            
                            lda #HR_RED_BLACK               ; 
                            sta TabDataWalkSwitchColor_Ri   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set switch left sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$24                        ; 
                            sta TabSFX_WalkSwitch_Tone      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the side walk switch
; --------------------------------------------------------------------------------------------------------------------- ;
DrawSideWalkSwitch          ldy #CC_SideWalk_Switch_PosX    ; get offset walk switch PosX
                            lda (CCZ_WalkDataPtr),y         ; get walk switch PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_SideWalk_Switch_PosY    ; get offset walk switch PosY
                            lda (CCZ_WalkDataPtr),y         ; get walk switch PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_WalkSwitch         ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; set the selected switch sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #NumSfx_WalkSwitch          ; 
                            jsr ItemSfxInit                 ; init the selected room item sound effect
; --------------------------------------------------------------------------------------------------------------------- ;
; control player joystick fire flags - avoid a constant switch - a fire button has to be released for the next switch
; --------------------------------------------------------------------------------------------------------------------- ;
CtrlPlayerFireFlag          ldy #CC_SideWalk_Mode           ; get offset side walk mode
                            lda #$ff                        ; ########
                            eor TabFlagWalk_Save_P1         ; #####.## - isolate player fire bits
                            eor TabFlagWalk_Save_P2         ; ####..##
                            and (CCZ_WalkDataPtr),y         ; isolate side walk mode bits
                            
                            bit TabFlagWalk_Press_P1        ; test flag player #1 pressed fire
                            beq CtrlPlayerFireFlag_P2       ; check: fire - no: skip control update - check player #2
; --------------------------------------------------------------------------------------------------------------------- ;
; mark player #1 has pressed fire
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora TabFlagWalk_Save_P1         ; set flag player #1 pressed fire
                            eor TabFlagWalk_Press_P1        ; flip flag player #1 pressed fire
                            
CtrlPlayerFireFlag_P2       bit TabFlagWalk_Press_P2        ; test flag player #2 pressed fire
                            beq SetPlayerFireFlag           ; check: fire - no: skip control update
; --------------------------------------------------------------------------------------------------------------------- ;
; mark player #2 has pressed fire
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora TabFlagWalk_Save_P2         ; set flag player #2 pressed fire
                            eor TabFlagWalk_Press_P2        ; flip flag player #2 pressed fire
                            
SetPlayerFireFlag           sta (CCZ_WalkDataPtr),y         ; store the marked fire flags
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the actual walk way move step
; --------------------------------------------------------------------------------------------------------------------- ;
                            bit TabFlagWalk_Move            ; test flag side walk move
                            beq ItemSideWalkMoveX           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check the move delay counter
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$01                        ; isolate step delay
                            bne ItemSideWalkMoveX           ; check: 2nd step - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; init draw next side walk move step
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_ItemNum,x     ; get actual item number
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda (CCZ_WalkDataPtr),y         ; get side walk mode
                            bit TabFlagWalk_MoveDir         ; test flag side walk move direction
                            bne StepWalk_Ri                 ; check: move right - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; set next side walk move step left
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkDraw_T0_Parm_ItemNum  ; inc draw item type_0 parm: Item Number
                            
                            lda TabWrkDraw_T0_Parm_ItemNum  ; get draw item type_0 parm: Item Number
                            cmp #ItemNum_WalkMov_Max + $01  ; test max
                            bcc GetWalkDrawPos              ; check: LT - yes: bypass reset move step to min
; --------------------------------------------------------------------------------------------------------------------- ;
; reset side walk move step to minimum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_WalkMov_Min        ; get walk move min
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jmp GetWalkDrawPos              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set next side walk move step right
; --------------------------------------------------------------------------------------------------------------------- ;
StepWalk_Ri                 dec TabWrkDraw_T0_Parm_ItemNum  ; dec draw item type_0 parm: Item Number
                            
                            lda TabWrkDraw_T0_Parm_ItemNum  ; get draw item type_0 parm: Item Number
                            cmp #ItemNum_WalkMov_Min        ; test min
                            bcs GetWalkDrawPos              ; check: GE - yes: bypass set max
; --------------------------------------------------------------------------------------------------------------------- ;
; reset side walk move step to maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #ItemNum_WalkMov_Max        ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
GetWalkDrawPos              lda CC_WA_ItemDef_PosX,x        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            lda CC_WA_ItemDef_PosY,x        ; 
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the next side walk step
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
                            
ItemSideWalkMoveX           jmp RoomItemHandler.RTS_RoomItemHandler ; return to caller
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerSideWalkPace        Does    : a sprite is accelerated/pushed back by the walk move dir
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset side walk work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerSideWalkPace         .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set data pointer for the selected moving side walk
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkWalk_CastleDataPtr_Lo ; 
                            adc CC_WA_Item_Walk_DataOff,y   ; add this side walk castle data offset
                            sta CCZ_WalkDataPtr_Lo          ; 
                            
                            lda TabWrkWalk_CastleDataPtr_Hi ; 
                            adc #$00                        ; add carry
                            sta CCZ_WalkDataPtr_Hi          ; 
                            
                            sty TabWrkWalk_WA_Off           ; save offset walk work area
                            
                            ldy #CC_SideWalk_Mode           ; get offset side walk mode
                            lda (CCZ_WalkDataPtr),y         ; get side walk mode
                            bit TabFlagWalk_Move            ; test flag side walk move
                            beq PlayerSideWalkPaceX         ; check: move - no: stopped - nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; test the possible sprite types
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            beq WalkMove_Player             ; check: player - yes: check player
                            
                            cmp #CC_WA_Sprite_Type_Mummy    ; test mummy
                            beq WalkMove_Sprite             ; check: EQ - yes: move mummy
                            
                            cmp #CC_WA_Sprite_Type_Frank    ; test frankenstein
                            beq WalkMove_Sprite             ; check: EQ - yes: move frankenstein
                            
                            jmp PlayerSideWalkPaceX         ; no sprite of the nexessary type - nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; no sidewalk moves if this player is on a pole or ladder
; --------------------------------------------------------------------------------------------------------------------- ;
WalkMove_Player             lda CC_WA_Sprite_Num,x          ; 
                            cmp #SpriteNum_PlayerMoveRi_Max + $01 ; test player move left/right sprite number
                            bcs PlayerSideWalkPaceX         ; check: GE - yes: pole or ladder - nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if sprite is on side walk
; --------------------------------------------------------------------------------------------------------------------- ;
WalkMove_Sprite             clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get sprite PosX
                            adc CC_WA_Sprite_Width,x        ; aad width
                            
                            ldy TabWrkWalk_WA_Off           ; get offset walk work area
                            sec                             ; 
                            sbc CC_WA_ItemDef_PosX,y        ; subtract side walk PosX
                            bcc PlayerSideWalkPaceX         ; check: LT - yes: reached walk end left - nothing to do - exit
                            
                            cmp #$20                        ; test with walk length
                            bcs PlayerSideWalkPaceX         ; check: GE - yes: reached walk end right - nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite is on side walk
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_SideWalk_Mode           ; get offset side walk mode
                            lda (CCZ_WalkDataPtr),y         ; get side walk mode
                            bit TabFlagWalk_MoveDir         ; test flag side walk move direction
                            beq GetWalkMoveSpeed_Le         ; check: move dir left - yes: get move left correction value
; --------------------------------------------------------------------------------------------------------------------- ;
; side walk moves right - get side walk move speed correction for right move
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; decrease speed - get -1
                            jmp SetWalkMoveSpeed_Single     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; side walk moves left - get side walk move speed correction for left move
; --------------------------------------------------------------------------------------------------------------------- ;
GetWalkMoveSpeed_Le         lda #$01                        ; increase speed - get +1
; --------------------------------------------------------------------------------------------------------------------- ;
; preset the desired single move speed corretion value
; --------------------------------------------------------------------------------------------------------------------- ;
SetWalkMoveSpeed_Single     sta TabWrkWalk_MoveSpeed        ; init single side walk move speed correction
; --------------------------------------------------------------------------------------------------------------------- ;
; check if sprite is player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne SetWalkMoveSpeed_Double     ; check: player - no: double the speed correction value
; --------------------------------------------------------------------------------------------------------------------- ;
; if sprite is player wait a while to double the speed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkIRQ_Delay             ; get delay time value
                            and #$07                        ; isolate wait time
                            bne SpeedUpSpritePosX           ; check: used up - no: bypass double speed
                            
SetWalkMoveSpeed_Double     asl TabWrkWalk_MoveSpeed        ; double the sprite side walk move speed
; --------------------------------------------------------------------------------------------------------------------- ;
; speed up or slow down the sprite according to the walk move direction
; --------------------------------------------------------------------------------------------------------------------- ;
SpeedUpSpritePosX           clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get sprite PosX
                            adc TabWrkWalk_MoveSpeed        ; add side walk move speed correction 
                            sta CC_WA_Sprite_PosX,x         ; set new sprite PosX
                            
PlayerSideWalkPaceX         jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawMovingSideWalk        Does    : draw the castle room moving sidewalks
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawMovingSideWalk         .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; save data pointer sidewalk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabWrkWalk_CastleDataPtr_Lo ; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabWrkWalk_CastleDataPtr_Hi ; 
                            
                            lda #$00                        ; get initial value
                            sta TabWrkWalk_CastleData_Off   ; init actual side walk castle data offset
                            
DrawNextSideWalk            ldy #CC_SideWalk                ; get offset side walk data
                            lda (CCZ_DrawItemDataPtr),y     ; get side walk data status
                            bit TabFlagWalk_Eod             ; test flag CC_SideWalk_EoD
                            beq RoomSideWalk                ; check: CC_SideWalk_EoD - no: handle side walk
                            
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawMovingSideWalkX         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this side walk
; --------------------------------------------------------------------------------------------------------------------- ;
RoomSideWalk                lda #$ff                        ; set all flags
                            eor TabFlagWalk_Press_P1        ; flip selected flags
                            eor TabFlagWalk_Press_P2        ; 
                            eor TabFlagWalk_Save_P1         ; 
                            eor TabFlagWalk_Save_P2         ; 
                            and (CCZ_DrawItemDataPtr),y     ; clear flags with side walk mode data
                            sta (CCZ_DrawItemDataPtr),y     ; set side walk mode
                            
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_Walk    ; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as side walk
                            
                            lda TabWrkWalk_CastleData_Off   ; get actual side walk castle data offset
                            sta CC_WA_Item_Walk_DataOff,x   ; set this side walk castle data offset
                            
                            lda CC_WA_ItemDef_Status,x      ; 
                            ora TabItem_WA_Flag_Ready       ; insert flag ready to be dispatched in RoomItemHandler
                            sta CC_WA_ItemDef_Status,x      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear floor for side walk insertion
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_SideWalk_PosX           ; get offset side walk PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get side walk PosX
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            ldy #CC_SideWalk_PosY           ; get offset side walk PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get side walk PosY
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda #ItemNum_WalkBlank          ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; draw side walk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX item zype_0
                            
                            lda TabWrkDraw_T1_Parm_ItemPosY ; get draw item type_1 parm: PosY item type_1
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY item type_0
                            
                            lda #ItemNum_WalkMov_Min        ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; init side walk work areas
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_WalkCtrl; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as side walk ctrl
                            
                            lda TabWrkWalk_CastleData_Off   ; get actual side walk castle data offset
                            sta CC_WA_Item_Walk_DataOff,x   ; set this side walk castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; draw side walk work switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_SideWalk_Switch_PosX    ; get offset side walk switch PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get side walk switch PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_SideWalk_Switch_PosY    ; get offset side walk switch PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get side walk switch PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_WalkSwitch         ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
; --------------------------------------------------------------------------------------------------------------------- ;
; color side walk switch
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_SideWalk_Mode           ; get offset side walk mode
                            lda (CCZ_DrawItemDataPtr),y     ; get side walk mode
                            bit TabFlagWalk_Move            ; test flag side walk move
                            bne CheckMoveDir                ; check: move - yes
                            
                            lda #GREY << $04                ; 
                            sta TabDataWalkSwitchColor_Le   ; 
                            sta TabDataWalkSwitchColor_Ri   ; 
                            
                            jmp DrawSideWalkSwitch          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check side walk move dir
; --------------------------------------------------------------------------------------------------------------------- ;
CheckMoveDir                bit TabFlagWalk_MoveDir         ; test flag side walk move direction
                            bne SetWalkSwitchColor_Le       ; check: moves left - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; set colors side walk swith move dir right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #GREY << $04                ; 
                            sta TabDataWalkSwitchColor_Le   ; 
                            
                            lda #RED << $04                 ; 
                            sta TabDataWalkSwitchColor_Ri   ; 
                            
                            jmp DrawSideWalkSwitch          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set colors side walk swith move dir left
; --------------------------------------------------------------------------------------------------------------------- ;
SetWalkSwitchColor_Le       lda #GREEN << $04               ; 
                            sta TabDataWalkSwitchColor_Le   ; 
                            
                            lda #GREY << $04                ; 
                            sta TabDataWalkSwitchColor_Ri   ; 
                            
DrawSideWalkSwitch          jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; draw side walk switch hot spot
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_SideWalk_Switch_PosX    ; get offset switch PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get switch PosX
                            clc                             ; 
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_SideWalk_Switch_PosY    ; get offset switch PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get switch PosY
                            clc                             ; 
                            adc #$08                        ; add room draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            lda #ItemNum_Walk_HotSpot       ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the actual side walk data offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkWalk_CastleData_Off   ; get actual side walk castle data offset
                            adc #CC_SideWalkItem_Len        ; 
                            sta TabWrkWalk_CastleData_Off   ; set new actual side walk castle data offset
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the room data pointer to next side walk data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_SideWalkItem_Len        ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc TryNextSideWalk             ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
TryNextSideWalk             jmp DrawNextSideWalk            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawMovingSideWalkX         pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerSideWalkSwitch      Does    : a player controls a side walk move dir
;                           Expects : .X=offset sprite work area
;                                   : .Y=offset side walk work area
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerSideWalkSwitch       .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; only a player can control a side walk ...
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Type,x         ; get type - Player / Spark / ForceField / Mummy / Gun Beam / Frank
                            bne PlayerSideWalkSwitchX       ; check: CC_WA_Sprite_Type_Player - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; ... but only if he wants it
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_FireButton,x   ; get status fire button
                            beq PlayerSideWalkSwitchX       ; check: fire - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set data pointer for the selected moving side walk
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkWalk_CastleDataPtr_Lo ; 
                            adc CC_WA_Item_Walk_DataOff,y   ; 
                            sta CCZ_WalkDataPtr_Lo          ; 
                            
                            lda TabWrkWalk_CastleDataPtr_Hi ; 
                            adc #$00                        ; add carry
                            sta CCZ_WalkDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; handle the active player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PlayerNum,x    ; get player number
                            beq GetFlagFire_P1              ; check: player #1 - yes: get correct flag
                            
                            lda TabFlagWalk_Press_P2        ; get flag player #2 pressed fire
                            jmp SetSideWalkMode             ; 
                            
GetFlagFire_P1              lda TabFlagWalk_Press_P1        ; get flag player #1 pressed fire
; --------------------------------------------------------------------------------------------------------------------- ;
; reflect the player switch action in side walk mode
; --------------------------------------------------------------------------------------------------------------------- ;
SetSideWalkMode             ldy #CC_SideWalk_Mode           ; get offset side walk mode
                            ora (CCZ_WalkDataPtr),y         ; insert actual side walk mode
                            sta (CCZ_WalkDataPtr),y         ; set new side walk mode
                            
PlayerSideWalkSwitchX       jmp RoomPlayerMoveHandler.RTS_ItemManualMoveHandler ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabFlagWalk_Eod             .byte %10000000 ; $80 - CC_SideWalk_EoD 
TabFlagWalk_Save_P2         .byte %00100000 ; $20 - CC_SideWalk_Mode_Save_P2
TabFlagWalk_Save_P1         .byte %00010000 ; $10 - CC_SideWalk_Mode_Save_P1
TabFlagWalk_Press_P2        .byte %00001000 ; $08 - CC_SideWalk_Mode_Press_P2
TabFlagWalk_Press_P1        .byte %00000100 ; $04 - CC_SideWalk_Mode_Press_P1
TabFlagWalk_MoveDir         = *             ; $02 - CC_SideWalk_Mode_MoveDir
TabFlagWalk_MoveDir_Ri      .byte %00000010 ; $02 - 
TabFlagWalk_Move            .byte %00000001 ; $01 - CC_SideWalk_Mode_Move
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkWalk_CastleData_Off   .byte $a4 ; actual side walk data offset in castel date
TabWrkWalk_MoveSpeed        .byte $b9 ; side walk move speed correction 
TabWrkWalk_CastleDataPtr_Lo .byte $a0 ; 
TabWrkWalk_CastleDataPtr_Hi .byte $b6 ; 
TabWrkWalk_WA_Off           .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DrawFrankenstein          Does    : draw the castle room frankenstein coffins
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawFrankenstein           .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; save data pointer frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            sta TabWrkFrank_CastleDataPtr_Lo; 
                            lda CCZ_DrawItemDataPtr_Hi      ; 
                            sta TabWrkFrank_CastleDataPtr_Hi; 
                            
                            lda #$00                        ; get initial value
                            sta TabWrkFrank_CastleData_Off  ; init actual frankenstein castle data offset
                            
DrawNextFrankCoffin         ldy #CC_Frank                   ; get offset frank data status
                            lda (CCZ_DrawItemDataPtr),y     ; get frank data status
                            bit TabFlagFrank_Eod            ; test flag CC_Frank_EoD
                            beq RoomFrankenstein            ; check: CC_Frank_EoD - no: handle frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer behind flag byte EndOfFrankData and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DrawItemDataPtr_Lo      ; 
                            bne Exit                        ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
                            
Exit                        jmp DrawFrankensteinX           ; done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; draw this frankenstein coffin
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the floor start/end items for coffin insertion
; --------------------------------------------------------------------------------------------------------------------- ;
RoomFrankenstein            ldy #CC_Frank_Coffin_PosX       ; get offset frank coffin PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get frank coffin PosX
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            clc                             ; 
                            ldy #CC_Frank_Coffin_PosY       ; get offset frank coffin PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get frank coffin PosY
                            adc #$08 * $03                  ; add triple room draw grid height - set coffin PosY to floor
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda #ItemNum_FrankCoffinClear   ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; set game move ctrl pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get draw item type_1 parm: PosX
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                                                              
                            sec                             ; 
                            sbc #$04                        ; subtract global room row start of $10 ($04*$04 grids)
                            sta TabWrkDrawGrid_Col_Num      ; set coffin draw grid column number
                            
                            lda TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw grid height
                            sta TabWrkDrawGrid_Row_Num      ; set draw grid row number
                            
                            jsr GameSetMoveCtrlDataPtr      ; set the room move control data pointer 
; --------------------------------------------------------------------------------------------------------------------- ;
; mark floor as impassable due to an frankenstein coffin
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Frank_Coffin            ; get offset frank coffin
                            lda (CCZ_DrawItemDataPtr),y     ; get frank coffin
                            bit TabFlagFrank_CoffinDir      ; test frankenstein coffin dir
                            bne StepMoveDataPtr_Le          ; check: coffin open to right - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; coffin sits on the right end of floor and opens to the left - get floor right end erasor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #~CC_MoveCtrl_Left          ; get a possible move left marker
                            jmp SetFloorErasor              ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; coffin sits on the left end of floor and opens to the right - get floor left end position
; --------------------------------------------------------------------------------------------------------------------- ;
StepMoveDataPtr_Le          sec                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; step move ctrl pointer a half position to the left
                            sbc #$02                        ; 
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcs GetFloorErasor_Le           ; check: underflow - no
                            dec CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; coffin sits on the left end of floor and opens to the right - get floor left end move control erasor
; --------------------------------------------------------------------------------------------------------------------- ;
GetFloorErasor_Le           lda #~CC_MoveCtrl_Right         ; get clear a possible move right marker
                            
SetFloorErasor              sta TabFrank_MoveCtrl_Erase     ; store the selected move control erasor
; --------------------------------------------------------------------------------------------------------------------- ;
; mark floor as impassable - each move ctrl entry has a lenght of two bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$02 * $02                  ; erase two positions 
EraseNextFloorMoveCtrlByte  lda (CCZ_MoveCtrlDataPtr),y     ; 
                            and TabFrank_MoveCtrl_Erase     ; 
                            sta (CCZ_MoveCtrlDataPtr),y     ; 
                            
                            dey                             ; discount one postion of two bytes
                            dey                             ; 
                            bpl EraseNextFloorMoveCtrlByte  ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; init frankenstein work areas
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemInit_WA_Both        ; get and init new item status and save work areas (.X=WA offset)
                            
                            lda #CC_WA_ItemDef_Type_Frank   ; 
                            sta CC_WA_ItemDef_Type,x        ; mark new work area as frankenstein
                            
                            ldy #CC_Frank_Coffin_PosX       ; get offset frankenstein coffin PosX
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein coffin PosX
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            ldy #CC_Frank_Coffin_PosY       ; get offset frankenstein coffin PosY
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein coffin PosY
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item type_0 parm: PosY
                            
                            ldy #CC_Frank_Coffin            ; get offset frankenstein coffin
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein coffin
                            bit TabFlagFrank_CoffinDir      ; test coffin dir 
                            bne GetItemNumCoffin_Le         ; check: die left - yes
                            
                            lda #ItemNum_FrankCoffin_Ri     ; get right coffin item number
                            jmp SetItemNumCoffin            ; 
                            
GetItemNumCoffin_Le         lda #ItemNum_FrankCoffin_Le     ; get left coffin item number
                            
SetItemNumCoffin            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
; --------------------------------------------------------------------------------------------------------------------- ;
; draw the selected coffin
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDrawFrom_WA_Init    ; draw item from work area status and init its work area
; --------------------------------------------------------------------------------------------------------------------- ;
; check coffin open direction
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset frankenstein coffin
                            lda (CCZ_DrawItemDataPtr),y     ; get frankenstein coffin
                            bit TabFlagFrank_CoffinDir      ; test coffin dir 
                            bne IniFrankSprite              ; check: open left - yes: bypass floor redraw
; --------------------------------------------------------------------------------------------------------------------- ;
; redraw floor directly in front of a left end coffin pointing to the right
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            adc #$04                        ; add room draw grid width - step one room grid position right
                            sta TabWrkDraw_T0_Parm_ItemPosX ; set draw item type_0 parm: PosX
                            
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            adc #$18                        ; add room triple draw grid height
                            sta TabWrkDraw_T0_Parm_ItemPosY ; set draw item parm: next PosY down
                            
                            lda #ItemNum_Floor              ; 
                            sta TabWrkDraw_T0_Parm_ItemNum  ; set draw item type_0 parm: Item Number
                            
                            lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; init frankenstein sprite
; --------------------------------------------------------------------------------------------------------------------- ;
IniFrankSprite              jsr FrankSprite_WA_Handler      ; init a rooms frankenstein
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the room data pointer to next frankenstein data entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_DrawItemDataPtr_Lo      ; 
                            adc #CC_FrankItem_Len           ; 
                            sta CCZ_DrawItemDataPtr_Lo      ; 
                            bcc AdvanceFrankDataOff         ; check: overflow - no
                            inc CCZ_DrawItemDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the actual frankenstein data offset
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceFrankDataOff         clc                             ; 
                            lda TabWrkFrank_CastleData_Off  ; get actual frankenstein castle data offset
                            adc #CC_FrankItem_Len           ; 
                            sta TabWrkFrank_CastleData_Off  ; set new actual frankenstein castle data offset
                            
                            jmp DrawNextFrankCoffin         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DrawFrankensteinX           pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkFrank_CastleDataPtr_Lo .byte $90 ; 
TabWrkFrank_CastleDataPtr_Hi .byte $a0 ; 
TabWrkFrank_CastleData_Off  .byte $c1 ; actual frankenstein castle data offset
TabFrank_MoveCtrl_Erase     .byte $a0 ; 
TabFlagFrank_Eod            .byte $80 ; 
TabFlagFrank_Coffin_Dead    .byte $04 ; flag: frankenstein is dead
TabFlagFrank_Coffin_Empty   .byte $02 ; flag: coffin is empty
TabFlagFrank_CoffinDir      .byte $01 ; flag: coffin lid direction
TabFlagFrank_CoffinDir_Ri       = $00 ; 
TabFlagFrank_CoffinDir_Le       = $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomItemInit_WA_Both      Does    : init both the item status and the save work areas
;                           Expects : 
;                           Returns : .X=work area offset
;                                   : .C=0 - ok
;                                   : .C=1 - error: all $20 possible work areas in use
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemInit_WA_Both       .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabItem_WA_UseCount         ; get current work area use count
                            cmp #TabItem_WA_UseCount_Max    ; test max
                            bne IniWorkArea                 ; check: EQ - no: init next free work areas
                            
                            sec                             ; set error flag
                            jmp RoomItemInit_WA_BothX       ; exit
; --------------------------------------------------------------------------------------------------------------------- ;
IniWorkArea                 inc TabItem_WA_UseCount         ; inc work area use count - discount the number of free ones
                            
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 - work area length
                            tax                             ; set as work area offset
                            
                            ldy #CC_WA_ItemDef_Len          ; get work area length
                            lda #$00                        ; get init value
IniNext_WA_Byte             sta CC_WA_ItemDef,x             ; init Room Item Work   Area ($be00-$beff)
                            sta CC_WA_Item,x                ; init Room Item Status Area ($bf00-$bfff)
                            
                            inx                             ; inc workarea offset
                            dey                             ; dec work area length
                            bne IniNext_WA_Byte             ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset work area offset to start
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; get advanced work area offset
                            sec                             ; 
                            sbc #CC_WA_ItemDef_Len          ; sub number of init bytes written
                            tax                             ; set as work area offset offset
; --------------------------------------------------------------------------------------------------------------------- ;
; mark status work are as initialized but still inactive
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabItem_WA_Flag_Init        ; 
                            sta CC_WA_ItemDef_Status,x      ; set flag CC_WA_ItemDef_Status_Init
                            
                            clc                             ; set flag ok
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemInit_WA_BothX       pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomItemDrawFrom_WA_Init  Does    : draw item from work area status and init its work area
;                           Expects : 
;                           Returns : 
;                           Remark  : Type_0: Draw   an item
;                                   : Type_2: Update an item
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemDrawFrom_WA_Init   .block                           ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            bit TabItem_WA_Flag_Init        ; test CC_WA_ItemDef_Status_Init
                            bne SetItemType_0               ; check: acive - no
; --------------------------------------------------------------------------------------------------------------------- ;
; init draw of item type_2
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkDraw_Parm_ItemType_2 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda CC_WA_ItemDef_PosX,x        ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            lda CC_WA_ItemDef_PosY,x        ; 
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
                            
                            lda CC_WA_ItemDef_ItemNum,x     ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            jmp DrawItem                    ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; init draw of item type_0
; --------------------------------------------------------------------------------------------------------------------- ;
SetItemType_0               lda #TabWrkDraw_Parm_ItemType_0 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
DrawItem                    jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; set up the item work area from draw item parms
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabItem_WA_Flag_Init        ; get flag CC_WA_ItemDef_Status_Init
                            eor #$ff                        ; flip all bits - prepare reset of bit7
                            and CC_WA_ItemDef_Status,x      ; reset bit7 - keep bit6/bit5
                            sta CC_WA_ItemDef_Status,x      ; 
                            
                            lda TabWrkDraw_T0_Parm_ItemNum  ; get draw item type_0 parm: Item Number
                            sta CC_WA_ItemDef_ItemNum,x     ; save number
                            
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            sta CC_WA_ItemDef_PosX,x        ; save PosX
                            
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY
                            sta CC_WA_ItemDef_PosY,x        ; save PosY
                            
                            lda TabWrkDraw_T0_Hdr_Cols      ; 
                            sta CC_WA_ItemDef_Width,x       ; save number of item col bytes from item header
                            
                            lda TabWrkDraw_T0_Hdr_Rows      ; 
                            sta CC_WA_ItemDef_Rows,x        ; save number of item pixel rows from item header
                            
                            asl CC_WA_ItemDef_Width,x       ; *2
                            asl CC_WA_ItemDef_Width,x       ; *4 - room draw grid width
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomItemDelete            Does    : wipe out an item from the room display and deactivate its work area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemDelete             .block                           ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check work area status initialized but still inactive
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            bit TabItem_WA_Flag_Init        ; test flag CC_WA_ItemDef_Status_Init
                            bne RoomDeleteItemX             ; check: EQ - no: nothing to do - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set up parms for room item deletion
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkDraw_Parm_ItemType_1 ; 
                            sta TabWrkDraw_Parm_ItemType    ; set global draw item parm: Type
                            
                            lda CC_WA_ItemDef_ItemNum,x     ; 
                            sta TabWrkDraw_T1_Parm_ItemNum  ; set draw item type_1 parm: Item Number
                            
                            lda CC_WA_ItemDef_PosX,x        ; 
                            sta TabWrkDraw_T1_Parm_ItemPosX ; set draw item type_1 parm: PosX
                            
                            lda CC_WA_ItemDef_PosY,x        ; 
                            sta TabWrkDraw_T1_Parm_ItemPosY ; set draw item type_1 parm: PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; wipe out the desired item from the room display
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr RoomItemDraw                ; draw the selected room item
; --------------------------------------------------------------------------------------------------------------------- ;
; mark its work area as initialized but inactive
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_ItemDef_Status,x      ; 
                            ora TabItem_WA_Flag_Init        ; insert flag CC_WA_ItemDef_Status_Init
                            sta CC_WA_ItemDef_Status,x      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomDeleteItemX             pla                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomItemDraw              Does    : draw the selected room item into the castles room
;                           Expects : TabWrkDraw_Parm_ItemType
;                                   : Draw: TabWrkDraw_T0_Parm_ItemNum  / Delete: TabWrkDraw_T1_Parm_ItemNum
;                                   : Draw: TabWrkDraw_T0_Parm_ItemPosX / Delete: TabWrkDraw_T1_Parm_ItemPosX
;                                   : Draw: TabWrkDraw_T0_Parm_ItemPosY / Delete: TabWrkDraw_T1_Parm_ItemPosY
;                           Returns : 
;                           Remark  : Type_0: Draw   an item
;                                   : Type_1: Delete an item
;                                   : Type_2: Update an item
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemDraw               .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_Parm_ItemType    ; get draw item parm Type
                            cmp #TabWrkDraw_Parm_ItemType_0 ; test item draw type_0
                            bne RoomItemInitType_01_02      ; check: EQ - no: init item type_1/type_2
                            
                            jmp RoomItemInitType_00         ; init item type_0
; --------------------------------------------------------------------------------------------------------------------- ;
; init item data address table pointer for item type_01/type_02 - delete an existing item/redraw an existing item
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemInitType_01_02      lda TabWrkDraw_T1_Parm_ItemNum  ; get draw item type_1 parm: Item Number
                            sta CCZ_ItemDataAdrTabPtr_Lo    ; set item pointer Lo to item number
                            lda #$00                        ; 
                            sta CCZ_ItemDataAdrTabPtr_Hi    ; init item pointer Hi
                            
                            asl CCZ_ItemDataAdrTabPtr_Lo    ; *2 - make it an address word
                            rol CCZ_ItemDataAdrTabPtr_Hi    ; 
                            
                            clc                             ; add item data address table base
                            lda CCZ_ItemDataAdrTabPtr_Lo    ; 
                            adc #<TabDataAdr_Items          ; 
                            sta CCZ_ItemDataAdrTabPtr_Lo    ; 
                            
                            lda CCZ_ItemDataAdrTabPtr_Hi    ; 
                            adc #>TabDataAdr_Items          ; 
                            sta CCZ_ItemDataAdrTabPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init item data address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda (CCZ_ItemDataAdrTabPtr),y   ; 
                            sta CCZ_ItemDataPtr_Lo          ; 
                            
                            iny                             ; 
                            lda (CCZ_ItemDataAdrTabPtr),y   ; 
                            sta CCZ_ItemDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get item header data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_ItemData_Header_Col     ; get offset header columns
                            lda (CCZ_ItemDataPtr),y         ; 
                            sta TabWrkDraw_T1_Hdr_Cols      ; set number of item col bytes from item header
                            
                            ldy #CC_ItemData_Header_Row     ; get offset header rows
                            lda (CCZ_ItemDataPtr),y         ; 
                            sta TabWrkDraw_T1_Hdr_Rows      ; set number of item pixel rows from item header
                            sta TabWrkDraw_T1_Row_Num       ; set actual row number
; --------------------------------------------------------------------------------------------------------------------- ;
; Delete Item: set item top PosX/PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosY ; get item type_1 parm PosY
                            adc TabWrkDraw_T1_Hdr_Rows      ; add number of item pixel rows from item header
                            sta TabWrkDraw_T1_PosY_Bot      ; set bottom of item
                            
                            dec TabWrkDraw_T1_PosY_Bot      ; correct pixel bottom row
                            
                            sec                             ; 
                            lda TabWrkDraw_T1_Parm_ItemPosX ; get item type_1 parm PosX
                            sbc #$10                        ; sub global room row start of $10 ($04*$04 grids)
                            bcs SetItem_T1_PosX_Start       ; check: underflow - no
                            
                            sta TabWrkDraw_T1_PosX_Start    ; set PosX minus the item global starting offset of $10
                            
                            lda #$ff                        ; 
                            jmp SetItem_T1_PosX_Start_Hi    ; 
                            
SetItem_T1_PosX_Start       sta TabWrkDraw_T1_PosX_Start    ; set PosX minus the item global starting offset of $10
                            
                            lda #$00                        ; 
                            
SetItem_T1_PosX_Start_Hi    sta TabWrkDraw_T1_PosX_Start_Hi ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Delete Item: get item row/column room draw start grid number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T1_PosX_Start    ; parm PosX minus the item global starting offset of $10
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                            sta TabWrkDraw_T1_Col_Min       ; set leftmost item col number
                            
                            lda TabWrkDraw_T1_PosX_Start_Hi ; get parm PosX minus the item global starting offset of $10
                            and #$c0                        ; ##......
                            ora TabWrkDraw_T1_Col_Min       ; insert leftmost item col number
                            sta TabWrkDraw_T1_Col_Min       ; set leftmost item col number
; --------------------------------------------------------------------------------------------------------------------- ;
; Delete Item: set hires screen graphic row address offset from item PosX minus the item global starting offset of $10
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl TabWrkDraw_T1_PosX_Start    ; *2 - 
                            rol TabWrkDraw_T1_PosX_Start_Hi ; *4 - hires offset
; --------------------------------------------------------------------------------------------------------------------- ;
; Delete Item: get item row/column room draw end grid number
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T1_Col_Min       ; get leftmost item col number
                            adc TabWrkDraw_T1_Hdr_Cols      ; add number of item col bytes from item header
                            sta TabWrkDraw_T1_Col_Max       ; set rightmost item col number
                            
                            dec TabWrkDraw_T1_Col_Max       ; adjust rightmost item col number
                            
                            lda #TabWrkDraw_T1_Flag_P0      ; get flag item part #0
                            sta TabWrkDraw_T1_Flag          ; start with part #0
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer to item data following item header
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_ItemDataPtr_Lo          ; 
                            adc #TabData_Hdr_Len            ; add item header length
                            sta CCZ_ItemDataPtr_Lo          ; 
                            bcc GetItemType                 ; check: overflow - no
                            inc CCZ_ItemDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check item type
; --------------------------------------------------------------------------------------------------------------------- ;
GetItemType                 lda TabWrkDraw_Parm_ItemType    ; get draw item parm Type
                            cmp #TabWrkDraw_Parm_ItemType_1 ; test item type_1
                            bne RoomItemInitType_00         ; check: EQ - no: handle item type_0
                            
                            jmp RoomItemType_01             ; handle item type_1 - delete the desired item
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: init item data address table pointer for item type_0
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemInitType_00         lda TabWrkDraw_T0_Parm_ItemNum  ; get draw item type_0 parm: Item Number
                            sta CCZ_ItemDataAdrTabPtr_Lo    ; set item pointer Lo to item number
                            lda #$00                        ; 
                            sta CCZ_ItemDataAdrTabPtr_Hi    ; init item pointer Hi
                            
                            asl CCZ_ItemDataAdrTabPtr_Lo    ; *2 - make it an address word
                            rol CCZ_ItemDataAdrTabPtr_Hi    ; 
                            
                            clc                             ; add item data address table base
                            lda CCZ_ItemDataAdrTabPtr_Lo    ; 
                            adc #<TabDataAdr_Items          ; 
                            sta CCZ_ItemDataAdrTabPtr_Lo    ; 
                            
                            lda CCZ_ItemDataAdrTabPtr_Hi    ; 
                            adc #>TabDataAdr_Items          ; 
                            sta CCZ_ItemDataAdrTabPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: init item data address pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda (CCZ_ItemDataAdrTabPtr),y   ; 
                            sta CCZ_ItemData_T0_Ptr_Lo      ; 
                            
                            iny                             ; 
                            lda (CCZ_ItemDataAdrTabPtr),y   ; 
                            sta CCZ_ItemData_T0_Ptr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: get item header data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_ItemData_Header_Col     ; get offset header columns
                            lda (CCZ_ItemData_T0_Ptr),y     ; 
                            sta TabWrkDraw_T0_Hdr_Cols      ; set number of item col bytes from item header
                            
                            ldy #CC_ItemData_Header_Row     ; get offset header rows
                            lda (CCZ_ItemData_T0_Ptr),y     ; 
                            sta TabWrkDraw_T0_Hdr_Rows      ; set number of item pixel rows from item header
                            sta TabWrkDraw_T0_Row_Num       ; set actual item pixel height row number
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: set item top PosX/PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY - top of item
                            adc TabWrkDraw_T0_Hdr_Rows      ; add number of item pixel rows from item header
                            sta TabWrkDraw_T0_PosY_Bot      ; set bottom of item
                            
                            dec TabWrkDraw_T0_PosY_Bot      ; correct pixel bottom row
                            
                            sec                             ; 
                            lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            sbc #$10                        ; sub global room row start of $10 ($04*$04 grids)
                            bcs SetItem_T0_PosX_Start       ; check: underflow - no
                            
                            sta TabWrkDraw_T0_PosX_Start    ; set PosX minus the item global starting offset of $10
                            
                            lda #$ff                        ; 
                            jmp SetItem_T0_PosX_Start_Hi    ; 
                            
SetItem_T0_PosX_Start       sta TabWrkDraw_T0_PosX_Start    ; set PosX minus the item global starting offset of $10
                            
                            lda #$00                        ; 
                            
SetItem_T0_PosX_Start_Hi    sta TabWrkDraw_T0_PosX_Start_Hi ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: get item row/column room draw start grid number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T0_PosX_Start    ; PosX minus the item global starting offset of $10
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                            sta TabWrkDraw_T0_Col_Min       ; set leftmost item col number
                            
                            lda TabWrkDraw_T0_PosX_Start_Hi ; 
                            and #$c0                        ; ##......
                            ora TabWrkDraw_T0_Col_Min       ; insert leftmost item col number
                            sta TabWrkDraw_T0_Col_Min       ; set leftmost item col number
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: set hires screen graphic row address offset from item PosX minus the item global starting offset of $10
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl TabWrkDraw_T0_PosX_Start    ; *2
                            rol TabWrkDraw_T0_PosX_Start_Hi ; *4 - hires offset
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: get item row/column room draw end grid number
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkDraw_T0_Col_Min       ; get leftmost item col number
                            adc TabWrkDraw_T0_Hdr_Cols      ; add number of item col bytes from item header
                            sta TabWrkDraw_T0_Col_Max       ; set rightmost item col number
                            
                            dec TabWrkDraw_T0_Col_Max       ; adjust rightmost item col number
                            
                            lda #TabWrkDraw_T0_Flag_P0      ; get flag item part #0
                            sta TabWrkDraw_T0_Flag          ; start with part #0
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: advance pointer to item data following item header
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_ItemData_T0_Ptr_Lo      ; 
                            adc #CC_ItemData_Data           ; add header length
                            sta CCZ_ItemData_T0_Ptr_Lo      ; 
                            bcc SetItem_T0_TopY             ; check: overflow - no
                            inc CCZ_ItemData_T0_Ptr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: calculate item top PosY - prepare for division
; --------------------------------------------------------------------------------------------------------------------- ;
SetItem_T0_TopY             lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY - top of item
                            sta TabWrkDraw_T0_Row_Top_Lo    ; set top of item work
                            
                            cmp #$dc                        ; test max PosY
                            bcs GetItem_T0_TopY_Hi_Min      ; check: GE - yes: set all division bits
                            
                            lda #$00                        ; 
                            jmp SetItem_T0_TopY_Hi          ; 
                            
GetItem_T0_TopY_Hi_Min      lda #$ff                        ; 
                            
SetItem_T0_TopY_Hi          sta CCZ_Draw_T0_PosY_Top_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: calculate item top draw grid number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr CCZ_Draw_T0_PosY_Top_Hi     ; 
                            ror TabWrkDraw_T0_Row_Top_Lo    ; /2
                            lsr CCZ_Draw_T0_PosY_Top_Hi     ; 
                            ror TabWrkDraw_T0_Row_Top_Lo    ; /4
                            lsr CCZ_Draw_T0_PosY_Top_Hi     ; 
                            ror TabWrkDraw_T0_Row_Top_Lo    ; /8 - room draw grid height
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: calculate item room grid row numbers
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T0_Hdr_Rows      ; get number of item pixel rows from item header
                            sec                             ; 
                            sbc #$01                        ; correction
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: calculate item height room grid row number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw grid height
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: calculate item top grid row number
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc TabWrkDraw_T0_Row_Top_Lo    ; add item top char row number calculated above
                            sta TabWrkDraw_T0_Row_Bot       ; set item max char row number
                            
                            lda TabWrkDraw_T0_Row_Top_Lo    ; get item top char row number
                            bpl IniHiresColorRowAdr         ; check: negative - no
                            
                            lda #$00                        ; 
                            sec                             ; 
                            sbc TabWrkDraw_T0_Row_Top_Lo    ; sub item top char row number - make positive
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: init hires color screen row address to start of item char row
; --------------------------------------------------------------------------------------------------------------------- ;
IniHiresColorRowAdr         tax                             ; set TabWrkDraw_T0_Row_Top_Lo  as index
                            lda TabTextScreenRowAdr_Lo,x    ; 
                            sta TabWrkHiRes_Color_RowAdr_Lo ; start of hires color char screen row address Lo
                            lda TabTextScreenRowAdr_Hi,x    ; 
                            sta TabWrkHiRes_Color_RowAdr_Hi ; start of hires color char screen row address Hi
                            
                            lda TabWrkDraw_T0_Row_Top_Lo    ; 
                            bpl SetItem_T0_StartX           ; check: negative - no
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: set hires color row address
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda #$00                        ; 
                            sbc TabWrkHiRes_Color_RowAdr_Lo ; start of hires color char screen row address Lo
                            sta TabWrkHiRes_Color_RowAdr_Lo ; 
                            
                            lda #$00                        ; 
                            sbc TabWrkHiRes_Color_RowAdr_Hi ; start of hires color char screen row address Hi
                            sta TabWrkHiRes_Color_RowAdr_Hi ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: calculate item start PosX - prepare for division
; --------------------------------------------------------------------------------------------------------------------- ;
SetItem_T0_StartX           lda TabWrkDraw_T0_Parm_ItemPosX ; get draw item parm: PosX
                            sec                             ; 
                            sbc #$10                        ; sub global room row start of $10 ($04*$04 grids)
                            sta CCZ_Draw_T0_PosX_Start_Lo   ; 
                            bcs GetItem_T0_StartX_Hi        ; check: overflow - no
                            
                            lda #$ff                        ; get min
                            jmp SetItem_T0_StartX_Hi        ; 
                            
GetItem_T0_StartX_Hi        lda #$00                        ; 
                            
SetItem_T0_StartX_Hi        sta CCZ_Draw_T0_PosX_Start_Hi   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: calculate item start draw grid number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr CCZ_Draw_T0_PosX_Start_Hi    ; /2
                            ror CCZ_Draw_T0_PosX_Start_Lo    ; 
                            lsr CCZ_Draw_T0_PosX_Start_Hi    ; /4 - room draw grid width
                            ror CCZ_Draw_T0_PosX_Start_Lo    ; 
                            
                            sta CCZ_Draw_T0_PosX_Start_Hi    ; restore division bits Hi
; --------------------------------------------------------------------------------------------------------------------- ;
; Draw Item: add start item column to hires color screen row address
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabWrkHiRes_Color_RowAdr_Lo ; start of hires color char screen row address Lo
                            adc CCZ_Draw_T0_PosX_Start_Lo   ; add start item column Lo
                            sta TabWrkHiRes_Color_RowAdr_Lo ; 
                            
                            lda TabWrkHiRes_Color_RowAdr_Hi ; start of hires color char screen row address Hi
                            adc CCZ_Draw_T0_PosX_Start_Hi   ; add start item column Hi
                            sta TabWrkHiRes_Color_RowAdr_Hi ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; test the different item types
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_Parm_ItemType    ; get draw item parm Type
                            cmp #TabWrkDraw_Parm_ItemType_2 ; test item type_2 (Pole/Ladder/Text/WA item)
                            beq RoomItemType_02             ; check: type_2 - yes
                            
                            cmp #TabWrkDraw_Parm_ItemType_0 ; test item type_0
                            bne RoomItemType_01             ; check: type_0 - no: was type_1
; --------------------------------------------------------------------------------------------------------------------- ;
; was item type_0 - simply set PosY top and bottom values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get draw item parm: PosY - top of item
                            sta TabWrkDraw_PosY_Top         ; set global top of item
                            
                            lda TabWrkDraw_T0_PosY_Bot      ; get bottom of item
                            sta TabWrkDraw_PosY_Bot         ; set global bottom of item
                            
                            jmp IniBitmapWorkAdr            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; was item type_1 - simply set PosY top and bottom values
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemType_01             lda TabWrkDraw_T1_Parm_ItemPosY ; get item type_1 parm PosY
                            sta TabWrkDraw_PosY_Top         ; set global top of item
                                                              
                            lda TabWrkDraw_T1_PosY_Bot      ; get bottom of item
                            sta TabWrkDraw_PosY_Bot         ; set global bottom of item
                            
                            jmp IniBitmapWorkAdr            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; was item type_2 - compare type_0 against type_1 PosY top
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemType_02             lda TabWrkDraw_T0_Parm_ItemPosY ; get item parm type_0 top
                            cmp TabWrkDraw_T1_Parm_ItemPosY ; test item type_1 parm - top
                            beq GetDraw_T0_PosY_Top         ; check: EQ - yes: set top PosY from item type_0
                            bcc TryDraw_T1_PosY_Top         ; check: LT - yes: try to set top PosY from item type_1
                            
                            cmp #$dc                        ; 
                            bcc GetDraw_T1_PosY_Top         ; check: LT - yes: get top PosY from item type_1
                            
                            lda TabWrkDraw_T1_Parm_ItemPosY ; get item type_1 parm - top
                            cmp #$dc                        ; 
                            bcs GetDraw_T1_PosY_Top         ; check: GE - yes: get top PosY from item type_1
                            
                            jmp GetDraw_T0_PosY_Top         ; get top PosY from item type_0
; --------------------------------------------------------------------------------------------------------------------- ;
; item type_1 PosY LT item type_0 PosY
; --------------------------------------------------------------------------------------------------------------------- ;
TryDraw_T1_PosY_Top         lda TabWrkDraw_T1_Parm_ItemPosY ; get item type_1 parm - top
                            cmp #$dc                        ; 
                            bcc GetDraw_T0_PosY_Top         ; check: LT - yes: set top PosY from item type_0
                            
                            lda TabWrkDraw_T0_Parm_ItemPosY ; get item type_0 top
                            cmp #$dc                        ; 
                            bcs GetDraw_T0_PosY_Top         ; check: GE - yes: set top PosY from item type_0
                            
GetDraw_T1_PosY_Top         lda TabWrkDraw_T1_Parm_ItemPosY ; get item type_1 parm PosY - top
                            jmp SetDraw_PosY_Top            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; item type_0 PosY EQ item type_1 PosY
; --------------------------------------------------------------------------------------------------------------------- ;
GetDraw_T0_PosY_Top         lda TabWrkDraw_T0_Parm_ItemPosY ; get top PosY from item type_0
                            
SetDraw_PosY_Top            sta TabWrkDraw_PosY_Top         ; set global top PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; compare type_0 against type_1 PosY bottom
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T0_PosY_Bot      ; get item type_0 bottom
                            cmp TabWrkDraw_T1_PosY_Bot      ; test item type_1 bottom
                            beq GetDraw_T1_PosY_Bot         ; check: EQ - yes: set bottom PosY from item type_1
                            bcc TryDraw_T0_PosY_Bot         ; check: TL - yes: try to set bottom PosY from item type_0
                            
                            cmp #$dc                        ; 
                            bcc GetDraw_T0_PosY_Bot         ; check: LT - yes: set bottom PosY from item type_0
                            
                            lda TabWrkDraw_T1_PosY_Bot      ; 
                            cmp #$dc                        ; test type_1 bottom PosY max
                            bcc GetDraw_T1_PosY_Bot         ; check: LT - yes: set bottom PosY from item type1
                            
                            jmp GetDraw_T0_PosY_Bot         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TryDraw_T0_PosY_Bot         lda TabWrkDraw_T1_PosY_Bot      ; 
                            cmp #$dc                        ; 
                            bcc GetDraw_T1_PosY_Bot         ; check: LT - yes: set bottom PosY from item type_1
                            
                            lda TabWrkDraw_T0_PosY_Bot      ; 
                            cmp #$dc                        ; test type_0 bottom PosY max
                            bcs GetDraw_T1_PosY_Bot         ; check: GE - yes
                            
GetDraw_T0_PosY_Bot         lda TabWrkDraw_T0_PosY_Bot      ; 
                            sta TabWrkDraw_PosY_Bot         ; 
                            
                            jmp IniBitmapWorkAdr            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetDraw_T1_PosY_Bot         lda TabWrkDraw_T1_PosY_Bot      ; 
                            
                            sta TabWrkDraw_PosY_Bot         ; set bottom PosY
; --------------------------------------------------------------------------------------------------------------------- ;
; init hires bitmap work address to start of item row
; --------------------------------------------------------------------------------------------------------------------- ;
IniBitmapWorkAdr            lda TabWrkDraw_PosY_Top         ; get global top PosY
                            sta TabWrkDraw_PosY             ; set actual hires pixel row
; --------------------------------------------------------------------------------------------------------------------- ;
; init bitmap address pointer for item type_1
; --------------------------------------------------------------------------------------------------------------------- ;
                            tax                             ; set global top PosY as bitmap address table offset
                            lda CC_ScreenGfxRowPtr_Lo,x     ; 
                            sta CCZ_HiReScreenGfxRowAdr_Lo  ; 
                            
                            lda CC_ScreenGfxRowPtr_Hi,x     ; 
                            sta CCZ_HiReScreenGfxRowAdr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;




; --------------------------------------------------------------------------------------------------------------------- ;
; check for type_0
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextDrawItemTypeNum      lda TabWrkDraw_Parm_ItemType    ; get draw item parm Type
                            cmp #TabWrkDraw_Parm_ItemType_0 ; test type_0
                            beq ChkItemColoring             ; check: type_0 - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; was type_1: Erase the item
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T1_Row_Num       ; get actual row number
                            beq ChkItemColoring             ; 
                            
                            lda TabWrkDraw_T1_Flag          ; 
                            cmp #TabWrkDraw_T1_Flag_P1      ; test 
                            beq SetNextRowNumber            ; 
                            
                            lda TabWrkDraw_PosY             ; get actual hires pixel row
                            cmp TabWrkDraw_T1_Parm_ItemPosY ; test item type_1 parm
                            bne ChkItemColoring             ; check: 
                            
                            lda #TabWrkDraw_T1_Flag_P1      ; 
                            sta TabWrkDraw_T1_Flag          ; 
                            
SetNextRowNumber            dec TabWrkDraw_T1_Row_Num       ; dec actual row number
                            
                            lda TabWrkDraw_PosY             ; get actual hires pixel row
                            cmp #$c8                        ; test max hires pixel rows
                            bcs SetNextItem_T1_DataRowAdr   ; check: GE - yes: advance pointer to next item data row
; --------------------------------------------------------------------------------------------------------------------- ;
; set item multi color column start
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T1_Col_Min       ; get leftmost item col number
                            sta TabWrkDraw_Col_Num          ; set actual item color column
; --------------------------------------------------------------------------------------------------------------------- ;
; init add hires screen graphic pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_HiReScreenGfxRowAdr_Lo  ; 
                            adc TabWrkDraw_T1_Gfx_ColAdr_Lo ; TabWrkDraw_T1_PosX_Start * $02
                            sta CCZ_HiReScreenGfxAdr_Lo     ; 
                            
                            lda CCZ_HiReScreenGfxRowAdr_Hi  ; 
                            adc TabWrkDraw_T1_Gfx_ColAdr_Hi ; TabWrkDraw_T1_PosX_Start * $02
                            sta CCZ_HiReScreenGfxAdr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; item type_1: erase graphic loop
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; init offset
EraseNextItem_T1_Byte       lda TabWrkDraw_Col_Num          ; get actual item color column
                            cmp #LLEN                       ; test max col single line
                            bcs SetNextItem_T1_GfxCol       ; check: GE - yes
                            
                            lda (CCZ_ItemDataPtr),y         ; get existing graphic byte
                            eor #$ff                        ; flip bits
                            and (CCZ_HiReScreenGfxAdr),y    ; insert item graphic byte
                            sta (CCZ_HiReScreenGfxAdr),y    ; set new item graphic byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance hires screen graphic pointer to next graphic column
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextItem_T1_GfxCol       lda TabWrkDraw_Col_Num          ; get actual item color column
                            cmp TabWrkDraw_T1_Col_Max       ; test rightmost item col number
                            beq SetNextItem_T1_DataRowAdr   ; check: EQ - yes: advance pointer to next item data row
                            
                            clc                             ; 
                            lda CCZ_HiReScreenGfxAdr_Lo     ; 
                            adc #$07                        ; add graphic block width
                            sta CCZ_HiReScreenGfxAdr_Lo     ; 
                            bcc IncRoomGrid_T1_ColNum       ; check: overflow - no
                            inc CCZ_HiReScreenGfxAdr_Hi     ; 
                            
IncRoomGrid_T1_ColNum       inc TabWrkDraw_Col_Num          ; inc actual item color column
                            
                            iny                             ; inc offset
                            jmp EraseNextItem_T1_Byte       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance item data pointer to next data row address
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextItem_T1_DataRowAdr   clc                             ; 
                            lda CCZ_ItemDataPtr_Lo          ; 
                            adc TabWrkDraw_T1_Hdr_Cols      ; add number of item col bytes from item header
                            sta CCZ_ItemDataPtr_Lo          ; 
                            bcc ChkItemColoring             ; check: overflow - no
                            inc CCZ_ItemDataPtr_Hi          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if coloring is required
; --------------------------------------------------------------------------------------------------------------------- ;
ChkItemColoring             lda TabWrkDraw_Parm_ItemType    ; get draw item parm Type
                            cmp #TabWrkDraw_Parm_ItemType_1 ; test item type_1: erase item
                            beq CheckDrawItem_Finish        ; check: type_1 - yes: see if item is completey draws
                            
                            lda TabWrkDraw_T0_Row_Num       ; get actual item pixel height row number
                            beq CheckDrawItem_Finish        ; check: ZERO - yes: see if item is completey draws
; --------------------------------------------------------------------------------------------------------------------- ;
; handle item part
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T0_Flag          ; get flag item part
                            cmp #TabWrkDraw_T0_Flag_P1      ; test flag item part #1
                            beq DecItemHeightNum            ; check: EQ - yes
                            
                            lda TabWrkDraw_PosY             ; get actual hires pixel row
                            cmp TabWrkDraw_T0_Parm_ItemPosY ; test top of item
                            bne CheckDrawItem_Finish        ; check: EQ - no: see if item is completey draws
                            
                            lda #TabWrkDraw_T0_Flag_P1      ; 
                            sta TabWrkDraw_T0_Flag          ; set flag item part #1
                            
DecItemHeightNum            dec TabWrkDraw_T0_Row_Num       ; dec actual item pixel height row number
                            
                            lda TabWrkDraw_PosY             ; get actual hires pixel row
                            cmp #$c8                        ; test max hires pixel rows
                            bcs SetNextItem_T0_DataRowAdr   ; check: GE - yes: advance pointer to next item data row
; --------------------------------------------------------------------------------------------------------------------- ;
; set item hires graphic pointer for item type_0
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDraw_T0_Col_Min       ; leftmost item col number
                            sta TabWrkDraw_Col_Num          ; get actual item color column
                            
                            lda CCZ_HiReScreenGfxRowAdr_Lo  ; 
                            clc                             ; 
                            adc TabWrkDraw_T0_Gfx_ColAdr_Lo ; TabWrkDraw_T0_PosX_Start * $02
                            sta CCZ_HiReScreenGfxAdr_Lo     ; 
                            
                            lda CCZ_HiReScreenGfxRowAdr_Hi  ; 
                            adc TabWrkDraw_T0_Gfx_ColAdr_Hi ; TabWrkDraw_T0_PosX_Start * $02
                            sta CCZ_HiReScreenGfxAdr_Hi     ; 
                            
                            ldy #$00                        ; 
DrawNextItem_T0_GfxColByte  lda TabWrkDraw_Col_Num          ; get actual item color column
                            cmp #LLEN                       ; test max col single line
                            bcs SetNextItem_T0_GfxCol       ; check: GE - yes
                            
                            lda (CCZ_ItemData_T0_Ptr),y     ; get existing graphic byte
                            ora (CCZ_HiReScreenGfxAdr),y    ; insert item graphic byte
                            sta (CCZ_HiReScreenGfxAdr),y    ; set new item graphic byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance hires screen graphic pointer to next graphic column
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextItem_T0_GfxCol       lda TabWrkDraw_Col_Num          ; get actual item color column
                            cmp TabWrkDraw_T0_Col_Max       ; test rightmost item col number
                            beq SetNextItem_T0_DataRowAdr   ; check: EQ - yes: advance pointer to next item data row
                            
                            clc                             ; 
                            lda CCZ_HiReScreenGfxAdr_Lo     ; 
                            adc #$07                        ; 
                            sta CCZ_HiReScreenGfxAdr_Lo     ; 
                            bcc IncRoomGrid_T0_ColNum       ; check: overflow - no
                            inc CCZ_HiReScreenGfxAdr_Hi     ; 
                            
IncRoomGrid_T0_ColNum       iny                             ; 
                            
                            inc TabWrkDraw_Col_Num          ; inc actual item color column
                            jmp DrawNextItem_T0_GfxColByte  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance item data pointer to next data row address
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextItem_T0_DataRowAdr   clc                             ; 
                            lda CCZ_ItemData_T0_Ptr_Lo      ; 
                            adc TabWrkDraw_T0_Hdr_Cols      ; add number of item col bytes from item header
                            sta CCZ_ItemData_T0_Ptr_Lo      ; 
                            bcc CheckDrawItem_Finish        ; check: overflow - no: see if item is completey draws
                            inc CCZ_ItemData_T0_Ptr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; see if item is completey draws - color the item then - otherwise advance row pointers and continue
; --------------------------------------------------------------------------------------------------------------------- ;
CheckDrawItem_Finish        lda TabWrkDraw_PosY             ; get actual hires pixel row
                            cmp TabWrkDraw_PosY_Bot         ; test max
                            beq TryColorItem_Type_0         ; check: EQ - yes: done - try to color the item
; --------------------------------------------------------------------------------------------------------------------- ;
; advance actual item row marker
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkDraw_PosY             ; inc actual hires pixel row
                            
                            lda TabWrkDraw_PosY             ; get actual hires pixel row
                            and #$07                        ; isolate full byte pixel amount
                            beq IncHiResScreenRowAdr        ; check: item hires byte complete - yes: set next hires screen row
; --------------------------------------------------------------------------------------------------------------------- ;
; no new row - simply advance hires screen row address pointer to next col
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_HiReScreenGfxRowAdr_Lo  ; 
                            bne ContinuePaintLoop           ; check: overflow - no: continue
                            inc CCZ_HiReScreenGfxRowAdr_Hi  ; 
                            
                            jmp ContinuePaintLoop           ; continue - bypass advance to next hires row
; --------------------------------------------------------------------------------------------------------------------- ;
; advance hires screen row address pointer to next row
; --------------------------------------------------------------------------------------------------------------------- ;
IncHiResScreenRowAdr        clc                             ; 
                            lda CCZ_HiReScreenGfxRowAdr_Lo  ; 
                            adc #<$140 - $07                ; add $140 (320) - subtract the processed hires byte
                            sta CCZ_HiReScreenGfxRowAdr_Lo  ; 
                            
                            lda CCZ_HiReScreenGfxRowAdr_Hi  ; 
                            adc #>$140 - $07                ; add $140 (320) - subtract the processed hires byte
                            sta CCZ_HiReScreenGfxRowAdr_Hi  ; 
                            
ContinuePaintLoop           jmp GetNextDrawItemTypeNum      ; continue
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            

                            
; --------------------------------------------------------------------------------------------------------------------- ;
; finally color the item
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st: handle the possible multi color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TryColorItem_Type_0         lda TabWrkDraw_Parm_ItemType    ; get draw item parm Type
                            cmp #TabWrkDraw_Parm_ItemType_1 ; test item type_1
                            bne HandleFlagSetMultiColorByte ; check: type_1 - no: was type_0 - test if a color byte can be set
                            
                            jmp RoomItemDrawX               ; completely done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; a color byte can be set only if on full byte boundary
; --------------------------------------------------------------------------------------------------------------------- ;
HandleFlagSetMultiColorByte lda TabWrkDraw_T0_Parm_ItemPosY ; get top of item
                            and #$07                        ; isolate full byte pixel amount
                            beq GetFlagSetMultiColorByte    ; check: full byte boundary - yes: get flag: set color
                            
                            lda #TabWrkDrawColorByteFlag_No ; get flag: do not write a color byte
                            jmp SetFlagSetMultiColorByte    ; 
                            
GetFlagSetMultiColorByte    lda #TabWrkDrawColorByteFlag_Yes; get flag: write a color byte
                            
SetFlagSetMultiColorByte    sta TabWrkDrawColorByteFlag     ; set flag color byte write
                            
                            lda TabWrkDraw_T0_Row_Top_Lo    ; 
                            sta TabWrkDraw_PosY             ; set actual hires pixel row
; --------------------------------------------------------------------------------------------------------------------- ;
; init multi color screen pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda #<CC_ScreenMultiColors      ; 
                            adc TabWrkHiRes_Color_RowAdr_Lo ; start of hires color char screen row address Lo
                            sta CCZ_HiResColor_RowPtr_Lo    ; 
                            
                            lda #>CC_ScreenMultiColors      ; 
                            adc TabWrkHiRes_Color_RowAdr_Hi ; start of hires color char screen row address Hi
                            sta CCZ_HiResColor_RowPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; item multi color loop: test if already on max screen row
; --------------------------------------------------------------------------------------------------------------------- ;
TryNextSetHiresScreenColor  lda TabWrkDraw_PosY             ; get actual hires pixel row
                            cmp #NLINES                     ; test max screen lines - $19 (25) rows
                            bcs TryNextMultiColorRow        ; check: GE - yes: done
; --------------------------------------------------------------------------------------------------------------------- ;
; set item multi colors
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; 
                            lda TabWrkDraw_T0_Col_Min       ; leftmost item col number
                            sta TabWrkDraw_Col_Num          ; set actual item color column
                            
SetNextItemMultiColorColor  lda TabWrkDraw_Col_Num          ; get actual item color column
                            cmp #LLEN                       ; test max col single line
                            bcs IncMultiColorDataOff        ; check: GE - yes: skip coloring
                            
                            lda (CCZ_ItemData_T0_Ptr),y     ; get item data color byte
                            sta (CCZ_HiResColor_RowPtr),y   ; set hires color byte
                            
IncMultiColorDataOff        iny                             ; 
                            
                            lda TabWrkDraw_Col_Num          ; get actual item color column
                            cmp TabWrkDraw_T0_Col_Max       ; test rightmost item col number
                            beq TryNextMultiColorRow        ; 
                            
                            inc TabWrkDraw_Col_Num          ; inc actual item color column
                            jmp SetNextItemMultiColorColor  ; continue coloring
; --------------------------------------------------------------------------------------------------------------------- ;
TryNextMultiColorRow        lda TabWrkDraw_PosY             ; get actual hires pixel row
                            cmp TabWrkDraw_T0_Row_Bot       ; test item max char row number
                            beq TestMultiColorByteFlag      ; 
                            
                            inc TabWrkDraw_PosY             ; inc actual hires pixel row
; --------------------------------------------------------------------------------------------------------------------- ;
; advance item color data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_ItemData_T0_Ptr_Lo      ; 
                            adc TabWrkDraw_T0_Hdr_Cols      ; add number of item col bytes from item header
                            sta CCZ_ItemData_T0_Ptr_Lo      ; 
                            bcc AdvanceMultiColorRowPtr     ; check: overflow - no: point to next multi color row
                            inc CCZ_ItemData_T0_Ptr_Hi      ; 
                            
                            jmp AdvanceMultiColorRowPtr     ; point to next multi color row
; --------------------------------------------------------------------------------------------------------------------- ;
TestMultiColorByteFlag      lda TabWrkDrawColorByteFlag     ; get flag color byte write
                            cmp #TabWrkDrawColorByteFlag_No ; test flag: do not write a color byte
                            bne AdvanceItemColorDataRowPtr  ; check: EQ - no: point to next multi color row
                                                              
                            lda #TabWrkDrawColorByteFlag_Yes; get flag: write a color byte
                            sta TabWrkDrawColorByteFlag     ; reset flag color byte write
                                                              
                            lda TabWrkDraw_PosY             ; get actual hires pixel row
                            cmp #$ff                        ; test a possible max
                            beq AdvanceMultiColorRowPtr     ; check: EQ - yes: point to next multi color row
                            
                            cmp #NLINES - $01               ; test max screen lines - $19 (25) rows
                            bcs AdvanceItemColorDataRowPtr  ; set next item color data row
; --------------------------------------------------------------------------------------------------------------------- ;
; advance hires color screen pointer to next row
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceMultiColorRowPtr     clc                             ; 
                            lda CCZ_HiResColor_RowPtr_Lo    ; 
                            adc #LLEN                       ; add single line length of $28 (40) columns
                            sta CCZ_HiResColor_RowPtr_Lo    ; 
                            bcc TryNextSetHiresScreenColor  ; check: overflow - no: try next hires color loop
                            inc CCZ_HiResColor_RowPtr_Hi    ; 
                            
                            jmp TryNextSetHiresScreenColor  ; try next hires color loop
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd: handle the possible coloram bytes
; --------------------------------------------------------------------------------------------------------------------- ;
; advance item color data pointer to coloram color data
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceItemColorDataRowPtr  clc                             ; 
                            lda CCZ_ItemData_T0_Ptr_Lo      ; 
                            adc TabWrkDraw_T0_Hdr_Cols      ; add number of item col bytes from item header
                            sta CCZ_ItemData_T0_Ptr_Lo      ; 
                            bcc HandleFlagSetColoramByte    ; check: overflow - no
                            inc CCZ_ItemData_T0_Ptr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; a color byte can be set only if on full byte boundary
; --------------------------------------------------------------------------------------------------------------------- ;
HandleFlagSetColoramByte    lda TabWrkDraw_T0_Parm_ItemPosY ; get top of item
                            and #$07                        ; isolate full byte pixel amount
                            beq GetFlagSetColoramByte       ; check: full byte boundary - yes: get flag: set color
                            
                            lda #TabWrkDrawColorByteFlag_No ; get flag: do not write a color byte
                            jmp SetFlagSetColoramByte       ; 
                            
GetFlagSetColoramByte       lda #TabWrkDrawColorByteFlag_Yes; get flag: write a color byte
                            
SetFlagSetColoramByte       sta TabWrkDrawColorByteFlag     ; set flag color byte write
                            
                            lda TabWrkDraw_T0_Row_Top_Lo    ; 
                            sta TabWrkDraw_PosY             ; set actual hires pixel row
; --------------------------------------------------------------------------------------------------------------------- ;
; init coloram screen pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda #<COLORAM                   ; 
                            adc TabWrkHiRes_Color_RowAdr_Lo ; start of coloram row address Lo
                            sta CCZ_HiResColor_RowPtr_Lo    ; 
                            
                            lda #>COLORAM                   ; 
                            adc TabWrkHiRes_Color_RowAdr_Hi ; start of coloram row address Hi
                            sta CCZ_HiResColor_RowPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; write item coloram loop: test if already on max screen row
; --------------------------------------------------------------------------------------------------------------------- ;
TryNextColoramColorRow      lda TabWrkDraw_PosY             ; get actual coloram row
                            cmp #NLINES                     ; test max screen lines - $19 (25) rows
                            bcs TryNextColoramRow           ; check: GE - yes: done
; --------------------------------------------------------------------------------------------------------------------- ;
; set item coloram colors
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; set item color data offset
                            lda TabWrkDraw_T0_Col_Min       ; get leftmost item column number
                            sta TabWrkDraw_Col_Num          ; set actual item color column
                            
SetNextItemColoramColor     lda TabWrkDraw_Col_Num          ; get actual item coloram column
                            cmp #LLEN                       ; test max column of a single screen row
                            bcs IncColoramDataOff           ; check: GE - yes: skip coloring
                            
                            lda (CCZ_ItemData_T0_Ptr),y     ; get item data coloram byte
                            sta (CCZ_HiResColor_RowPtr),y   ; set coloram byte
                            
IncColoramDataOff           iny                             ; inc item coloram data offset
                            
                            lda TabWrkDraw_Col_Num          ; get actual item coloram column
                            cmp TabWrkDraw_T0_Col_Max       ; test rightmost item column number
                            beq TryNextColoramRow           ; check: EQ - yes: done with this row - set next
                            
                            inc TabWrkDraw_Col_Num          ; inc actual item coloram column
                            jmp SetNextItemColoramColor     ; continue coloring
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
TryNextColoramRow           lda TabWrkDraw_PosY             ; get actual coloram row
                            cmp TabWrkDraw_T0_Row_Bot       ; test item max coloram row number
                            beq TestColoramByteFlag         ; check: EQ - yes: test flag write coloram byte
                            
                            inc TabWrkDraw_PosY             ; inc actual coloram row
; --------------------------------------------------------------------------------------------------------------------- ;
; advance item color data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_ItemData_T0_Ptr_Lo      ; 
                            adc TabWrkDraw_T0_Hdr_Cols      ; add number of item column bytes from item header
                            sta CCZ_ItemData_T0_Ptr_Lo      ; 
                            bcc AdvanceColoramRowPtr        ; check: check overflow - no: point to next multi color row
                            inc CCZ_ItemData_T0_Ptr_Hi      ; 
                            
                            jmp AdvanceColoramRowPtr        ; point to next coloram row
; --------------------------------------------------------------------------------------------------------------------- ;
; test if all color data is processed
; --------------------------------------------------------------------------------------------------------------------- ;
TestColoramByteFlag         lda TabWrkDrawColorByteFlag     ; get flag color byte write
                            cmp #TabWrkDrawColorByteFlag_No ; test flag: do not write a color byte
                            bne RoomItemDrawX               ; check: EQ - no: completely done - exit
                            
                            lda #TabWrkDrawColorByteFlag_Yes; get flag: write a color byte
                            sta TabWrkDrawColorByteFlag     ; reset flag color byte write
                            
                            lda TabWrkDraw_PosY             ; get actual coloram row
                            cmp #$ff                        ; test a possible max
                            beq AdvanceColoramRowPtr        ; check: EQ - yes: point to next coloram row
                            
                            cmp #NLINES - $01               ; test max screen lines - $19 (25) rows
                            bcs RoomItemDrawX               ; check: GE - yes: competely done - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; advance hires color screen pointer to next row
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceColoramRowPtr        clc                             ; 
                            lda CCZ_HiResColor_RowPtr_Lo    ; 
                            adc #LLEN                       ; add a single line - $28 (40) columns
                            sta CCZ_HiResColor_RowPtr_Lo    ; 
                            bcc TryNextColoramColorRow      ; check: overflow - no
                            inc CCZ_HiResColor_RowPtr_Hi    ; 
                            
                            jmp TryNextColoramColorRow      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomItemDrawX               pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDraw_PosY             .byte $a0 ; actual hires pixel row
TabWrkDraw_PosY_Top         .byte $94 ; global item PosY top
TabWrkDraw_PosY_Bot         .byte $a9 ; global item PosY bottom
; --------------------------------------------------------------------------------------------------------------------- ;
; RoomItemDraw calling parameter: Type
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDraw_Parm_ItemType    .byte $8a ; draw item parm Type
TabWrkDraw_Parm_ItemType_0      = $00 ; draw  item
TabWrkDraw_Parm_ItemType_1      = $01 ; erase item
TabWrkDraw_Parm_ItemType_2      = $02 ; update item (erase/draw) - Pole/Ladder/Text/WA item
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDraw_Col_Num          .byte $cf ; actual item column number
; --------------------------------------------------------------------------------------------------------------------- ;
; RoomItemDraw calling parms for Type_0 - draw an item
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDraw_T0_Parm_ItemNum  .byte $9e ; draw item parm Item Number
TabWrkDraw_T0_Parm_ItemPosY .byte $a0 ; draw item parm PosY
TabWrkDraw_T0_Parm_ItemPosX .byte $c5 ; draw item parm PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; RoomItemDraw working set for type_0 - draw an item
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDraw_T0_PosY_Bot      .byte $ff ; item bottom
TabWrkDraw_T0_Hdr_Cols      .byte $c5 ; number of item col bytes from item header
TabWrkDraw_T0_Hdr_Rows      .byte $e5 ; number of item pixel rows from item header
TabWrkDraw_T0_Row_Num       .byte $a0 ; actual row number
TabWrkDraw_T0_Gfx_ColAdr_Lo = *       ; hires screen graphic col address offset Lo (TabWrkDraw_T0_PosX_Start * $02)
TabWrkDraw_T0_PosX_Start    .byte $a0 ; draw item parm PosX minus the item global starting offset of $10
TabWrkDraw_T0_Gfx_ColAdr_Hi = *       ; hires screen graphic col address offset Hi (TabWrkDraw_T0_PosX_Start * $02)
TabWrkDraw_T0_PosX_Start_Hi .byte $9e ; 
TabWrkDraw_T0_Col_Min       .byte $95 ; leftmost item col number
TabWrkDraw_T0_Col_Max       .byte $b9 ; rightmost item col number
TabWrkDraw_T0_Flag          .byte $90 ; 
TabWrkDraw_T0_Flag_P0           = $00 ; item part #0
TabWrkDraw_T0_Flag_P1           = $01 ; item part #1
; --------------------------------------------------------------------------------------------------------------------- ;
; RoomItemDraw calling parms for Type_1 - erase an item
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDraw_T1_Parm_ItemNum  .byte $80 ; draw item parm Item Number
TabWrkDraw_T1_Parm_ItemPosY .byte $b8 ; draw item parm PosY
TabWrkDraw_T1_Parm_ItemPosX .byte $c5 ; draw item parm PosX
; --------------------------------------------------------------------------------------------------------------------- ;
; RoomItemDraw working set for type_1 - erase an item
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDraw_T1_PosY_Bot      .byte $a0 ; item bottom
TabWrkDraw_T1_Hdr_Cols      .byte $af ; number of item col bytes from item header
TabWrkDraw_T1_Hdr_Rows      .byte $ba ; number of item pixel rows from item header
TabWrkDraw_T1_Row_Num       .byte $d5 ; actual row number
TabWrkDraw_T1_Gfx_ColAdr_Lo = *       ; hires screen graphic col address offset Lo (TabWrkDraw_T1_PosX_Start * $02)
TabWrkDraw_T1_PosX_Start    .byte $a0 ; draw item parm PosX minus the item global starting offset of $10
TabWrkDraw_T1_Gfx_ColAdr_Hi = *       ; hires screen graphic col address offset Hi (TabWrkDraw_T1_PosX_Start * $02)
TabWrkDraw_T1_PosX_Start_Hi .byte $a0 ; 
TabWrkDraw_T1_Col_Min       .byte $d0 ; leftmost item col number
TabWrkDraw_T1_Col_Max       .byte $d9 ; rightmost item col number
TabWrkDraw_T1_Flag          .byte $8a ; 
TabWrkDraw_T1_Flag_P0           = $00 ; item part #0
TabWrkDraw_T1_Flag_P1           = $01 ; item part #1
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkDraw_T0_Row_Top_Lo    .byte $e6 ; item char row number
TabWrkDraw_T0_Row_Bot       .byte $b1 ; item max char row number
; --------------------------------------------------------------------------------------------------------------------- ;
; misc
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkHiRes_Color_RowAdr_Lo .byte $a0 ; start of hires color char screen row address Lo
TabWrkHiRes_Color_RowAdr_Hi .byte $ff ; start of hires color char screen row address Hi

TabWrkDrawColorByteFlag     .byte $a0 ; flag color byte write
TabWrkDrawColorByteFlag_Yes     = $00 ; write a color byte
TabWrkDrawColorByteFlag_No      = $01 ; do not write a color byte
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextScreenRowAdr_Lo      = *       ; 
                            .byte $a5 ; $00 - 0000
                            .byte $a0 ; $01 - 0028
                            .byte $f0 ; $02 - 0050
                            .byte $a0 ; $03 - 0078
                            .byte $a0 ; $04 - 00a0
                            .byte $a1 ; $05 - 00c8
                            .byte $a0 ; $06 - 00f0
                            .byte $a0 ; $07 - 0118
                            .byte $a0 ; $08 - 0140
                            .byte $80 ; $09 - 0168
                            .byte $a0 ; $0a - 0190
                            .byte $a0 ; $0b - 01b8
                            .byte $98 ; $0c - 01e0
                            .byte $a0 ; $0d - 0208
                            .byte $cc ; $0e - 0230
                            .byte $b7 ; $0f - 0258
                            .byte $a0 ; $10 - 0280
                            .byte $a0 ; $11 - 02a8
                            .byte $b0 ; $12 - 02d0
                            .byte $85 ; $13 - 02f8
                            .byte $c4 ; $14 - 0320
                            .byte $ad ; $15 - 0348
                            .byte $a0 ; $16 - 0370
                            .byte $83 ; $17 - 0398
                            .byte $a0 ; $18 - 03c0
                            
                            .byte $e8 ; $19 - 03e8
                            .byte $a0 ; $1a - 0410
                            .byte $a0 ; $1b - 0438
                            .byte $c3 ; $1c - 0460
                            .byte $d5 ; $1d - 0488
                            .byte $fb ; $1e - 04b0
                            .byte $d0 ; $1f - 04d8
TabTextScreenRowAdr_Len     = * - TabTextScreenRowAdr_Lo ; number of entries
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextScreenRowAdr_Hi      = *       ; 
                            .byte $a0 ; $00 - 0000
                            .byte $e0 ; $01 - 0028
                            .byte $c4 ; $02 - 0050
                            .byte $e9 ; $03 - 0078
                            .byte $a0 ; $04 - 00a0
                            .byte $af ; $05 - 00c8
                            .byte $c3 ; $06 - 00f0
                            .byte $a0 ; $07 - 0118
                            .byte $b5 ; $08 - 0140
                            .byte $d3 ; $09 - 0168
                            .byte $89 ; $0a - 0190
                            .byte $c2 ; $0b - 01b8
                            .byte $94 ; $0c - 01e0
                            .byte $c4 ; $0d - 0208
                            .byte $a0 ; $0e - 0230
                            .byte $c3 ; $0f - 0258
                            .byte $a0 ; $10 - 0280
                            .byte $d6 ; $11 - 02a8
                            .byte $a0 ; $12 - 02d0
                            .byte $88 ; $13 - 02f8
                            .byte $a0 ; $14 - 0320
                            .byte $a0 ; $15 - 0348
                            .byte $c5 ; $16 - 0370
                            .byte $a0 ; $17 - 0398
                            .byte $86 ; $18 - 03c0
                            
                            .byte $a0 ; $19 - 03e8
                            .byte $89 ; $1a - 0410
                            .byte $a0 ; $1b - 0438
                            .byte $f5 ; $1c - 0460
                            .byte $b6 ; $1d - 0488
                            .byte $c3 ; $1e - 04b0
                            .byte $97 ; $1f - 04d8
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; SpriteDataUncompress      Does    : uncompress sprite data and set sprite attributes
;                           Expects : .X=offset sprite WA block
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDataUncompress       .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set up the sprite data address table pointer for the selected sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Num,x          ; get sprite number from sprite WA block
                            sta CCZ_SprtDataAdrTabPtr_Lo    ; 
                            lda #$00                        ; 
                            sta CCZ_SprtDataAdrTabPtr_Hi    ; 
                            
                            asl CCZ_SprtDataAdrTabPtr_Lo    ; *2
                            rol CCZ_SprtDataAdrTabPtr_Hi    ; make it a word for the sprite data address table offset
                            
                            clc                             ; 
                            lda CCZ_SprtDataAdrTabPtr_Lo    ; add the sprite data address table start address
                            adc #<TabDataAdr_Items          ; 
                            sta CCZ_SprtDataAdrTabPtr_Lo    ; 
                            
                            lda CCZ_SprtDataAdrTabPtr_Hi    ; 
                            adc #>TabDataAdr_Items          ; 
                            sta CCZ_SprtDataAdrTabPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set up the sprite source data pointer for the selected sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; set offset CCZ_SpriteDataSourcePtr word Lo
                            lda (CCZ_SprtDataAdrTabPtr),y   ; get address sprite data Lo
                            sta CCZ_SpriteDataSourcePtr_Lo  ; 
                            
                            iny                             ; set offset CCZ_SpriteDataSourcePtr word Hi
                            lda (CCZ_SprtDataAdrTabPtr),y   ; get address sprite data Hi
                            sta CCZ_SpriteDataSourcePtr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; handle the sprite source header data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabData_Hdr_Off_Attr        ; set offset sprite attributes
                            lda (CCZ_SpriteDataSourcePtr),y ; get sprite attributes
                            sta CC_WA_Sprite_Attr,x         ; 
                            
                            ldy #TabData_Hdr_Off_Cols        ; set offset sprite number of columns
                            lda (CCZ_SpriteDataSourcePtr),y ; get sprite columns
                            sta TabWrkSprite_Col_Count      ; set sprite column count
                            
                            asl a                           ; *2
                            asl a                           ; *4
                            sta CC_WA_Sprite_Cols,x         ; 
                            
                            ldy #TabData_Hdr_Off_Rows        ; set offset sprite number of rows
                            lda (CCZ_SpriteDataSourcePtr),y ; get sprite rows
                            sta CC_WA_Sprite_Rows,x         ; 
                            
                            txa                             ; get offset sprite WA
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
                            lsr a                           ; /32 = sprite WA number
                            sta TabWrkSprite_WA_Num         ; 
                            
                            tay                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; select CC_MemSpriteDataBuf_1 ($20=$0800) or CC_MemSpriteDataBuf_2 ($28=$0a00)
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_TabSprtDataPtrs_Long,y  ; 
                            eor #$08                        ; ....#... - flip bit3 - select $20 or $28
                            sta CCZ_SpriteDataTargetPtr_Lo  ; 
                            lda #$00                        ; 
                            sta CCZ_SpriteDataTargetPtr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; calc sprite data target buffer offset $0800 or $0a00
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl CCZ_SpriteDataTargetPtr_Lo  ; *2
                            rol CCZ_SpriteDataTargetPtr_Hi  ; 
                            asl CCZ_SpriteDataTargetPtr_Lo  ; *4
                            rol CCZ_SpriteDataTargetPtr_Hi  ; 
                            asl CCZ_SpriteDataTargetPtr_Lo  ; *8
                            rol CCZ_SpriteDataTargetPtr_Hi  ; 
                            asl CCZ_SpriteDataTargetPtr_Lo  ; *16
                            rol CCZ_SpriteDataTargetPtr_Hi  ; 
                            asl CCZ_SpriteDataTargetPtr_Lo  ; *32
                            rol CCZ_SpriteDataTargetPtr_Hi  ; 
                            asl CCZ_SpriteDataTargetPtr_Lo  ; *64
                            rol CCZ_SpriteDataTargetPtr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; add sprite data buffers start address for sprite target data
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_SpriteDataTargetPtr_Lo  ; 
                            adc #<CI2PRA_VIC_BASE_3         ; add VIC base address Lo $c000-$cfff
                            sta CCZ_SpriteDataTargetPtr_Lo  ; 
                            lda CCZ_SpriteDataTargetPtr_Hi  ; 
                            adc #>CI2PRA_VIC_BASE_3         ; add VIC base address Hi $c000-$cfff
                            sta CCZ_SpriteDataTargetPtr_Hi  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; point sprite source data pointer behind sprite header
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_SpriteDataSourcePtr_Lo  ; 
                            adc #TabData_Hdr_Len             ; 
                            sta CCZ_SpriteDataSourcePtr_Lo  ; 
                            bcc IniSpriteWrkRows            ; check: 
                            inc CCZ_SpriteDataSourcePtr_Hi  ; 
                            
IniSpriteWrkRows            lda #$00                        ; get initial value
                            sta TabWrkSprite_Row_Num        ; init actual sprite row num
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite source data uncompress loop
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSpriteSrceDataOff    ldy #$00                        ; init sprite source data col offset
ChkSprtSrceCols             cpy TabWrkSprite_Col_Count      ; test actual sprite columns with this sprites column count
                            bcs GetNextEmptySpriteSrceData  ; check: GE - yes: get empty 3rd col byte
                            
                            lda (CCZ_SpriteDataSourcePtr),y ; get 1st and 2nd sprite source data byte
                            jmp SetNextSprtTargByte         ; store it
; --------------------------------------------------------------------------------------------------------------------- ;
; get 3rd sprite column empty byte
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEmptySpriteSrceData  lda #$00                        ; 3rd column byte is always empty
                            
SetNextSprtTargByte         sta (CCZ_SpriteDataTargetPtr),y ; store sprite source data byte into target buffer
                            
                            iny                             ; inc sprite col offset
                            cpy #SPRT_COLS                  ; test max cols of a row reached
                            bcc ChkSprtSrceCols             ; check: LT - yes: continue
                            
                            inc TabWrkSprite_Row_Num        ; inc actual sprite row count
                            
                            lda TabWrkSprite_Row_Num        ; get actual sprite row count
                            cmp #SPRT_ROWS                  ; test max sprite rows reached
                            beq SetSpritePtrAndAttr         ; check: EQ - yes: fully done
                            
                            cmp CC_WA_Sprite_Rows,x         ; test with actual sprite rows
                            bcs IniSprtLastRowsFillUp       ; check: GE - yes: fill up the missing rows with ZEROEs
; --------------------------------------------------------------------------------------------------------------------- ;
; advance sprite source data pointer and continue
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_SpriteDataSourcePtr_Lo  ; 
                            adc TabWrkSprite_Col_Count      ; add number of sprite columns
                            sta CCZ_SpriteDataSourcePtr_Lo  ; 
                            bcc SetNextSpriteTargetBufRow   ; check: overflow
                            inc CCZ_SpriteDataSourcePtr_Hi  ; 
                            
                            jmp SetNextSpriteTargetBufRow   ; continue with next round
; --------------------------------------------------------------------------------------------------------------------- ;
; set source pointer to empty row - fill up the missing sprite source rows with ZERO
; --------------------------------------------------------------------------------------------------------------------- ;
IniSprtLastRowsFillUp       lda #<TabWrkSprite_Row_Filler   ; 
                            sta CCZ_SpriteDataSourcePtr_Lo  ; 
                            lda #>TabWrkSprite_Row_Filler   ; 
                            sta CCZ_SpriteDataSourcePtr_Hi  ; 
                            
SetNextSpriteTargetBufRow   clc                             ; 
                            lda CCZ_SpriteDataTargetPtr_Lo  ; 
                            adc #SPRT_COLS                  ; 
                            sta CCZ_SpriteDataTargetPtr_Lo  ; 
                            bcc GetNextSpriteSrceDataOff    ; check: overflow - no: continue uncompress
                            inc CCZ_SpriteDataTargetPtr_Hi  ; 
                            
                            jmp GetNextSpriteSrceDataOff    ; continue uncompress
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite data pointer to CC_MemSpriteDataBuf_1 ($20=$0800) or CC_MemSpriteDataBuf_2 ($28=$0a00)
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpritePtrAndAttr         ldy TabWrkSprite_WA_Num         ; 
                            
                            lda CCZ_TabSprtDataPtrs_Long,y  ; 
                            eor #$08                        ; ....#... - flip bit3 - select $20 or $28
                            sta CCZ_TabSprtDataPtrs_Long,y  ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Attr,x         ; 
                            and #Sprite_Attr_Color_Mask     ; isolate sprite color
                            sta SP0COL,y                    ; VIC($D027) Color Sprite 0
; --------------------------------------------------------------------------------------------------------------------- ;
; check sprite ExpandX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Attr,x         ; 
                            bit TabFlagSprt_XXPAND          ; test flag ExpandX
                            bne Sprite_XXPAND               ; check: set - yes: Expand sprite
                            
                            lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits for clear
                            and XXPAND                      ; VIC($D01D) Sprite Scale Double Width
                            jmp SetSprite_XXPAND            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Xxpand the sprite
; --------------------------------------------------------------------------------------------------------------------- ;
Sprite_XXPAND               lda XXPAND                      ; VIC($D01D) Sprite Scale Double Width
                            asl CC_WA_Sprite_Cols,x         ; double sprite column count
                            
                            ora TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            
SetSprite_XXPAND            sta XXPAND                      ; VIC($D01D) Sprite Scale Double Width
; --------------------------------------------------------------------------------------------------------------------- ;
; check sprite ExpandY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Attr,x         ; 
                            bit TabFlagSprt_YXPAND          ; test flag ExpandY
                            bne Sprite_YXPAND               ; check: set - yes: Expand sprite
                            
                            lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits for clear
                            and YXPAND                      ; VIC($D017) Sprite Scale Double Height
                            jmp SetSprite_YXPAND            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
Sprite_YXPAND               lda YXPAND                      ; VIC($D017) Sprite Scale Double Height
                            ora TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            asl CC_WA_Sprite_Rows,x         ; 
                            
SetSprite_YXPAND            sta YXPAND                      ; VIC($D017) Sprite Scale Double Height
; --------------------------------------------------------------------------------------------------------------------- ;
; check sprite collision prio
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Attr,x         ; 
                            bit TabFlagSprt_SPBGPR          ; test flag sprite to background display priority
                            bne Sprite_SPBGPR_Behind        ; check: set - no: get sprite prio behind background
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite will be displayed in front of the background graphics data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SPBGPR                      ; VIC($D01B) Sprite to Foreground Display Priority
                            ora TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            jmp SetSprite_SPBGPR            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite will be displayed behind the background graphics data
; --------------------------------------------------------------------------------------------------------------------- ;
Sprite_SPBGPR_Behind        lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits for clear
                            and SPBGPR                      ; VIC($D01B) Sprite to Foreground Display Priority
                            
SetSprite_SPBGPR            sta SPBGPR                      ; VIC($D01B) Sprite to Foreground Display Priority
; --------------------------------------------------------------------------------------------------------------------- ;
; check sprite MultiColor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_Attr,x         ; 
                            bit TabFlagSprt_SPMC            ; test flag sprite multi color
                            bne Sprite_SPMC_Off             ; check: set - no: skip multicolor activation
                            
                            lda SPMC                        ; VIC($D01C) Sprite Multicolor
                            ora TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            jmp Sprite_SPMC                 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; multicolor for sprite will be switched off
; --------------------------------------------------------------------------------------------------------------------- ;
Sprite_SPMC_Off             lda TabSprt_VIC_BitNum,y        ; address sprite in one of the VIC sprite registers
                            eor #$ff                        ; flip all bits for clear
                            and SPMC                        ; VIC($D01C) Sprite Multicolor
                            
Sprite_SPMC                 sta SPMC                        ; VIC($D01C) Sprite Multicolor
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSprite_WA_Num         .byte $8c ; sprite work area number
TabWrkSprite_Row_Filler     .byte $00, $00 , $00 ; empty fill up values for the missing sprite source data rows
TabWrkSprite_Row_Num        .byte $a0 ; actual sprite row count
TabWrkSprite_Col_Count      .byte $8a ; number of sprite columns
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; RoomLockSearchKey         Does    : search the players pocket for a matching key to open the desired lock
;                           Expects : .A=lock color
;                           Returns : .C=0 - A key for the door color was found
;                                   : .C=1 - A key for the door color was not found
; --------------------------------------------------------------------------------------------------------------------- ;
RoomLockSearchKey          .block                           ; 
                            pha                             ; 
                            sta TabWrkLock_Color            ; save lock color
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_WA_Sprite_PlayerNum,x    ; get player number
                            beq IniKeySearch_P1             ; check: player #1 - yes: handle him
; --------------------------------------------------------------------------------------------------------------------- ;
; setup search for player #2
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CC_GameDataVar_Keys_Got_P2  ; get player #2 picked key count from castle data variables
                            sta TabWrkLock_Key_Count        ; set numer of collected keys for player #2
                            
                            lda #<CC_GameDataVar_Keys_Buf_P2; 
                            sta CCZ_KeyCollectBufPtr_Lo     ; 
                            lda #>CC_GameDataVar_Keys_Buf_P2; 
                            sta CCZ_KeyCollectBufPtr_Hi     ; 
                            
                            jmp IniKeySearch                ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; setup search for player #1
; --------------------------------------------------------------------------------------------------------------------- ;
IniKeySearch_P1             lda CC_GameDataVar_Keys_Got_P1  ; get player #1 picked key count from castle data variables
                            sta TabWrkLock_Key_Count        ; set numer of collected keys for player #1
                            
                            lda #<CC_GameDataVar_Keys_Buf_P1; 
                            sta CCZ_KeyCollectBufPtr_Lo     ; 
                            lda #>CC_GameDataVar_Keys_Buf_P1; 
                            sta CCZ_KeyCollectBufPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; search the selectd key list
; --------------------------------------------------------------------------------------------------------------------- ;
IniKeySearch                ldy #$00                        ; init key buffer offset
SearchNextKey               cpy TabWrkLock_Key_Count        ; test with numer of collected keys
                            beq SetFlagKeyFound_No          ; check: EQ - yes: search failed
                            
                            lda (CCZ_KeyCollectBufPtr),y    ; get a collected key from buffer
                            cmp TabWrkLock_Color            ; test with lock color
                            beq SetFlagKeyFound_Yes         ; check: EQ - yes: a collected key for this lock was found
                            
                            iny                             ; inc key buffer offset
                            jmp SearchNextKey               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagKeyFound_No          sec                             ; 
                            jmp RoomLockSearchKeyX          ; 
                            
SetFlagKeyFound_Yes         clc                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
RoomLockSearchKeyX          pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkLock_Key_Count        .byte $b5 ; number of collected keys
TabWrkLock_Color            .byte $d4 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GetNextRandomValue        Does    : get a random value
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextRandomValue         .block                           ; 
                            lda TabWrkRnd_Val_03            ; 
                            ror a                           ; 
                            
                            lda TabWrkRnd_Val_02            ; 
                            ror a                           ; 
                            sta TabWrkRnd_Val_01            ; 
                            
                            lda #$00                        ; 
                            rol a                           ; 
                            eor TabWrkRnd_Val_02            ; 
                            sta TabWrkRnd_Val_02            ; 
                            
                            lda TabWrkRnd_Val_01            ; 
                            eor TabWrkRnd_Val_03            ; 
                            sta TabWrkRnd_Val_03            ; 
                            
                            eor TabWrkRnd_Val_02            ; 
                            sta TabWrkRnd_Val_02            ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkRnd_Val_01            .byte $a0 ; 
TabWrkRnd_Val_02            .byte $c6 ; 
TabWrkRnd_Val_03            .byte $57 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameGetInputKeyJoy        Does    : get STOP key and player jostick input
;                           Expects : .A=player number ($00/$01)
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameGetInputKeyJoy         .block                           ; 
                            pha                             ; 
                            sta TabWrkInput_Joy_Player_Num  ; save player number
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare keybord scan
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$ff                        ; keybord scan: set all to output
                            sta CIADDRA                     ; CIA1($DC02) Data Direction Register A
                            lda #$00                        ; keybord scan: set all to input
                            sta CIADDRB                     ; CIA1($DC03) Data Direction Register B
; --------------------------------------------------------------------------------------------------------------------- ;
; select keyboard matrix row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #~CIAPRA_KEY_SEL_ROW_7      ; .####### - select matrix row 7
                            sta CIAPRA                      ; CIA1($DC00) Data Port Register A
                            
                            lda CIAPRB                      ; CIA1($DC01) Data Port Register B
                            and #CIAPRB_PB7                 ; isolate STOP key bit
                            beq GetKeyFlag_STOP             ; check: STOP key - yes: get STOP key flag
                            
                            lda #$00                        ; get flag no STOP key
                            jmp SetKeyFlag_STOP             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetKeyFlag_STOP             lda #$01                        ; 
                            
SetKeyFlag_STOP             sta TabWrkInput_Key_Stop        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get joystick input for the selected player
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkFlag_Force_IRQ_No    ; get initial value
                            sta TabWrkFlag_Force_IRQ        ; init flag force an IRQ
                            
                            lda TabWrkInput_Joy_Player_Num  ; restore player number
                            eor #$01                        ; flip player bit0
                            tax                             ; set as offset
                            
                            lda #$00                        ; joystick scan: set all to input
                            sta CIADDRA,x                   ; CIA1($DC02) Data Direction Register A
                            
                            lda CIAPRA,x                    ; CIA1($DC00) Data Port Register A
                            sta TabWrkInput_Joy_Move        ; store the joystick port scan result
                            
                            and #$0f                        ; ....#### - isolate joystick move bits
                            tax                             ; set as an offset
                            
                            lda TabJoy_Move_Subst,x         ; get the move substitution value
                            sta TabWrkInput_Joy_Move_Subst  ; set the move substitition value
                            
                            lda TabWrkInput_Joy_Move        ; 
                            and #CIAPRA_JOY_FIRE            ; isolate fire button bit
                            bne GetFlagFireNone             ; check: pressed - no
                            
                            lda #TabWrkInput_Joy_Fire_Press ; 
                            jmp SetStatusJoyFire            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetFlagFireNone             lda #TabWrkInput_Joy_Fire_None  ; 
                            
SetStatusJoyFire            sta TabWrkInput_Joy_Fire        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; restore input player number
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkInput_Joy_Move_Subst  .byte $82 ; move substitition value from TabJoy_Move_Subst
TabWrkInput_Joy_Fire        .byte $a0 ; 
TabWrkInput_Joy_Fire_None       = $00 ; 
TabWrkInput_Joy_Fire_Press      = $01 ; 
TabWrkInput_Joy_Player_Num  = *       ; 
TabWrkInput_Joy_Move        .byte $bf ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; jostick move substitution values
; ---------------------------------------------------------------+----------+----------+----------------------+-----+----
TabJoy_Move_Subst           = *                            ;     ! subst    ! input    !                      ! ok  ! bad
                                                           ; ----+----------+----------+----------------------+-----+----
                            .byte $80                      ;     ; #....... ;          ; ---------- <invalid> ;     ; $00
                            .byte $80                      ;     ; #....... ;          ; ---------- <invalid> ;     ; $01
                            .byte $80                      ;     ; #....... ;          ; ---------- <invalid> ;     ; $02
                            .byte $80                      ;     ; #....... ;          ; ---------- <invalid> ;     ; $03
                            .byte $80                      ;     ; #....... ;          ; ---------- <invalid> ;     ; $04
                            .byte TabJoy_Move_Subst_DR     ; $03 ; ......## ; ....0101 ; Down/right 0=pressed ; $05 ; 
                            .byte TabJoy_Move_Subst_UR     ; $01 ; .......# ; ....0110 ; Up/right   0=pressed ; $06 ; 
                            .byte TabJoy_Move_Subst_R      ; $02 ; ......#. ; ....0111 ; Right      0=pressed ; $07 ; 
                            .byte $80                      ;     ; #....... ;          ; ---------- <invalid> ;     ; $08
                            .byte TabJoy_Move_Subst_DL     ; $05 ; .....#.# ; ....1001 ; Down/left  0=pressed ; $09 ; 
                            .byte TabJoy_Move_Subst_UL     ; $07 ; .....### ; ....1010 ; Up/left    0=pressed ; $0a ; 
                            .byte TabJoy_Move_Subst_L      ; $06 ; .....##. ; ....1011 ; Left       0=pressed ; $0b ; 
                            .byte $80                      ;     ; #....... ;          ; ---------- <invalid> ;     ; $0c
                            .byte TabJoy_Move_Subst_D      ; $04 ; .....#.. ; ....1101 ; Down       0=pressed ; $0d ; 
                            .byte TabJoy_Move_Subst_U      ; $00 ; ........ ; ....1110 ; Up         0=pressed ; $0e ; 
                            .byte $80                      ;     ; #....... ;          ; ---------- <invalid> ;     ; $0f
; --------------------------------------------------------------------------------------------------------------------- ;
; joystick move substitution values
; --------------------------------------------------------------------------------------------------------------------- ;
TabJoy_Move_Subst_U         = %00000000 ; $00 ; Up
TabJoy_Move_Subst_UR        = %00000001 ; $01 ; Up/right
TabJoy_Move_Subst_R         = %00000010 ; $02 ; Right
TabJoy_Move_Subst_DR        = %00000011 ; $03 ; Down/right
TabJoy_Move_Subst_D         = %00000100 ; $04 ; Down
TabJoy_Move_Subst_DL        = %00000101 ; $05 ; Down/left
TabJoy_Move_Subst_L         = %00000110 ; $06 ; Left
TabJoy_Move_Subst_UL        = %00000111 ; $07 ; Up/left
TabJoy_Move_Subst_None      = %10000000 ; $80 ; no move
                            
TabJoy_Move_Subst_Mask      = %00000111 ; $07 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkInput_Key_Stop        .byte TabWrkInput_Key_Stop_No ; 
TabWrkInput_Key_Stop_Yes        = $01 ; 
TabWrkInput_Key_Stop_No         = $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkFlag_Force_IRQ        .byte $00 ; force endless IRQs
TabWrkFlag_Force_IRQ_No         = $00 ; 
TabWrkFlag_Force_IRQ_Yes        = $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSpriteMoveCtrlPtrSet  Does    : prepare and set sprite move control memory pointer
;                           Expects : .X=offset sprite work area
;                           Returns : hansi
; --------------------------------------------------------------------------------------------------------------------- ;
GameSpriteMoveCtrlPtrSet   .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosX,x         ; get this sprite PosX
                            adc CC_WA_Sprite_Width,x        ; add this sprite width
                            sta TabWrkSprite_PosX_Max       ; set this sprite PosX plus sprite width
                            
                            and #$03                        ; MOD $03 - room draw grid width
                            sta TabWrkDrawGrid_PosX_Off     ; set sprite max x-offset in draw grid ($00-$03)
; --------------------------------------------------------------------------------------------------------------------- ;
; set move control data column number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSprite_PosX_Max       ; get this sprite PosX plus sprite width
                            lsr a                           ; /2
                            lsr a                           ; /4 - room draw grid width
                            
                            sec                             ; 
                            sbc #$04                        ; subtract global room row start of $10 ($04*$04 grids)
                            sta TabWrkDrawGrid_Col_Num      ; set draw grid column number
; --------------------------------------------------------------------------------------------------------------------- ;
; sprite PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CC_WA_Sprite_PosY,x         ; get this sprite PosY
                            adc CC_WA_Sprite_Height,x       ; add this sprite height
                            sta TabWrkSprite_PosY_Max       ; set this sprite bottom PosY
                            
                            and #$07                        ; MOD $07 - room draw grid height
                            sta TabWrkDrawGrid_PosY_Off     ; set sprite max y-offset in draw grid ($00-$07)
; --------------------------------------------------------------------------------------------------------------------- ;
; set move control data row number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkSprite_PosY_Max       ; get this sprite bottom PosY
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8 - room draw grid height
                            sta TabWrkDrawGrid_Row_Num      ; set draw grid row number
                            
                            jmp GameSetMoveCtrlDataPtr.GetMoveCtrlRowNum ; bypass suboutine header
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSetMoveCtrlDataPtr    Does    : set the room move control data pointer (floors / ladders / poles)
;                           Expects : TabWrkDrawGrid_Row_Num
;                                   : TabWrkDrawGrid_Col_Num
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSetMoveCtrlDataPtr     .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; select the character screen row address
; --------------------------------------------------------------------------------------------------------------------- ;
GetMoveCtrlRowNum           ldy TabWrkDrawGrid_Row_Num      ; get draw grid row number - set as table offset
                            lda TabTextScreenRowAdr_Lo,y    ; get the screen row address Lo
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            lda TabTextScreenRowAdr_Hi,y    ; get the screen row address Hi
                            sta CCZ_MoveCtrlDataPtr_Hi      ; 
                            
                            asl CCZ_MoveCtrlDataPtr_Lo      ; *2 - each move control entry is $02 bytes long
                            rol CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; add room move control memory base address 
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_MoveCtrlDataPtr_Lo      ; 
                            adc #<CC_MoveCtrl               ; room move control data  $c000-$c7ff
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            
                            lda CCZ_MoveCtrlDataPtr_Hi      ; 
                            adc #>CC_MoveCtrl               ; room move control data  $c000-$c7ff
                            sta CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; select the drw grid column number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkDrawGrid_Col_Num      ; get draw grid column number
                            asl a                           ; *2 - each ctrl screen position occupies $02 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
; add room move control memory column number
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc CCZ_MoveCtrlDataPtr_Lo      ; 
                            sta CCZ_MoveCtrlDataPtr_Lo      ; 
                            bcc GameSetMoveCtrlDataPtrX     ; check: overflow - no
                            inc CCZ_MoveCtrlDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSetMoveCtrlDataPtrX     pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkSprite_PosX_Max       = *       ; sprite PosX plus sprite width
TabWrkDrawGrid_Col_Num      .byte $ac ; draw grid column number
TabWrkSprite_PosY_Max       = *       ; sprite PosX plus sprite height
TabWrkDrawGrid_Row_Num      .byte $85 ; draw grid row number
TabWrkDrawGrid_PosX_Off     .byte $c8 ; sprite max x-offset in draw grid ($00-$03) - sprite PosX + sprite width
TabWrkDrawGrid_PosY_Off     .byte $a0 ; sprite max y-offset in draw grid ($00-$07) - sprite PosY + sprite height
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleRoomDataPointerSet  Does    : set the room data pointer to the requested entry in the target data store
;                           Expects : .A=target room number
;                                   : TabFlagDataBufAdr flag set castle data load memory
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CastleRoomDataPointerSet   .block                           ; 
                            pha                             ; save parm target room number
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta CCZ_RoomListDataPtr_Lo      ; init castle data pointer
                            lda #$00                        ; 
                            sta CCZ_RoomListDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; each room definition data entry in room definition list has $08 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            asl CCZ_RoomListDataPtr_Lo      ; *2
                            rol CCZ_RoomListDataPtr_Hi      ; 
                            asl CCZ_RoomListDataPtr_Lo      ; *4
                            rol CCZ_RoomListDataPtr_Hi      ; 
                            asl CCZ_RoomListDataPtr_Lo      ; *8
                            rol CCZ_RoomListDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; start with game level data memory address $7900
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_RoomListDataPtr_Lo      ; 
                            adc #<CC_GameData_Room          ; room data definition start address = CC_GameDataBuf + $100
                            sta CCZ_RoomListDataPtr_Lo      ; 
                            
                            lda CCZ_RoomListDataPtr_Hi      ; 
                            adc #>CC_GameData_Room          ; room data definition address = CC_GameDataBuf + $100
                            sta CCZ_RoomListDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check flag castle data load memory
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabFlagDataBufAdr           ; $00=$7800(game) $01=$9800(load) $02=$b800(times)
                            cmp #TabFlagDataBufAdr_Load     ; test flag castle data game memory
                            bne RestoreRoomNumber           ; check: EQ - no: keep game level memory address
; --------------------------------------------------------------------------------------------------------------------- ;
; set load level data memory address $9900
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_RoomListDataPtr_Hi      ; 
                            adc #>CC_LoadDataBuf - CC_GameDataBuf ; add buffer pages - each buffer has a length of $2000 bytes
                            sta CCZ_RoomListDataPtr_Hi      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreRoomNumber           pla                             ; restore parm room number
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CastleDoorDataPointerSet  Does    : set the door address pointer to the requested door data area / set the door count
;                           Expects : .A=room door number
;                           Returns : TabWrkCastleRoomDoorCount=rooms door count
; --------------------------------------------------------------------------------------------------------------------- ;
CastleDoorDataPointerSet   .block                           ; 
                            pha                             ; 
                            sta TabWrkCastleRoomDoorNum     ; save requested door number
                            tya                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init room data pointer to address of CC_Door_Count
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Room_Ptr_DoorCount_Lo   ; get offset room door count Lo
                            lda (CCZ_RoomListDataPtr),y     ; get room door count Lo
                            sta CCZ_DoorDataPtr_Lo          ; init pointer to room door count Lo - start of room data
                            
                            iny                             ; set offset room door count Hi
                            lda (CCZ_RoomListDataPtr),y     ; get room door count Hi
                            sta CCZ_DoorDataPtr_Hi          ; init pointer to room door count Hi - start of room data
; --------------------------------------------------------------------------------------------------------------------- ;
; get the starting room door counter 1st
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_Door_Count              ; get offset room door count
                            lda (CCZ_DoorDataPtr),y         ; get room door count
                            pha                             ; save room door count
; --------------------------------------------------------------------------------------------------------------------- ;
; multiply the requested door number with the length of the door data area
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabWrkCastleRoomDoorNum     ; restore requested door number
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8 = length of room data map
; --------------------------------------------------------------------------------------------------------------------- ;
; add one byte for the starting CC_Door_Count
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$01                        ; bypass the 1st byte containing the room door count
; --------------------------------------------------------------------------------------------------------------------- ;
; set room data pointer to the address of the requested door
; --------------------------------------------------------------------------------------------------------------------- ;
                            adc CCZ_DoorDataPtr_Lo          ; pointer to start of castle room door data Lo
                            sta CCZ_DoorDataPtr_Lo          ; 
                            lda CCZ_DoorDataPtr_Hi          ; pointer to start of castle room door data Hi
                            adc #$00                        ; add carry
                            sta CCZ_DoorDataPtr_Hi          ; 
                            
                            pla                             ; restore room door count
                            sta TabWrkCastleRoomDoorCount   ; save room door count
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkCastleRoomDoorNum    = *       ; 
TabWrkCastleRoomDoorCount  .byte $a1 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; addresses of game room/map items and sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataAdr_Items             = * ;
TabSprtAdr_PlayerMoveLe_01  .word TabDataPlayerMoveLeft_01    ; Sprite
TabSprtAdr_PlayerMoveLe_02  .word TabDataPlayerMoveLeft_02    ; Sprite
TabSprtAdr_PlayerMoveLe_03  .word TabDataPlayerMoveLeft_03    ; Sprite
                            
TabSprtAdr_PlayerMoveRi_01  .word TabDataPlayerMoveRight_01   ; Sprite
TabSprtAdr_PlayerMoveRi_02  .word TabDataPlayerMoveRight_02   ; Sprite
TabSprtAdr_PlayerMoveRi_03  .word TabDataPlayerMoveRight_03   ; Sprite
                            
TabItemAdr_DoorNormal       .word TabDataDoorNormal           ; 
TabItemAdr_DoorGrate        .word TabDataDoorGrate            ; 
TabItemAdr_DoorOpen         .word TabDataDoorOpen             ; 
TabItemAdr_DoorBell         .word TabDataDoorBell             ; 
                            
TabItemAdr_MapRoomFill      .word TabDataMapRoomFill          ; 
TabItemAdr_MapRoomWall_NS   .word TabDataMapRoomWall_NS       ; 
TabItemAdr_MapRoomWall_W    .word TabDataMapRoomWall_W        ; 
TabItemAdr_MapRoomWall_E    .word TabDataMapRoomWall_E        ; 
                            
TabItemAdr_MapRoomDoorLe_NS .word TabDataMapRoomDoorLe_NS     ; 
TabItemAdr_MapRoomDoorRi_NS .word TabDataMapRoomDoorRi_NS     ; 
TabItemAdr_MapRoomDoor_E    .word TabDataMapRoomDoor_E        ; 
TabItemAdr_MapRoomDoor_W    .word TabDataMapRoomDoor_W        ; 
                            
TabSprtAdr_Arrow_Up         .word TabDataCastleMapArrowUp     ; Sprite
TabSprtAdr_Arrow_Ri         .word TabDataCastleMapArrowRight  ; Sprite
TabSprtAdr_Arrow_Do         .word TabDataCastleMapArrowDown   ; Sprite
TabSprtAdr_Arrow_Le         .word TabDataCastleMapArrowLeft   ; Sprite
                            
TabItemAdr_Graphic          .word $0000                       ; 
                            
                            .word $0000                       ; <obsolete> - not used
                            .word $0000                       ; 
                            .word $0000                       ; 
                            .word $0000                       ; 
                            
TabItemAdr_FloorStart       .word TabDataFloorStart           ; 
TabItemAdr_Floor            .word TabDataFloor                ; 
TabItemAdr_FloorEnd         .word TabDataFloorEnd             ; 
                            
TabSprtAdr_PlayerEnters_01  .word TabDataPlayerEntersRoom_01  ; Sprite
TabSprtAdr_PlayerEnters_02  .word TabDataPlayerEntersRoom_02  ; Sprite
TabSprtAdr_PlayerEnters_03  .word TabDataPlayerEntersRoom_03  ; Sprite
TabSprtAdr_PlayerEnters_04  .word TabDataPlayerEntersRoom_04  ; Sprite
TabSprtAdr_PlayerEnters_05  .word TabDataPlayerEntersRoom_05  ; Sprite
TabSprtAdr_PlayerEnters_06  .word TabDataPlayerEntersRoom_06  ; Sprite
                            
TabItemAdr_Pole             .word TabDataPole                 ; 
TabItemAdr_PoleEnd          .word TabDataPoleEnd              ; 
                            
TabSprtAdr_PlayerSlidePole  .word TabDataPlayerSlidePole      ; Sprite
                            
TabItemAdr_PoleFront        .word TabDataPoleFront            ; 
                            
TabItemAdr_Ladder           .word TabDataLadder               ; 
TabItemAdr_LadderEnd        .word TabDataLadderEnd            ; 
TabItemAdr_LadderEndCover   .word TabDataLadderEndCover       ; 
TabItemAdr_LadderTop        .word TabDataLadderTop            ; 
TabItemAdr_LadderFloor      .word TabDataLadderFloor          ; 
TabItemAdr_LadderFloorCover .word TabDataLadderFloorCover     ; 
                            
TabSprtAdr_PlayerClimb_01   .word TabDataPlayerClimbLadder_01 ; Sprite
TabSprtAdr_PlayerClimb_02   .word TabDataPlayerClimbLadder_02 ; Sprite
TabSprtAdr_PlayerClimb_03   .word TabDataPlayerClimbLadder_03 ; Sprite
TabSprtAdr_PlayerClimb_04   .word TabDataPlayerClimbLadder_04 ; Sprite
                            
TabItemAdr_LightPole        .word TabDataLightMachPole        ; 
TabItemAdr_LightOrb         .word TabDataLightMachOrb         ; 
TabItemAdr_LightPoleColor   .word TabDataLightMachPoleColor   ; 
                            
TabSprtAdr_ForceCurtain_01  .word TabDataForceFieldCurtain_01 ; Sprite
                            
TabItemAdr_LightSwitch      .word TabDataLightMachSwitchFrame ; 
TabItemAdr_LightSwitch_Up   .word TabDataLightMachSwitch_Up   ; 
TabItemAdr_LightSwitch_Do   .word TabDataLightMachSwitch_Do   ; 
                            
TabSprtAdr_SparkFlicker_01  .word TabDataLightMachSpark_01    ; Sprite
TabSprtAdr_SparkFlicker_02  .word TabDataLightMachSpark_02    ; Sprite
TabSprtAdr_SparkFlicker_03  .word TabDataLightMachSpark_03    ; Sprite
TabSprtAdr_SparkFlicker_04  .word TabDataLightMachSpark_04    ; Sprite
                            
TabSprtAdr_ForceCurtain_02  .word TabDataForceFieldCurtain_02 ; Sprite
                            
TabItemAdr_ForceFieldHead   .word TabDataForceFieldHead       ; 
TabItemAdr_ForceFieldSwitch .word TabDataForceFieldSwitch     ; 
TabItemAdr_ForceFieldTimer  .word TabDataForceFieldTimer      ; 
                            
TabSprtAdr_ForceCurtain_03  .word TabDataForceFieldCurtain_03 ; Sprite
                            
TabItemAdr_MummyWall        .word TabDataMummyWall            ; 
TabItemAdr_MummyTombOpen    .word TabDataMummyTombOpen        ; 
TabItemAdr_MummyAnkh        .word TabDataMummyAnkh            ; 
                            
TabSprtAdr_MummyOut_01      .word TabDataMummyMoveOut_01      ; Sprite
TabSprtAdr_MummyOut_02      .word TabDataMummyMoveOut_02      ; Sprite
TabSprtAdr_MummyOut_03      .word TabDataMummyMoveOut_03      ; Sprite
TabSprtAdr_MummyOut_04      .word TabDataMummyMoveOut_04      ; Sprite
TabSprtAdr_MummyOut_05      .word TabDataMummyMoveOut_05      ; Sprite
TabSprtAdr_MummyOut_06      .word TabDataMummyMoveOut_06      ; Sprite
                            
TabSprtAdr_MummyMoveLe_01   .word TabDataMummyMoveLeft_01     ; Sprite
TabSprtAdr_MummyMoveLe_02   .word TabDataMummyMoveLeft_02     ; Sprite
TabSprtAdr_MummyMoveLe_03   .word TabDataMummyMoveLeft_03     ; Sprite
                            
TabSprtAdr_MummyMoveRi_01   .word TabDataMummyMoveRight_01    ; Sprite
TabSprtAdr_MummyMoveRi_02   .word TabDataMummyMoveRight_02    ; Sprite
TabSprtAdr_MummyMoveRi_03   .word TabDataMummyMoveRight_03    ; Sprite
                            
TabItemAdr_KeyWhite         .word TabDataKeyWhite             ; 
TabItemAdr_KeyRed           .word TabDataKeyRed               ; 
TabItemAdr_KeyCyan          .word TabDataKeyCyan              ; 
TabItemAdr_KeyPurple        .word TabDataKeyPurple            ; 
TabItemAdr_KeyGreen         .word TabDataKeyGreen             ; 
TabItemAdr_KeyBlue          .word TabDataKeyBlue              ; 
TabItemAdr_KeyYellow        .word TabDataKeyYellow            ; 
                            
TabItemAdr_Lock             .word TabDataLock                 ; 
                            
                            .word $0000                       ; <obsolete> - not used
                            .word $0000                       ; 
                            .word $0000                       ; 
                            .word $0000                       ; 
                            .word $0000                       ; 
                            .word $0000                       ; 
                            
TabItemAdr_GunPole_Le       .word TabDataRayGunPoleLeft       ; 
TabItemAdr_GunPole_Ri       .word TabDataRayGunPoleRight      ; 
                            
TabItemAdr_GunLaser_Ri_01   .word TabDataRayGunLaserRight_01  ; 
TabItemAdr_GunLaser_Ri_02   .word TabDataRayGunLaserRight_02  ; 
TabItemAdr_GunLaser_Ri_03   .word TabDataRayGunLaserRight_03  ; 
TabItemAdr_GunLaser_Ri_04   .word TabDataRayGunLaserRight_04  ; 
                            
TabItemAdr_GunLaser_Le_01   .word TabDataRayGunLaserLeft_01   ; 
TabItemAdr_GunLaser_Le_02   .word TabDataRayGunLaserLeft_02   ; 
TabItemAdr_GunLaser_Le_03   .word TabDataRayGunLaserLeft_03   ; 
TabItemAdr_GunLaser_Le_04   .word TabDataRayGunLaserLeft_04   ; 
                            
                            .word $0000                       ; <obsolete> - not used
                            .word $0000                       ; 
                            .word $0000                       ; 
                            
TabSprtAdr_GunBeam          .word TabDataRayGunBeam           ; Sprite
                            
TabItemAdr_GunSwitch        .word TabDataRayGunSwitch         ; 
TabItemAdr_GunSwitchColor   .word TabDataRayGunSwitchColor    ; 
                            
TabItemAdr_XmitBooth        .word TabDataXmitBooth            ; 
TabItemAdr_XmitBoothHotSpot .word TabDataXmitBooth_HotSpot    ; 
TabItemAdr_XmitBoothBack    .word TabDataXmitBoothBack        ; 
TabItemAdr_XmitTarget       .word TabDataXmitTarget           ; 
                            
TabItemAdr_TrapMove_01      .word TabDataTrapMove_01          ; trap part #1a - 1st bottom part
TabItemAdr_TrapMove_02      .word TabDataTrapMove_02          ; trap part #1b - 2nd bottom part
TabItemAdr_TrapMove_03      .word TabDataTrapMove_03          ; trap part #2a - 1st middle part
TabItemAdr_TrapMove_04      .word TabDataTrapMove_04          ; trap part #2b - 2nd middle part
TabItemAdr_TrapMove_05      .word TabDataTrapMove_05          ; trap part #3a - 1st top part
TabItemAdr_TrapMove_06      .word TabDataTrapMove_06          ; trap part #3b - 2nd top part
                            
TabItemAdr_TrapOpen_HotSpot .word TabDataTrapOpen_HotSpot     ; 
TabItemAdr_TrapSwitch       .word TabDataTrapSwitch           ; 
TabItemAdr_TrapOpen         .word TabDataTrapOpen             ; 
                            
TabItemAdr_Blank            .word DatObjBlank                 ; 
                            
TabItemAdr_WalkBlank        .word TabDataWalkBlank            ; 
TabItemAdr_WalkMove_01      .word TabDataWalkMove_01          ; 
TabItemAdr_WalkMove_02      .word TabDataWalkMove_02          ; 
TabItemAdr_WalkMove_03      .word TabDataWalkMove_03          ; 
TabItemAdr_WalkMove_04      .word TabDataWalkMove_04          ; 
TabItemAdr_WalkSwitch       .word TabDataWalkSwitch           ; 
TabItemAdr_Walk_HotSpot     .word TabDataWalk_HotSpot         ; 
                            
TabSprtAdr_FrankMove_Ri_01  .word TabDataFrankMoveRight_01    ; Sprite
TabSprtAdr_FrankMove_Ri_02  .word TabDataFrankMoveRight_02    ; Sprite
TabSprtAdr_FrankMove_Ri_03  .word TabDataFrankMoveRight_03    ; Sprite
                            
TabSprtAdr_FrankMove_Le_01  .word TabDataFrankMoveLeft_01     ; Sprite
TabSprtAdr_FrankMove_Le_02  .word TabDataFrankMoveLeft_02     ; Sprite
TabSprtAdr_FrankMove_Le_03  .word TabDataFrankMoveLeft_03     ; Sprite
                            
TabSprtAdr_FrankSlidePole   .word TabDataFrankSlidePole       ; Sprite
                            
TabSprtAdr_FrankClimb_01    .word TabDataFrankClimbLadder_01  ; Sprite
TabSprtAdr_FrankClimb_02    .word TabDataFrankClimbLadder_02  ; Sprite
TabSprtAdr_FrankClimb_03    .word TabDataFrankClimbLadder_03  ; Sprite
TabSprtAdr_FrankClimb_04    .word TabDataFrankClimbLadder_04  ; Sprite
                            
TabSprtAdr_FrankInCoffin    .word TabDataFrankInCoffin        ; Sprite
                            
TabItemAdr_FrankCoffin_Ri   .word TabDataFrankCoffinRight     ; 
TabItemAdr_FrankCoffin_Le   .word TabDataFrankCoffinLeft      ; 
TabItemAdr_FrankCoffinClear .word TabDataFrankCoffinClear     ; clear the floor start/end pieces for coffin
                            
TabItemAdr_TimeFrame        .word TabDataCastleTimeFrame      ; 
                            
TabItemAdr_CharClear        .word TabDataCharClear            ; 
TabItemAdr_Char             .word TabDataChar                 ; 
                            
TabItemAdr_DoorExit         .word TabDataDoorExit             ; 
                            
TabSprtAdr_PlayerWave_M1    .word TabDataPlayerWaveGoodBye_Mi ; Sprite
TabSprtAdr_PlayerWave_Ri    .word TabDataPlayerWaveGoodBye_Ri ; Sprite
TabSprtAdr_PlayerWave_M2    .word TabDataPlayerWaveGoodBye_Mi ; Sprite
TabSprtAdr_PlayerWave_Le    .word TabDataPlayerWaveGoodBye_Le ; Sprite
; ------------------------------------------------------------------------------------------------------------- ;
; room item numbers
; ------------------------------------------------------------------------------------------------------------- ;
ItemNum_DoorNormal          = (TabItemAdr_DoorNormal         - TabDataAdr_Items) / 2 ; 
ItemNum_DoorExit            = (TabItemAdr_DoorExit           - TabDataAdr_Items) / 2 ; 
                            
ItemNum_DoorGrate           = (TabItemAdr_DoorGrate          - TabDataAdr_Items) / 2 ; 
ItemNum_DoorOpen            = (TabItemAdr_DoorOpen           - TabDataAdr_Items) / 2 ; 
                            
ItemNum_DoorBell            = (TabItemAdr_DoorBell           - TabDataAdr_Items) / 2 ; 
                            
ItemNum_MapRoomFill         = (TabItemAdr_MapRoomFill        - TabDataAdr_Items) / 2 ; 
ItemNum_MapRoomWall_NS      = (TabItemAdr_MapRoomWall_NS     - TabDataAdr_Items) / 2 ; 
ItemNum_MapRoomWall_W       = (TabItemAdr_MapRoomWall_W      - TabDataAdr_Items) / 2 ; 
ItemNum_MapRoomWall_E       = (TabItemAdr_MapRoomWall_E      - TabDataAdr_Items) / 2 ; 
                            
ItemNum_MapRoomDoorLe_NS    = (TabItemAdr_MapRoomDoorLe_NS   - TabDataAdr_Items) / 2 ; 
ItemNum_MapRoomDoorRi_NS    = (TabItemAdr_MapRoomDoorRi_NS   - TabDataAdr_Items) / 2 ; 
ItemNum_MapRoomDoor_E       = (TabItemAdr_MapRoomDoor_E      - TabDataAdr_Items) / 2 ; 
ItemNum_MapRoomDoor_W       = (TabItemAdr_MapRoomDoor_W      - TabDataAdr_Items) / 2 ; 
                            
ItemNum_Graphic             = (TabItemAdr_Graphic            - TabDataAdr_Items) / 2 ; 
                            
ItemNum_FloorStart          = (TabItemAdr_FloorStart         - TabDataAdr_Items) / 2 ; 
ItemNum_Floor               = (TabItemAdr_Floor              - TabDataAdr_Items) / 2 ; 
ItemNum_FloorEnd            = (TabItemAdr_FloorEnd           - TabDataAdr_Items) / 2 ; 
                            
ItemNum_Pole                = (TabItemAdr_Pole               - TabDataAdr_Items) / 2 ; 
ItemNum_PoleEnd             = (TabItemAdr_PoleEnd            - TabDataAdr_Items) / 2 ; 
                            
ItemNum_PoleFront           = (TabItemAdr_PoleFront          - TabDataAdr_Items) / 2 ; 
                            
ItemNum_Ladder              = (TabItemAdr_Ladder             - TabDataAdr_Items) / 2 ; 
ItemNum_LadderEnd           = (TabItemAdr_LadderEnd          - TabDataAdr_Items) / 2 ; 
ItemNum_LadderEndCover      = (TabItemAdr_LadderEndCover     - TabDataAdr_Items) / 2 ; 
ItemNum_LadderTop           = (TabItemAdr_LadderTop          - TabDataAdr_Items) / 2 ; 
ItemNum_LadderFloor         = (TabItemAdr_LadderFloor        - TabDataAdr_Items) / 2 ; 
ItemNum_LadderFloorCover    = (TabItemAdr_LadderFloorCover   - TabDataAdr_Items) / 2 ; 
                            
ItemNum_LightPole           = (TabItemAdr_LightPole          - TabDataAdr_Items) / 2 ; 
ItemNum_LightOrb            = (TabItemAdr_LightOrb           - TabDataAdr_Items) / 2 ; 
ItemNum_LightPoleColor      = (TabItemAdr_LightPoleColor     - TabDataAdr_Items) / 2 ; 
                            
ItemNum_LightSwitch         = (TabItemAdr_LightSwitch        - TabDataAdr_Items) / 2 ; 
ItemNum_LightSwitch_Up      = (TabItemAdr_LightSwitch_Up     - TabDataAdr_Items) / 2 ; 
ItemNum_LightSwitch_Do      = (TabItemAdr_LightSwitch_Do     - TabDataAdr_Items) / 2 ; 
                            
ItemNum_ForceFieldHead      = (TabItemAdr_ForceFieldHead     - TabDataAdr_Items) / 2 ; 
ItemNum_ForceFieldSwitch    = (TabItemAdr_ForceFieldSwitch   - TabDataAdr_Items) / 2 ; 
ItemNum_ForceFieldTimer     = (TabItemAdr_ForceFieldTimer    - TabDataAdr_Items) / 2 ; 
                            
ItemNum_MummyWall           = (TabItemAdr_MummyWall          - TabDataAdr_Items) / 2 ; 
ItemNum_MummyTombOpen       = (TabItemAdr_MummyTombOpen      - TabDataAdr_Items) / 2 ; 
ItemNum_MummyAnkh           = (TabItemAdr_MummyAnkh          - TabDataAdr_Items) / 2 ; 
                            
ItemNum_KeyTab              = (TabItemAdr_KeyWhite           - TabDataAdr_Items) / 2 ; 
ItemNum_KeyWhite            = (TabItemAdr_KeyWhite           - TabDataAdr_Items) / 2 ; 
ItemNum_KeyRed              = (TabItemAdr_KeyRed             - TabDataAdr_Items) / 2 ; 
ItemNum_KeyCyan             = (TabItemAdr_KeyCyan            - TabDataAdr_Items) / 2 ; 
ItemNum_KeyPurple           = (TabItemAdr_KeyPurple          - TabDataAdr_Items) / 2 ; 
ItemNum_KeyGreen            = (TabItemAdr_KeyGreen           - TabDataAdr_Items) / 2 ; 
ItemNum_KeyBlue             = (TabItemAdr_KeyBlue            - TabDataAdr_Items) / 2 ; 
ItemNum_KeyYellow           = (TabItemAdr_KeyYellow          - TabDataAdr_Items) / 2 ; 
                            
ItemNum_Lock                = (TabItemAdr_Lock               - TabDataAdr_Items) / 2 ; 
                            
ItemNum_GunPole_Le          = (TabItemAdr_GunPole_Le         - TabDataAdr_Items) / 2 ; 
ItemNum_GunPole_Ri          = (TabItemAdr_GunPole_Ri         - TabDataAdr_Items) / 2 ; 
                            
ItemNum_GunLaser_Ri_01      = (TabItemAdr_GunLaser_Ri_01     - TabDataAdr_Items) / 2 ; 
ItemNum_GunLaser_Ri_02      = (TabItemAdr_GunLaser_Ri_02     - TabDataAdr_Items) / 2 ; 
ItemNum_GunLaser_Ri_03      = (TabItemAdr_GunLaser_Ri_03     - TabDataAdr_Items) / 2 ; 
ItemNum_GunLaser_Ri_04      = (TabItemAdr_GunLaser_Ri_04     - TabDataAdr_Items) / 2 ; 
                            
ItemNum_GunLaser_Le_01      = (TabItemAdr_GunLaser_Le_01     - TabDataAdr_Items) / 2 ; 
ItemNum_GunLaser_Le_02      = (TabItemAdr_GunLaser_Le_02     - TabDataAdr_Items) / 2 ; 
ItemNum_GunLaser_Le_03      = (TabItemAdr_GunLaser_Le_03     - TabDataAdr_Items) / 2 ; 
ItemNum_GunLaser_Le_04      = (TabItemAdr_GunLaser_Le_04     - TabDataAdr_Items) / 2 ; 
                            
ItemNum_GunMovRi_Min        = ItemNum_GunLaser_Ri_01                                 ; 
ItemNum_GunMovRi_Max        = ItemNum_GunLaser_Ri_04                                 ; 
                            
ItemNum_GunMovLe_Min        = ItemNum_GunLaser_Le_01                                 ; 
ItemNum_GunMovLe_Max        = ItemNum_GunLaser_Le_04                                 ; 
                            
ItemNum_GunSwitch           = (TabItemAdr_GunSwitch          - TabDataAdr_Items) / 2 ; 
ItemNum_GunSwitchColor      = (TabItemAdr_GunSwitchColor     - TabDataAdr_Items) / 2 ; 
                            
ItemNum_XmitBooth           = (TabItemAdr_XmitBooth          - TabDataAdr_Items) / 2 ; 
ItemNum_XmitBooth_HotSpot   = (TabItemAdr_XmitBoothHotSpot   - TabDataAdr_Items) / 2 ; 
ItemNum_XmitBoothBack       = (TabItemAdr_XmitBoothBack      - TabDataAdr_Items) / 2 ; 
ItemNum_XmitTarget          = (TabItemAdr_XmitTarget         - TabDataAdr_Items) / 2 ; 
                            
ItemNum_TrapMove_01         = (TabItemAdr_TrapMove_01        - TabDataAdr_Items) / 2 ; trap part #1a - 1st bottom part
ItemNum_TrapMove_02         = (TabItemAdr_TrapMove_02        - TabDataAdr_Items) / 2 ; trap part #1b - 2nd bottom part
ItemNum_TrapMove_03         = (TabItemAdr_TrapMove_03        - TabDataAdr_Items) / 2 ; trap part #2a - 1st middle part
ItemNum_TrapMove_04         = (TabItemAdr_TrapMove_04        - TabDataAdr_Items) / 2 ; trap part #2b - 2nd middle part
ItemNum_TrapMove_05         = (TabItemAdr_TrapMove_05        - TabDataAdr_Items) / 2 ; trap part #3a - 1st top part
ItemNum_TrapMove_06         = (TabItemAdr_TrapMove_06        - TabDataAdr_Items) / 2 ; trap part #3b - 2nd top part

ItemNum_TrapOpen_HotSpot    = (TabItemAdr_TrapOpen_HotSpot   - TabDataAdr_Items) / 2 ; 
ItemNum_TrapSwitch          = (TabItemAdr_TrapSwitch         - TabDataAdr_Items) / 2 ; 
ItemNum_TrapOpen            = (TabItemAdr_TrapOpen           - TabDataAdr_Items) / 2 ; 
                            
ItemNum_TrapMov_Min         = ItemNum_TrapMove_01                                    ; trap part #1a - 1st bottom part
ItemNum_TrapMov_Max         = ItemNum_TrapMove_06                                    ; trap part #3b - 2nd top part
                            
ItemNum_Blank               = (TabItemAdr_Blank              - TabDataAdr_Items) / 2 ; 
                            
ItemNum_WalkBlank           = (TabItemAdr_WalkBlank          - TabDataAdr_Items) / 2 ; 
ItemNum_WalkMove_01         = (TabItemAdr_WalkMove_01        - TabDataAdr_Items) / 2 ; 
ItemNum_WalkMove_02         = (TabItemAdr_WalkMove_02        - TabDataAdr_Items) / 2 ; 
ItemNum_WalkMove_03         = (TabItemAdr_WalkMove_03        - TabDataAdr_Items) / 2 ; 
ItemNum_WalkMove_04         = (TabItemAdr_WalkMove_04        - TabDataAdr_Items) / 2 ; 
ItemNum_WalkSwitch          = (TabItemAdr_WalkSwitch         - TabDataAdr_Items) / 2 ; 
ItemNum_Walk_HotSpot        = (TabItemAdr_Walk_HotSpot       - TabDataAdr_Items) / 2 ; 
                            
ItemNum_WalkMov_Min         = ItemNum_WalkMove_01                                    ; 
ItemNum_WalkMov_Max         = ItemNum_WalkMove_04                                    ; 
                            
ItemNum_FrankCoffin_Ri      = (TabItemAdr_FrankCoffin_Ri     - TabDataAdr_Items) / 2 ; 
ItemNum_FrankCoffin_Le      = (TabItemAdr_FrankCoffin_Le     - TabDataAdr_Items) / 2 ; 
ItemNum_FrankCoffinClear    = (TabItemAdr_FrankCoffinClear   - TabDataAdr_Items) / 2 ; 
                            
ItemNum_TimeFrame           = (TabItemAdr_TimeFrame          - TabDataAdr_Items) / 2 ; 
                            
ItemNum_CharClear           = (TabItemAdr_CharClear          - TabDataAdr_Items) / 2 ; 
ItemNum_Char                = (TabItemAdr_Char               - TabDataAdr_Items) / 2 ; 
; ------------------------------------------------------------------------------------------------------------- ;
; sprite numbers
; ------------------------------------------------------------------------------------------------------------- ;
SpriteNum_PlayerMoveLe_01   = (TabSprtAdr_PlayerMoveLe_01    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerMoveLe_02   = (TabSprtAdr_PlayerMoveLe_02    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerMoveLe_03   = (TabSprtAdr_PlayerMoveLe_03    - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_PlayerMoveLe_Min  = SpriteNum_PlayerMoveLe_01                              ; 
SpriteNum_PlayerMoveLe_Max  = SpriteNum_PlayerMoveLe_03                              ; 
                            
SpriteNum_PlayerMoveRi_01   = (TabSprtAdr_PlayerMoveRi_01    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerMoveRi_02   = (TabSprtAdr_PlayerMoveRi_02    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerMoveRi_03   = (TabSprtAdr_PlayerMoveRi_03    - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_PlayerMoveRi_Min  = SpriteNum_PlayerMoveRi_01                              ; 
SpriteNum_PlayerMoveRi_Max  = SpriteNum_PlayerMoveRi_03                              ; 
                            
SpriteNum_PlayerClimb_01    = (TabSprtAdr_PlayerClimb_01     - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerClimb_02    = (TabSprtAdr_PlayerClimb_02     - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerClimb_03    = (TabSprtAdr_PlayerClimb_03     - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerClimb_04    = (TabSprtAdr_PlayerClimb_04     - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_PlayerClimb_Min   = SpriteNum_PlayerClimb_01                               ; 
SpriteNum_PlayerClimb_Max   = SpriteNum_PlayerClimb_04                               ; 
                            
SpriteNum_PlayerSlidePole   = (TabSprtAdr_PlayerSlidePole    - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_PlayerArrives_01  = (TabSprtAdr_PlayerEnters_01    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerArrives_02  = (TabSprtAdr_PlayerEnters_02    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerArrives_03  = (TabSprtAdr_PlayerEnters_03    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerArrives_04  = (TabSprtAdr_PlayerEnters_04    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerArrives_05  = (TabSprtAdr_PlayerEnters_05    - TabDataAdr_Items) / 2 ; 
SpriteNum_PlayerArrives_06  = (TabSprtAdr_PlayerEnters_06    - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_PlayerWave_M1     = (TabSprtAdr_PlayerWave_M1      - TabDataAdr_Items) / 2 ; wave step #1 - hand mid 
SpriteNum_PlayerWave_Ri     = (TabSprtAdr_PlayerWave_Ri      - TabDataAdr_Items) / 2 ; wave step #2 - hand right
SpriteNum_PlayerWave_M2     = (TabSprtAdr_PlayerWave_M2      - TabDataAdr_Items) / 2 ; wave step #1 - hand mid
SpriteNum_PlayerWave_Le     = (TabSprtAdr_PlayerWave_Le      - TabDataAdr_Items) / 2 ; wave step #3 - hand left
                            
SpriteNum_PlayerWave_Min    = SpriteNum_PlayerWave_M1                                ; 
SpriteNum_PlayerWave_Max    = SpriteNum_PlayerWave_Le                                ; 
                            
SpriteNum_MummyMoveLe_01    = (TabSprtAdr_MummyMoveLe_01     - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyMoveLe_02    = (TabSprtAdr_MummyMoveLe_02     - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyMoveLe_03    = (TabSprtAdr_MummyMoveLe_03     - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_MummyMoveLe_Min   = SpriteNum_MummyMoveLe_01                               ; 
SpriteNum_MummyMoveLe_Max   = SpriteNum_MummyMoveLe_03                               ; 
                            
SpriteNum_MummyMoveRi_01    = (TabSprtAdr_MummyMoveRi_01     - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyMoveRi_02    = (TabSprtAdr_MummyMoveRi_02     - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyMoveRi_03    = (TabSprtAdr_MummyMoveRi_03     - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_MummyMoveRi_Min   = SpriteNum_MummyMoveRi_01                               ; 
SpriteNum_MummyMoveRi_Max   = SpriteNum_MummyMoveRi_03                               ; 
                            
SpriteNum_MummyOut_01       = (TabSprtAdr_MummyOut_01        - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyOut_02       = (TabSprtAdr_MummyOut_02        - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyOut_03       = (TabSprtAdr_MummyOut_03        - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyOut_04       = (TabSprtAdr_MummyOut_04        - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyOut_05       = (TabSprtAdr_MummyOut_05        - TabDataAdr_Items) / 2 ; 
SpriteNum_MummyOut_06       = (TabSprtAdr_MummyOut_06        - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_MummyOut_Min      = SpriteNum_MummyOut_01                                  ; 
SpriteNum_MummyOut_Max      = SpriteNum_MummyOut_06                                  ; 
                            
SpriteNum_FrankMove_Min     = SpriteNum_FrankMove_Ri_01                              ; lower limit all frank move sprite numbers

SpriteNum_FrankMove_Ri_01   = (TabSprtAdr_FrankMove_Ri_01    - TabDataAdr_Items) / 2 ; 
SpriteNum_FrankMove_Ri_02   = (TabSprtAdr_FrankMove_Ri_02    - TabDataAdr_Items) / 2 ; 
SpriteNum_FrankMove_Ri_03   = (TabSprtAdr_FrankMove_Ri_03    - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_FrankMove_Ri_Min  = SpriteNum_FrankMove_Ri_01                              ; 
SpriteNum_FrankMove_Ri_Max  = SpriteNum_FrankMove_Ri_03                              ; 
                            
SpriteNum_FrankMove_Le_01   = (TabSprtAdr_FrankMove_Le_01    - TabDataAdr_Items) / 2 ; 
SpriteNum_FrankMove_Le_02   = (TabSprtAdr_FrankMove_Le_02    - TabDataAdr_Items) / 2 ; 
SpriteNum_FrankMove_Le_03   = (TabSprtAdr_FrankMove_Le_03    - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_FrankMove_Le_Min  = SpriteNum_FrankMove_Le_01                              ; 
SpriteNum_FrankMove_Le_Max  = SpriteNum_FrankMove_Le_03                              ; 
                            
SpriteNum_FrankMove_Max     = SpriteNum_FrankMove_Le_Max                             ; upper limit all frank move sprite numbers

SpriteNum_FrankClimb_01     = (TabSprtAdr_FrankClimb_01      - TabDataAdr_Items) / 2 ; 
SpriteNum_FrankClimb_02     = (TabSprtAdr_FrankClimb_02      - TabDataAdr_Items) / 2 ; 
SpriteNum_FrankClimb_03     = (TabSprtAdr_FrankClimb_03      - TabDataAdr_Items) / 2 ; 
SpriteNum_FrankClimb_04     = (TabSprtAdr_FrankClimb_04      - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_FrankClimb_Min    = SpriteNum_FrankClimb_01                                ; 
SpriteNum_FrankClimb_Max    = SpriteNum_FrankClimb_04                                ; 
                            
SpriteNum_FrankSlidePole    = (TabSprtAdr_FrankSlidePole     - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_FrankInCoffin     = (TabSprtAdr_FrankInCoffin      - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_SparkFlicker_01   = (TabSprtAdr_SparkFlicker_01    - TabDataAdr_Items) / 2 ; 
SpriteNum_SparkFlicker_02   = (TabSprtAdr_SparkFlicker_02    - TabDataAdr_Items) / 2 ; 
SpriteNum_SparkFlicker_03   = (TabSprtAdr_SparkFlicker_03    - TabDataAdr_Items) / 2 ; 
SpriteNum_SparkFlicker_04   = (TabSprtAdr_SparkFlicker_04    - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_SparkFlicker_Min  = SpriteNum_SparkFlicker_01                              ; 
SpriteNum_SparkFlicker_Max  = SpriteNum_SparkFlicker_04                              ; 
                            
SpriteNum_ForceCurtain_01   = (TabSprtAdr_ForceCurtain_01    - TabDataAdr_Items) / 2 ; 
SpriteNum_ForceCurtain_02   = (TabSprtAdr_ForceCurtain_02    - TabDataAdr_Items) / 2 ; 
SpriteNum_ForceCurtain_03   = (TabSprtAdr_ForceCurtain_03    - TabDataAdr_Items) / 2 ; 

SpriteNum_ForceCurtain_Min  = SpriteNum_ForceCurtain_01                              ; 
SpriteNum_ForceCurtain_Max  = SpriteNum_ForceCurtain_03                              ; 
                            
SpriteNum_GunBeam           = (TabSprtAdr_GunBeam            - TabDataAdr_Items) / 2 ; 
                            
SpriteNum_Arrow_Up          = (TabSprtAdr_Arrow_Up           - TabDataAdr_Items) / 2 ; 
SpriteNum_Arrow_Ri          = (TabSprtAdr_Arrow_Ri           - TabDataAdr_Items) / 2 ; 
SpriteNum_Arrow_Do          = (TabSprtAdr_Arrow_Do           - TabDataAdr_Items) / 2 ; 
SpriteNum_Arrow_Le          = (TabSprtAdr_Arrow_Le           - TabDataAdr_Items) / 2 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; Sprite color data and attribute flags - for items always $00
; --------------------------------------------------------------------------------------------------------------------- ;
Sprite_Attr_Color_Mask       = %00001111               ; Bits3-0: Color 0
Sprite_Attr_Color_Player       = YELLOW                ;          Color 0 - Player
Sprite_Attr_Color_Fank         = GREY                  ;          Color 0 - Frankenstein
Sprite_Attr_Color_Beam         = WHITE                 ;          Color 0 - Ray Gun Beam
Sprite_Attr_Color_Force        = WHITE                 ;          Color 0 - Force Field
Sprite_Attr_Color_Spark        = WHITE                 ;          Color 0 - Lightning Machine Spark
Sprite_Attr_Color_Mummy        = WHITE                 ;          Color 0 - Mummy
Sprite_Attr_Color_Arrow        = BLACK                 ;          Color 0 - Castle Map Door Arrow
Sprite_Attr_Flag_Mask        = %11110000               ; Bits7-4: Attriute flags
Sprite_Attr_Flag_MColor      = %00010000               ; Bit4:    MultiColor
Sprite_Attr_Flag_PrioBG      = %00100000               ; Bit5:    Spr/BG-Prio
Sprite_Attr_Flag_ExpandY     = %01000000               ; Bit6:    Y-expand
Sprite_Attr_Flag_ExpandX     = %10000000               ; Bit7:    X-expand
; --------------------------------------------------------------------------------------------------------------------- ;
; game room/map items and sprite data
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerMoveLeft_01    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
TabData_Hdr_Col             .byte TabData_Hdr_Cols ; 
TabData_Hdr_Row             .byte TabData_Hdr_Rows ; 
TabData_Hdr_Att             .byte TabData_Hdr_Attr ; 
TabData_Hdr_Len             = * - TabData_Hdr_Col  ;

TabData_Hdr_Off_Cols        = TabData_Hdr_Col - TabData_Hdr_Col ; 
TabData_Hdr_Off_Rows        = TabData_Hdr_Row - TabData_Hdr_Col ; 
TabData_Hdr_Off_Attr        = TabData_Hdr_Att - TabData_Hdr_Col ; 
                            
TabData_Item                .var  *   ; 
                            .byte $02, $00 ; ......#.........
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $02, $00 ; ......#.........
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $11, $44 ; ...#...#.#...#..
                            .byte $11, $44 ; ...#...#.#...#..
                            .byte $81, $48 ; #......#.#..#...
                            .byte $01, $40 ; .......#.#......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
                            .byte $0f, $c0 ; ....######......
                            .byte $0c, $f8 ; ....##..#####...
                            .byte $0c, $08 ; ....##......#...
                            .byte $0c, $08 ; ....##......#...
                            .byte $08, $00 ; ....#...........
                            .byte $28, $00 ; ..#.#...........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerMoveLeft_02    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $02, $00 ; ......#.........
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $02, $00 ; ......#.........
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $50 ; .......#.#.#....
                            .byte $01, $50 ; .......#.#.#....
                            .byte $01, $50 ; .......#.#.#....
                            .byte $95, $60 ; #..#.#.#.##.....
                            .byte $01, $40 ; .......#.#......
                            .byte $03, $c0 ; ......####......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0f, $c0 ; ....######......
                            .byte $03, $d0 ; ......####.#....
                            .byte $00, $d0 ; ........##.#....
                            .byte $00, $d0 ; ........##.#....
                            .byte $00, $80 ; ........#.......
                            .byte $02, $80 ; ......#.#.......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerMoveLeft_03    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $02, $00 ; ......#.........
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $02, $00 ; ......#.........
                            .byte $01, $40 ; .......#.#......
                            .byte $81, $54 ; #......#.#.#.#..
                            .byte $15, $42 ; ...#.#.#.#....#.
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $0f, $c0 ; ....######......
                            .byte $3c, $c0 ; ..####..##......
                            .byte $30, $30 ; ..##......##....
                            .byte $30, $30 ; ..##......##....
                            .byte $20, $0c ; ..#.........##..
                            .byte $a0, $08 ; #.#.........#...
                            .byte $00, $28 ; ..........#.#...
                            .byte $00, $20 ; ..........#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerMoveRight_01   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $80 ; ........#.......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $00, $80 ; ........#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $11, $44 ; ...#...#.#...#..
                            .byte $11, $44 ; ...#...#.#...#..
                            .byte $21, $42 ; ..#....#.#....#.
                            .byte $01, $40 ; .......#.#......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $f0 ; ......######....
                            .byte $2f, $30 ; ..#.####..##....
                            .byte $20, $30 ; ..#.......##....
                            .byte $20, $30 ; ..#.......##....
                            .byte $00, $20 ; ..........#.....
                            .byte $00, $28 ; ..........#.#...
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerMoveRight_02   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $80 ; ........#.......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $00, $80 ; ........#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $09, $56 ; ....#..#.#.#.##.
                            .byte $01, $40 ; .......#.#......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $30 ; ......##..##....
                            .byte $03, $f0 ; ......######....
                            .byte $0b, $c0 ; ....#.####......
                            .byte $0b, $00 ; ....#.##........
                            .byte $0b, $00 ; ....#.##........
                            .byte $02, $00 ; ......#.........
                            .byte $02, $80 ; ......#.#.......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerMoveRight_03   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $80 ; ........#.......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $00, $80 ; ........#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $15, $42 ; ...#.#.#.#....#.
                            .byte $81, $54 ; #......#.#.#.#..
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $03, $f0 ; ......######....
                            .byte $03, $3c ; ......##..####..
                            .byte $0c, $0c ; ....##......##..
                            .byte $0c, $0c ; ....##......##..
                            .byte $30, $08 ; ..##........#...
                            .byte $20, $0a ; ..#.........#.#.
                            .byte $28, $00 ; ..#.#...........
                            .byte $08, $00 ; ....#...........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataDoorNormal           = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $05 ; 
TabData_Hdr_Rows            .var  $20 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $55, $51, $55, $45, $55 ; .#.#.#.#.#.#...#.#.#.#.#.#...#.#.#.#.#.#
                            .byte $55, $51, $55, $45, $55 ; .#.#.#.#.#.#...#.#.#.#.#.#...#.#.#.#.#.#
                            .byte $15, $51, $55, $45, $54 ; ...#.#.#.#.#...#.#.#.#.#.#...#.#.#.#.#..
                            .byte $15, $51, $55, $45, $54 ; ...#.#.#.#.#...#.#.#.#.#.#...#.#.#.#.#..
                            .byte $45, $50, $55, $05, $51 ; .#...#.#.#.#.....#.#.#.#.....#.#.#.#...#
                            .byte $45, $54, $55, $15, $51 ; .#...#.#.#.#.#...#.#.#.#...#.#.#.#.#.#..
                            .byte $51, $54, $55, $15, $45 ; .#.#...#.#.#.#...#.#.#.#...#.#.#.#...#.#
                            .byte $51, $54, $55, $15, $45 ; .#.#...#.#.#.#...#.#.#.#...#.#.#.#...#.#
                            .byte $54, $54, $00, $15, $15 ; .#.#.#...#.#.#.............#.#.#...#.#.#
                            .byte $54, $10, $00, $04, $15 ; .#.#.#.....#.................#.....#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $40, $00, $01, $55 ; .#.#.#.#.#.....................#.#.#.#.#
                            .byte $55, $40, $00, $01, $55 ; .#.#.#.#.#.....................#.#.#.#.#
                            .byte $00, $00, $00, $00, $00 ; ........................................
                            .byte $00, $00, $00, $00, $00 ; ........................................
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $00, $00, $00, $00, $00 ; ........................................
                            .byte $00, $00, $00, $00, $00 ; ........................................
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            .byte $55, $00, $00, $00, $55 ; .#.#.#.#.........................#.#.#.#
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_PURPLE_BLACK ; $14 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataDoorGrate            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $11, $11, $10 ; ...#...#...#...#...#....
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#

Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_WHITE_BLACK ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataDoorOpen             = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $01 ; .......................#
                            .byte $00, $00, $01 ; .......................#
                            .byte $00, $00, $05 ; .....................#.#
                            .byte $00, $00, $15 ; ...................#.#.#
                            .byte $00, $00, $55 ; .................#.#.#.#
                            .byte $00, $01, $55 ; ...............#.#.#.#.#
                            .byte $00, $01, $55 ; ...............#.#.#.#.#
                            .byte $00, $05, $55 ; .............#.#.#.#.#.#
                            .byte $00, $15, $55 ; ...........#.#.#.#.#.#.#
                            .byte $00, $55, $55 ; .........#.#.#.#.#.#.#.#
                            .byte $01, $55, $55 ; .......#.#.#.#.#.#.#.#.#
                            .byte $01, $55, $55 ; .......#.#.#.#.#.#.#.#.#
                            .byte $05, $55, $55 ; .....#.#.#.#.#.#.#.#.#.#
                            .byte $15, $55, $55 ; ...#.#.#.#.#.#.#.#.#.#.#
                            .byte $55, $aa, $55 ; .#.#.#.##.#.#.#..#.#.#.#
                            
Item_Colors                 .var  *   ; 
TabDataDoorOpen_Color       .byte $a0, $af, $b3 ; variable object colors
                            .byte $b0, $a2, $b2 ; 
TabDataDoorOpen_Color_Len   = * - TabDataDoorOpen_Color - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataDoorBell             = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $13 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $55, $00 ; .........#.#.#.#........
                            .byte $01, $55, $40 ; .......#.#.#.#.#.#......
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $05, $82, $50 ; .....#.##.....#..#.#....
                            .byte $15, $14, $54 ; ...#.#.#...#.#...#.#.#..
                            .byte $14, $55, $14 ; ...#.#...#.#.#.#...#.#..
                            .byte $14, $55, $14 ; ...#.#...#.#.#.#...#.#..
                            .byte $14, $55, $14 ; ...#.#...#.#.#.#...#.#..
                            .byte $14, $55, $14 ; ...#.#...#.#.#.#...#.#..
                            .byte $15, $14, $54 ; ...#.#.#...#.#...#.#.#..
                            .byte $05, $82, $50 ; .....#.##.....#..#.#....
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $01, $55, $40 ; .......#.#.#.#.#.#......
                            .byte $00, $55, $00 ; .........#.#.#.#........
                            
Item_Colors                 .var  *   ; 
TabDataDoorBellColor_01     .byte $b3, $a0, $cc ; variable object colors
                            .byte $a0           ; 
TabDataDoorBellColor_02     .byte $a4           ; 
                            .byte $b1           ; 
                            .byte $ac, $80, $a0 ; 
TabDataDoorBellColor_Len    = * - TabDataDoorBellColor_01 - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMapRoomFill          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            
Item_Colors                 .var  *   ; 
                            .byte HR_WHITE_WHITE  ; fix object frame color
TabDataMapRoomFillColor     .byte HR_ORANGE_WHITE ; variable object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMapRoomWall_NS       = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $03 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $aa ; #.#.#.#.
                            .byte $aa ; #.#.#.#.
                            .byte $aa ; #.#.#.#.
TabDataMapRoomWall_NS_Len   = * - TabData_Item ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMapRoomWall_W        = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $a0 ; #.#.....
                            .byte $a0 ; #.#.....
                            .byte $a0 ; #.#.....
                            .byte $a0 ; #.#.....
                            .byte $a0 ; #.#.....
                            .byte $a0 ; #.#.....
                            .byte $a0 ; #.#.....
                            .byte $a0 ; #.#.....
TabDataMapRoomWall_W_Len    = * - TabData_Item ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMapRoomWall_E        = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $0a ; ....#.#.
                            .byte $0a ; ....#.#.
                            .byte $0a ; ....#.#.
                            .byte $0a ; ....#.#.
                            .byte $0a ; ....#.#.
                            .byte $0a ; ....#.#.
                            .byte $0a ; ....#.#.
                            .byte $0a ; ....#.#.
TabDataMapRoomWall_E_Len    = * - TabData_Item ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMapRoomDoorLe_NS     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $03 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $50 ; .#.#....
                            .byte $50 ; .#.#....
                            .byte $50 ; .#.#....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMapRoomDoorRi_NS     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $03 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $05 ; .....#.#
                            .byte $05 ; .....#.#
                            .byte $05 ; .....#.#
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMapRoomDoor_E        = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $04 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $50 ; .#.#....
                            .byte $50 ; .#.#....
                            .byte $50 ; .#.#....
                            .byte $50 ; .#.#....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMapRoomDoor_W        = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $04 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $05 ; .....#.#
                            .byte $05 ; .....#.#
                            .byte $05 ; .....#.#
                            .byte $05 ; .....#.#
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataCastleMapArrowUp     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0a ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Arrow ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $08, $00 ; ....#...........
                            .byte $1c, $00 ; ...###..........
                            .byte $3e, $00 ; ..#####.........
                            .byte $7f, $00 ; .#######........
                            .byte $ff, $80 ; #########.......
                            .byte $1c, $00 ; ...###..........
                            .byte $1c, $00 ; ...###..........
                            .byte $1c, $00 ; ...###..........
                            .byte $1c, $00 ; ...###..........
                            .byte $1c, $00 ; ...###..........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataCastleMapArrowRight  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $09 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Arrow ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $04, $00 ; .....#..........
                            .byte $06, $00 ; .....##.........
                            .byte $07, $00 ; .....###........
                            .byte $ff, $80 ; #########.......
                            .byte $ff, $c0 ; ##########......
                            .byte $ff, $80 ; #########.......
                            .byte $07, $00 ; .....###........
                            .byte $06, $00 ; .....##.........
                            .byte $04, $00 ; .....#..........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataCastleMapArrowDown   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0a ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Arrow ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $1c, $00 ; ...###..........
                            .byte $1c, $00 ; ...###..........
                            .byte $1c, $00 ; ...###..........
                            .byte $1c, $00 ; ...###..........
                            .byte $1c, $00 ; ...###..........
                            .byte $ff, $80 ; #########.......
                            .byte $7f, $00 ; .#######........
                            .byte $3e, $00 ; ..#####.........
                            .byte $1c, $00 ; ...###..........
                            .byte $08, $00 ; ....#...........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataCastleMapArrowLeft   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $09 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Arrow ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $08, $00 ; ....#...........
                            .byte $18, $00 ; ...##...........
                            .byte $38, $00 ; ..###...........
                            .byte $7f, $c0 ; .#########......
                            .byte $ff, $c0 ; ##########......
                            .byte $7f, $c0 ; .#########......
                            .byte $38, $00 ; ..###...........
                            .byte $18, $00 ; ...##...........
                            .byte $08, $00 ; ....#...........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFloorStart           = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $05 ; .....#.#
                            .byte $05 ; .....#.#
                            .byte $15 ; ...#.#.#
                            .byte $2a ; ..#.#.#.
                            .byte $aa ; #.#.#.#.
                            .byte $aa ; #.#.#.#.
                            .byte $ff ; ########
                            .byte $ff ; ########
                            
Item_Colors                 .var  *   ; 
TabDataFloorStart_Color     .byte HR_LT_RED_BLACK ; variable colors
                            .byte HR_BLACK_BROWN  ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFloor                = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            .byte $aa ; #.#.#.#.
                            .byte $aa ; #.#.#.#.
                            .byte $aa ; #.#.#.#.
                            .byte $ff ; ########
                            .byte $ff ; ########
                            
Item_Colors                 .var  *   ; 
TabDataFloorColor           .byte HR_DK_GREY_BLACK ; variable object color
                            .byte HR_BLACK_BROWN   ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFloorEnd             = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $57 ; .#.#.###
                            .byte $57 ; .#.#.###
                            .byte $5c ; .#.###..
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.###...
                            .byte $b0 ; #.###...
                            .byte $c0 ; ##......
                            .byte $c0 ; ##......
                            
Item_Colors                 .var  *   ; 
TabDataFloorEndColor        .byte HR_DK_GREY_YELLOW ; variable object color
                            .byte HR_BLACK_BROWN    ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerEntersRoom_01  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $80 ; ........#.......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $00, $80 ; ........#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $48 ; .....#.#.#..#...
                            .byte $21, $50 ; ..#....#.#.#....
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $f0 ; ......######....
                            .byte $03, $30 ; ......##..##....
                            .byte $0c, $30 ; ....##....##....
                            .byte $0c, $20 ; ....##....#.....
                            .byte $08, $20 ; ....#.....#.....
                            .byte $0a, $00 ; ....#.#.........
                            .byte $02, $00 ; ......#.........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerEntersRoom_02  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $11 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $80 ; ........#.......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $00, $80 ; ........#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $09, $68 ; ....#..#.##.#...
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $f0 ; ......######....
                            .byte $0f, $30 ; ....####..##....
                            .byte $08, $30 ; ....#.....##....
                            .byte $08, $20 ; ....#.....#.....
                            .byte $00, $20 ; ..........#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerEntersRoom_03  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0d ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $00 ; ......#.........
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $09, $60 ; ....#..#.##.....
                            .byte $01, $40 ; .......#.#......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $f0 ; ......######....
                            .byte $0b, $c0 ; ....#.####......
                            .byte $0a, $00 ; ....#.#.........
                            .byte $02, $80 ; ......#.#.......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerEntersRoom_04  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0a ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $00 ; ......#.........
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $60 ; .....#.#.##.....
                            .byte $01, $40 ; .......#.#......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $30 ; ......##..##....
                            .byte $03, $30 ; ......##..##....
                            .byte $02, $20 ; ......#...#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerEntersRoom_05  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $07 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $80 ; ........#.......
                            .byte $00, $a0 ; ........#.#.....
                            .byte $00, $40 ; .........#......
                            .byte $01, $50 ; .......#.#.#....
                            .byte $00, $c0 ; ........##......
                            .byte $02, $c0 ; ......#.##......
                            .byte $00, $c0 ; ........##......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerEntersRoom_06  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $04 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $01, $00 ; .......#........
                            .byte $03, $00 ; ......##........
                            .byte $02, $00 ; ......#.........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPole                 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $10 ; ...#....
                            .byte $10 ; ...#....
                            .byte $10 ; ...#....
                            .byte $10 ; ...#....
                            .byte $10 ; ...#....
                            .byte $10 ; ...#....
                            .byte $10 ; ...#....
                            .byte $10 ; ...#....
                            .byte $10 ; ...#....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPoleEnd              = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $03 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $05, $45, $50 ; .....#.#.#...#.#.#.#....
                            .byte $15, $45, $40 ; ...#.#.#.#...#.#.#......
                            .byte $55, $45, $00 ; .#.#.#.#.#...#.#........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerSlidePole      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $02, $00 ; ......#.........
                            .byte $04, $40 ; .....#...#......
                            .byte $12, $10 ; ...#..#....#....
                            .byte $1a, $90 ; ...##.#.#..#....
                            .byte $1a, $90 ; ...##.#.#..#....
                            .byte $1a, $90 ; ...##.#.#..#....
                            .byte $12, $10 ; ...#..#....#....
                            .byte $15, $50 ; ...#.#.#.#.#....
                            .byte $05, $40 ; .....#.#.#......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $3c, $f0 ; ..####..####....
                            .byte $30, $30 ; ..##......##....
                            .byte $0c, $c0 ; ....##..##......
                            .byte $02, $00 ; ......#.........
                            .byte $08, $80 ; ....#...#.......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPoleFront            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00 ; ........
                            
Item_Colors                 .var  *   ; 
TabDataPoleCoverColor       .byte HR_LT_GREEN_BROWN ; variable object color
                            .byte HR_BLACK_BROWN    ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLadder               = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $82 ; #.....#.
                            .byte $82 ; #.....#.
                            .byte $82 ; #.....#.
                            .byte $aa ; #.#.#.#.
                            .byte $82 ; #.....#.
                            .byte $82 ; #.....#.
                            .byte $82 ; #.....#.
                            .byte $aa ; #.#.#.#.
                            
                            .byte HR_BLACK_WHITE ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLadderEnd            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $96 ; #..#.##.
                            .byte $96 ; #..#.##.
                            .byte $96 ; #..#.##.
                            .byte $aa ; #.#.#.#.
                            .byte $96 ; #..#.##.
                            .byte $96 ; #..#.##.
                            
Item_Colors                 .var  *   ; 
TabDataLadderEndColor       .byte HR_BLACK_WHITE ; variable object color
                            .byte HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLadderEndCover       = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLadderTop            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $07 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $82 ; #.....#.
                            .byte $82 ; #.....#.
                            .byte $82 ; #.....#.
                            .byte $aa ; #.#.#.#.
                            .byte $82 ; #.....#.
                            .byte $82 ; #.....#.
                            .byte $82 ; #.....#.
                            
Item_Colors                 .var  *   ; 
                            .byte HR_BLACK_WHITE ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLadderFloor          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $55, $96, $55 ; .#.#.#.##..#.##..#.#.#.#
                            .byte $55, $96, $55 ; .#.#.#.##..#.##..#.#.#.#
                            .byte $55, $96, $55 ; .#.#.#.##..#.##..#.#.#.#
                            .byte $aa, $aa, $00 ; #.#.#.#.#.#.#.#.........
                            .byte $a8, $82, $02 ; #.#.#...#.....#.......#.
                            .byte $a0, $82, $0a ; #.#.....#.....#.....#.#.
                            .byte $f0, $82, $0f ; ####....#.....#.....####
                            .byte $f0, $aa, $0f ; ####....#.#.#.#.....####
                            
Item_Colors                 .var  *   ; 
TabDataLadderFloorColor_0  .byte HR_BLACK_WHITE ; variable object color left
TabDataLadderFloorColor_1  .byte HR_BLACK_WHITE ; variable object color mid
TabDataLadderFloorColor_2  .byte HR_BLACK_WHITE ; variable object color right
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLadderFloorCover     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $ff, $ff, $ff ; ########################
                            .byte $ff, $ff, $ff ; ########################
                            .byte $ff, $ff, $ff ; ########################
                            .byte $ff, $ff, $ff ; ########################
                            .byte $ff, $ff, $ff ; ########################
                            .byte $ff, $ff, $ff ; ########################
                            .byte $ff, $ff, $ff ; ########################
                            .byte $ff, $ff, $ff ; ########################
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerClimbLadder_01 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $08 ; ............#...
                            .byte $00, $04 ; .............#..
                            .byte $02, $84 ; ......#.#....#..
                            .byte $0a, $a4 ; ....#.#.#.#..#..
                            .byte $2a, $a4 ; ..#.#.#.#.#..#..
                            .byte $4a, $a0 ; .#..#.#.#.#.....
                            .byte $42, $80 ; .#....#.#.......
                            .byte $41, $40 ; .#.....#.#......
                            .byte $15, $50 ; ...#.#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $0f, $f0 ; ....########....
                            .byte $0f, $fc ; ....##########..
                            .byte $0c, $0c ; ....##......##..
                            .byte $0c, $0c ; ....##......##..
                            .byte $32, $c0 ; ..##..#.##......
                            .byte $3c, $00 ; ..####..........
                            .byte $3a, $00 ; ..###.#.........
                            .byte $02, $00 ; ......#.........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerClimbLadder_02 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $00, $00 ; ................
                            .byte $02, $88 ; ......#.#...#...
                            .byte $0a, $a4 ; ....#.#.#.#..#..
                            .byte $0a, $a4 ; ....#.#.#.#..#..
                            .byte $0a, $a4 ; ....#.#.#.#..#..
                            .byte $22, $84 ; ..#...#.#....#..
                            .byte $11, $40 ; ...#...#.#......
                            .byte $15, $50 ; ...#.#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $0f, $f0 ; ....########....
                            .byte $0f, $f0 ; ....########....
                            .byte $30, $0c ; ..##........##..
                            .byte $30, $0c ; ..##........##..
                            .byte $30, $0c ; ..##........##..
                            .byte $20, $08 ; ..#.........#...
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $00, $00 ; ................
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerClimbLadder_03 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $20, $00 ; ..#.............
                            .byte $10, $00 ; ...#............
                            .byte $12, $80 ; ...#..#.#.......
                            .byte $1a, $a0 ; ...##.#.#.#.....
                            .byte $1a, $a8 ; ...##.#.#.#.#...
                            .byte $0a, $a1 ; ....#.#.#.#....#
                            .byte $02, $81 ; ......#.#......#
                            .byte $01, $41 ; .......#.#.....#
                            .byte $05, $54 ; .....#.#.#.#.#..
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $0f, $f0 ; ....########....
                            .byte $3f, $f0 ; ..##########....
                            .byte $30, $30 ; ..##......##....
                            .byte $30, $30 ; ..##......##....
                            .byte $08, $3c ; ....#.....####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $ac ; ........#.#.##..
                            .byte $00, $08 ; ............#...
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerClimbLadder_04 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $00, $00 ; ................
                            .byte $22, $80 ; ..#...#.#.......
                            .byte $1a, $a0 ; ...##.#.#.#.....
                            .byte $1a, $a0 ; ...##.#.#.#.....
                            .byte $1a, $a0 ; ...##.#.#.#.....
                            .byte $12, $88 ; ...#..#.#...#...
                            .byte $01, $44 ; .......#.#...#..
                            .byte $05, $54 ; .....#.#.#.#.#..
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $0f, $f0 ; ....########....
                            .byte $0f, $f0 ; ....########....
                            .byte $30, $0c ; ..##........##..
                            .byte $30, $0c ; ..##........##..
                            .byte $30, $0c ; ..##........##..
                            .byte $20, $0c ; ..#.........##..
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $00, $00 ; ................
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachPole        = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $7d ; .#####.#
                            .byte $96 ; #..#.##.
                            .byte $eb ; ###.#.##
                            .byte $7d ; .#####.#
                            .byte $96 ; #..#.##.
                            .byte $eb ; ###.#.##
                            .byte $7d ; .#####.#
                            .byte $96 ; #..#.##.
                            
Item_Colors                 .var  *   ; 
                            .byte HR_GREEN_GREEN ; object color
                            .byte HR_BLACK_GREEN ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachOrb         = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $69, $00 ; .........##.#..#........
                            .byte $01, $55, $40 ; .......#.#.#.#.#.#......
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $07, $d5, $50 ; .....#####.#.#.#.#.#....
                            .byte $07, $d5, $50 ; .....#####.#.#.#.#.#....
                            .byte $1f, $55, $54 ; ...#####.#.#.#.#.#.#.#..
                            .byte $1d, $55, $54 ; ...###.#.#.#.#.#.#.#.#..
                            .byte $1d, $55, $54 ; ...###.#.#.#.#.#.#.#.#..
                            .byte $1d, $55, $54 ; ...###.#.#.#.#.#.#.#.#..
                            .byte $1d, $55, $54 ; ...###.#.#.#.#.#.#.#.#..
                            .byte $07, $55, $50 ; .....###.#.#.#.#.#.#....
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $01, $55, $40 ; .......#.#.#.#.#.#......
                            .byte $00, $55, $00 ; .........#.#.#.#........
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_GREY_GREEN ; $06 object color bytes
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, WHITE         ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachPoleColor   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00 ; ........
                            
Item_Colors                 .var  *   ; 
TabDataLightMachPoleColor_1 .byte HR_DK_GREY_LT_GREEN ; variable oject color
TabDataLightMachPoleColor_2 .byte HR_LT_RED_BLACK     ; variable oject color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataForceFieldCurtain_01 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $0e ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_ExpandY | Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Force ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00 ; ........
                            .byte $03 ; ......##
                            .byte $0c ; ....##..
                            .byte $33 ; ..##..##
                            .byte $0c ; ....##..
                            .byte $33 ; ..##..##
                            .byte $0c ; ....##..
                            .byte $33 ; ..##..##
                            .byte $0c ; ....##..
                            .byte $33 ; ..##..##
                            .byte $0c ; ....##..
                            .byte $33 ; ..##..##
                            .byte $0c ; ....##..
                            .byte $30 ; ..##....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachSwitchFrame = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $00, $50 ; .....#.#.........#.#....
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_YELLOW_BLACK ; $09 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachSwitch_Up   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $05 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $28 ; ..#.#...
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            
Item_Colors                 .var  *   ; 
                            .byte HR_WHITE_WHITE ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachSwitch_Do   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $28 ; ..#.#...
                            
Item_Colors                 .var  *   ; 
                            .byte HR_WHITE_WHITE ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachSpark_01    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_ExpandY | Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Spark ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $0c, $00 ; ............##..........
                            .byte $04, $02, $00 ; .....#........#.........
                            .byte $08, $01, $00 ; ....#..........#........
                            .byte $30, $01, $00 ; ..##...........#........
                            .byte $20, $00, $80 ; ..#.............#.......
                            .byte $30, $00, $80 ; ..##............#.......
                            .byte $48, $01, $00 ; .#..#..........#........
                            .byte $44, $02, $00 ; .#...#........#.........
                            .byte $22, $01, $00 ; ..#...#........#........
                            .byte $21, $00, $80 ; ..#....#........#.......
                            .byte $22, $00, $80 ; ..#...#.........#.......
                            .byte $02, $00, $80 ; ......#.........#.......
                            .byte $01, $00, $80 ; .......#........#.......
                            .byte $00, $00, $00 ; ........................
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachSpark_02    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_ExpandY | Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Spark ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $40, $00 ; .........#..............
                            .byte $00, $40, $20 ; .........#........#.....
                            .byte $00, $40, $20 ; .........#........#.....
                            .byte $00, $87, $c0 ; ........#....#####......
                            .byte $00, $8a, $00 ; ........#...#.#.........
                            .byte $00, $52, $00 ; .........#.#..#.........
                            .byte $00, $31, $00 ; ..........##...#........
                            .byte $00, $48, $80 ; .........#..#...#.......
                            .byte $01, $88, $10 ; .......##...#......#....
                            .byte $01, $08, $10 ; .......#....#......#....
                            .byte $01, $08, $10 ; .......#....#......#....
                            .byte $01, $00, $20 ; .......#..........#.....
                            .byte $00, $80, $20 ; ........#.........#.....
                            .byte $00, $80, $10 ; ........#..........#....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachSpark_03    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_ExpandY | Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Spark ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $c0, $00 ; ........##..............
                            .byte $01, $30, $08 ; .......#..##........#...
                            .byte $02, $00, $04 ; ......#..............#..
                            .byte $04, $00, $02 ; .....#................#.
                            .byte $04, $00, $01 ; .....#.................#
                            .byte $03, $80, $02 ; ......###.............#.
                            .byte $00, $40, $04 ; .........#...........#..
                            .byte $00, $20, $08 ; ..........#.........#...
                            .byte $00, $10, $08 ; ...........#........#...
                            .byte $00, $28, $14 ; ..........#.#......#.#..
                            .byte $00, $48, $12 ; .........#..#......#..#.
                            .byte $00, $48, $12 ; .........#..#......#..#.
                            .byte $00, $20, $01 ; ..........#............#
                            .byte $00, $00, $01 ; .......................#
                            .byte $00, $00, $00 ; ........................
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLightMachSpark_04    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_ExpandY | Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Spark ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $02, $00, $00 ; ......#.................
                            .byte $02, $00, $00 ; ......#.................
                            .byte $02, $00, $00 ; ......#.................
                            .byte $01, $48, $00 ; .......#.#..#...........
                            .byte $00, $84, $00 ; ........#....#..........
                            .byte $00, $04, $00 ; .............#..........
                            .byte $00, $08, $00 ; ............#...........
                            .byte $00, $10, $00 ; ...........#............
                            .byte $00, $10, $00 ; ...........#............
                            .byte $00, $0e, $00 ; ............###.........
                            .byte $00, $01, $00 ; ...............#........
                            .byte $00, $01, $00 ; ...............#........
                            .byte $00, $01, $00 ; ...............#........
                            .byte $00, $01, $00 ; ...............#........
                            .byte $00, $00, $00 ; ........................
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataForceFieldCurtain_02 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $0e ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_ExpandY | Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Spark ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00 ; ........
                            .byte $02 ; ......#.
                            .byte $05 ; .....#.#
                            .byte $2a ; ..#.#.#.
                            .byte $15 ; ...#.#.#
                            .byte $2a ; ..#.#.#.
                            .byte $15 ; ...#.#.#
                            .byte $2a ; ..#.#.#.
                            .byte $15 ; ...#.#.#
                            .byte $2a ; ..#.#.#.
                            .byte $15 ; ...#.#.#
                            .byte $2a ; ..#.#.#.
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataForceFieldHead       = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $52, $50 ; .#.#..#..#.#....; 
                            .byte $52, $50 ; .#.#..#..#.#....; 
                            .byte $59, $50 ; .#.##..#.#.#....; 
                            .byte $08, $00 ; ....#...........; 
                            .byte $20, $00 ; ..#.............; 
                            .byte $20, $00 ; ..#.............; 
                            
Item_Colors                 .var  *   ; 
                            .byte HR_RED_YELLOW, HR_RED_YELLOW ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataForceFieldSwitch     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $16 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $14, $00 ; ...........#.#..........
                            .byte $00, $55, $00 ; .........#.#.#.#........
                            .byte $01, $55, $40 ; .......#.#.#.#.#.#......
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $15, $55, $54 ; ...#.#.#.#.#.#.#.#.#.#..
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $54, $00, $15 ; .#.#.#.............#.#.#
                            .byte $15, $aa, $54 ; ...#.#.##.#.#.#..#.#.#..
                            .byte $05, $55, $50 ; .....#.#.#.#.#.#.#.#....
                            .byte $01, $55, $40 ; .......#.#.#.#.#.#......
                            .byte $00, $55, $00 ; .........#.#.#.#........
                            .byte $00, $14, $00 ; ...........#.#..........
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_RED_RED ; $09 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataForceFieldTimer      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a spritealways $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
TabDataForceFieldTime       =     *   ;   
TabDataForceFieldTimeTick_8 .byte $b5 ; 
TabDataForceFieldTimeTick_7 .byte $a0 ; 
TabDataForceFieldTimeTick_6 .byte $90 ; 
TabDataForceFieldTimeTick_5 .byte $a0 ; 
TabDataForceFieldTimeTick_4 .byte $87 ; 
TabDataForceFieldTimeTick_3 .byte $a0 ; 
TabDataForceFieldTimeTick_2 .byte $b0 ; 
TabDataForceFieldTimeTick_1 .byte $a0 ; 
TabDataForceFieldTime_Len   = * - TabDataForceFieldTime ; 
                            
Item_Colors                 .var  *   ; 
                            .byte HR_WHITE_BLACK ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataForceFieldCurtain_03 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_PrioBG | Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Force ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00 ; ........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyWall            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $07 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $54 ; .#.#.#..
                            .byte $54 ; .#.#.#..
                            .byte $54 ; .#.#.#..
                            .byte $00 ; ........
                            .byte $45 ; .#...#.#
                            .byte $45 ; .#...#.#
                            .byte $45 ; .#...#.#
                            
Item_Colors                 .var  *   ; 
                            .byte HR_PURPLE_BLACK ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyTombOpen        = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $01, $55 ; ...............#.#.#.#.#
                            .byte $00, $05, $55 ; .............#.#.#.#.#.#
                            .byte $00, $15, $55 ; ...........#.#.#.#.#.#.#
                            .byte $00, $55, $55 ; .........#.#.#.#.#.#.#.#
                            .byte $01, $55, $55 ; .......#.#.#.#.#.#.#.#.#
                            .byte $05, $55, $55 ; .....#.#.#.#.#.#.#.#.#.#
                            .byte $15, $55, $55 ; ...#.#.#.#.#.#.#.#.#.#.#
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_RED_BLACK ; $03 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyAnkh            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $17 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $00, $00 ; ................
                            .byte $05, $00 ; .....#.#........
                            .byte $15, $40 ; ...#.#.#.#......
                            .byte $10, $40 ; ...#.....#......
                            .byte $40, $10 ; .#.........#....
                            .byte $40, $10 ; .#.........#....
                            .byte $40, $10 ; .#.........#....
                            .byte $40, $10 ; .#.........#....
                            .byte $40, $10 ; .#.........#....
                            .byte $10, $40 ; ...#.....#......
                            .byte $10, $40 ; ...#.....#......
                            .byte $10, $40 ; ...#.....#......
                            .byte $10, $40 ; ...#.....#......
                            .byte $05, $00 ; .....#.#........
                            .byte $05, $00 ; .....#.#........
                            .byte $aa, $a0 ; #.#.#.#.#.#.....
                            .byte $55, $50 ; .#.#.#.#.#.#....
                            .byte $05, $00 ; .....#.#........
                            .byte $05, $00 ; .....#.#........
                            .byte $05, $00 ; .....#.#........
                            .byte $05, $00 ; .....#.#........
                            .byte $05, $00 ; .....#.#........
                            
Item_Colors                 .var  *   ; 
TabDataMummyAnkhColor       .byte $b0, $a9, $a0 ; variable object colors
                            .byte $e8, $a0, $97 ; 
TabDataMummyAnkhColor_Len   = * - TabDataMummyAnkhColor - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveOut_01      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $02 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $1e ; ...####.
                            .byte $3e ; ..#####.
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveOut_02      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $04 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $f7, $c0 ; ####.#####......; 
                            .byte $ff, $c0 ; ##########......; 
                            .byte $1f, $c0 ; ...#######......; 
                            .byte $3f, $80 ; ..#######.......; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveOut_03      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $01, $fc ; .......#######..; 
                            .byte $63, $fc ; .##...########..; 
                            .byte $f7, $fc ; ####.#########..; 
                            .byte $ff, $fc ; ##############..; 
                            .byte $1f, $fc ; ...###########..; 
                            .byte $3f, $80 ; ..#######.......; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveOut_04      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $01, $fc, $00 ; .......#######..........
                            .byte $63, $ff, $00 ; .##...##########........
                            .byte $f7, $ff, $c0 ; ####.###.###.#####......
                            .byte $ff, $ff, $c0 ; ##################......
                            .byte $1f, $fe, $00 ; ...############.........
                            .byte $3f, $80, $00 ; ..#######...............
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveOut_05      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $01, $fc, $00 ; .......#######..........
                            .byte $63, $ff, $00 ; .##...##########........
                            .byte $f7, $ff, $fc ; ####.#################..
                            .byte $ff, $ff, $fc ; ######################..
                            .byte $1f, $fe, $00 ; ...############.........
                            .byte $3f, $80, $00 ; ..#######...............
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveOut_06      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $01, $fc, $00 ; .......#######..........
                            .byte $63, $ff, $03 ; .##...##########......##
                            .byte $f7, $ff, $ff ; ####.###################
                            .byte $ff, $ff, $fe ; #######################.
                            .byte $1f, $fe, $00 ; ...############.........
                            .byte $3f, $80, $00 ; ..#######...............
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveLeft_01     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $30 ; ..........##....
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $38 ; ..........###...
                            .byte $0f, $f8 ; ....#########...
                            .byte $00, $fc ; ........######..
                            .byte $0f, $fc ; ....##########..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $7c ; .........#####..
                            .byte $00, $6e ; .........##.###.
                            .byte $00, $66 ; .........##..##.
                            .byte $00, $c6 ; ........##...##.
                            .byte $00, $cf ; ........##..####
                            .byte $03, $cf ; ......####..####
                            .byte $03, $c0 ; ......####......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveLeft_02     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $30 ; ..........##....
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $0e, $38 ; ....###...###...
                            .byte $01, $f8 ; .......######...
                            .byte $00, $3c ; ..........####..
                            .byte $01, $fc ; .......#######..
                            .byte $0e, $3c ; ....###...####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $fc ; ........######..
                            .byte $00, $0c ; ............##..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveLeft_03     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $30 ; ..........##....
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $f8 ; ........#####...
                            .byte $00, $38 ; ..........###...
                            .byte $00, $f8 ; ........#####...
                            .byte $0f, $3c ; ....####..####..
                            .byte $0f, $fc ; ....##########..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $3c ; ..........####..
                            .byte $00, $36 ; ..........##.##.
                            .byte $00, $36 ; ..........##.##.
                            .byte $00, $33 ; ..........##..##
                            .byte $00, $f3 ; ........####..##
                            .byte $00, $f7 ; ........####.###
                            .byte $00, $07 ; .............###
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveRight_01    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $0c, $00 ; ............##..........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1c, $00 ; ...........###..........
                            .byte $00, $1f, $f0 ; ...........#########....
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3f, $f0 ; ..........######........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3e, $00 ; ..........#####.........
                            .byte $00, $76, $00 ; .........###.##.........
                            .byte $00, $66, $00 ; .........##..##.........
                            .byte $00, $63, $00 ; .........##...##........
                            .byte $00, $f3, $00 ; ........####..##........
                            .byte $00, $f3, $c0 ; ........####..##........
                            .byte $00, $03, $c0 ; ..............####......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveRight_02    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $0c, $00 ; ............##..........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1c, $70 ; ...........###...###....
                            .byte $00, $1f, $80 ; ...........######.......
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3f, $80 ; ..........#######.......
                            .byte $00, $3c, $f0 ; ..........####..####....
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $1f, $00 ; ..........######........
                            .byte $00, $1f, $00 ; ..........######........
                            .byte $00, $30, $00 ; ..........##............
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataMummyMoveRight_03    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var  Sprite_Attr_Flag_MColor | Sprite_Attr_Color_Mummy ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $0c, $00 ; ............##..........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $1c, $00 ; ...........###..........
                            .byte $00, $1f, $00 ; ...........#####........
                            .byte $00, $3c, $f0 ; ..........####..####....
                            .byte $00, $3f, $f0 ; ..........##########....
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $3c, $00 ; ..........####..........
                            .byte $00, $6c, $00 ; .........##.##..........
                            .byte $00, $6c, $00 ; .........##.##..........
                            .byte $00, $cc, $00 ; ........##..##..........
                            .byte $00, $cf, $00 ; ........##..####........
                            .byte $00, $ef, $00 ; ........###.####........
                            .byte $00, $e0, $00 ; ........###.............
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataKeyWhite             = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $15 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $55, $55 ; .#.#.#.#.#.#.#.#
                            .byte $50, $05 ; .#.#.........#.#
                            .byte $50, $05 ; .#.#.........#.#
                            .byte $50, $05 ; .#.#.........#.#
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $44 ; .......#.#...#..
                            .byte $01, $54 ; .......#.#.#.#..
                            .byte $01, $50 ; .......#.#.#....
                            .byte $01, $50 ; .......#.#.#....
                            .byte $01, $54 ; .......#.#.#.#..
                            .byte $01, $44 ; .......#.#...#..
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_WHITE_WHITE ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataKeyRed               = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $14, $00, $00 ; ...#.#..................
                            .byte $14, $00, $00 ; ...#.#..................
                            .byte $15, $00, $00 ; ...#.#.#................
                            .byte $41, $00, $00 ; .#.....#................
                            .byte $55, $00, $00 ; .#.#.#.#................
                            .byte $41, $00, $00 ; .#.....#................
                            .byte $41, $55, $55 ; .#.....#.#.#.#.#.#.#.#.#
                            .byte $41, $96, $55 ; .#.....##..#.##..#.#.#.#
                            .byte $41, $00, $54 ; .#.....#.........#.#.#..
                            .byte $55, $00, $54 ; .#.#.#.#.........#.#.#..
                            .byte $41, $00, $10 ; .#.....#...........#....
                            .byte $55, $00, $10 ; .#.#.#.#...........#....
                            .byte $14, $01, $55 ; ...#.#.........#.#.#.#.#
                            .byte $14, $01, $45 ; ...#.#.........#.#...#.#
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_RED_RED ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataKeyCyan              = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $17 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $14, $14 ; ...#.#.....#.#..
                            .byte $54, $15 ; .#.#.#.....#.#.#
                            .byte $55, $55 ; .#.#.#.#.#.#.#.#
                            .byte $55, $55 ; .#.#.#.#.#.#.#.#
                            .byte $55, $55 ; .#.#.#.#.#.#.#.#
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $54 ; .......#.#.#.#..
                            .byte $01, $54 ; .......#.#.#.#..
                            .byte $01, $54 ; .......#.#.#.#..
                            .byte $01, $54 ; .......#.#.#.#..
                            .byte $01, $40 ; .......#.#......
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_CYAN_CYAN ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataKeyPurple            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $50 ; .................#.#....
                            .byte $00, $01, $04 ; ...............#.....#..
                            .byte $00, $01, $04 ; ...............#.....#..
                            .byte $00, $01, $05 ; ...............#.....#.#
                            .byte $00, $01, $05 ; ...............#.....#.#
                            .byte $00, $01, $01 ; ...............#.......#
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#
                            .byte $55, $96, $55 ; .#.#.#.##..#.##..#.#.#.#
                            .byte $14, $01, $01 ; ...#.#.........#.......#
                            .byte $14, $01, $05 ; ...#.#.........#.....#.#
                            .byte $15, $01, $05 ; ...#.#.#.......#.....#.#
                            .byte $15, $01, $04 ; ...#.#.#.......#.....#..
                            .byte $14, $01, $04 ; ...#.#.........#.....#..
                            .byte $44, $00, $50 ; .#...#...........#.#....
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_PURPLE_PURPLE ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataKeyGreen             = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $55, $40, $00 ; .#.#.#.#.#..............
                            .byte $55, $40, $00 ; .#.#.#.#.#..............
                            .byte $55, $40, $00 ; .#.#.#.#.#..............
                            .byte $55, $40, $00 ; .#.#.#.#.#..............
                            .byte $55, $40, $00 ; .#.#.#.#.#..............
                            .byte $55, $40, $00 ; .#.#.#.#.#..............
                            .byte $45, $55, $55 ; .#...#.#.#.#.#.#.#.#.#.#
                            .byte $45, $96, $55 ; .#...#.##..#.##..#.#.#.#
                            .byte $55, $40, $50 ; .#.#.#.#.#.......#.#....
                            .byte $55, $40, $54 ; .#.#.#.#.#.......#.#.#..
                            .byte $55, $40, $50 ; .#.#.#.#.#.......#.#....
                            .byte $55, $40, $54 ; .#.#.#.#.#.......#.#.#..
                            .byte $55, $40, $50 ; .#.#.#.#.#.......#.#....
                            .byte $55, $40, $00 ; .#.#.#.#.#..............
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_GREEN_GREEN ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataKeyBlue              = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $17 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $54, $15 ; .#.#.#.....#.#.#
                            .byte $54, $15 ; .#.#.#.....#.#.#
                            .byte $55, $55 ; .#.#.#.#.#.#.#.#
                            .byte $55, $55 ; .#.#.#.#.#.#.#.#
                            .byte $55, $55 ; .#.#.#.#.#.#.#.#
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $55 ; .......#.#.#.#.#
                            .byte $01, $55 ; .......#.#.#.#.#
                            .byte $01, $55 ; .......#.#.#.#.#
                            .byte $01, $45 ; .......#.#...#.#
                            .byte $01, $45 ; .......#.#...#.#
                            .byte $01, $40 ; .......#.#......
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_BLUE_BLUE ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataKeyYellow            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $0f ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $15, $00, $00 ; ...#.#.#................
                            .byte $44, $40, $00 ; .#...#...#..............
                            .byte $44, $40, $00 ; .#...#...#..............
                            .byte $55, $40, $00 ; .#.#.#.#.#..............
                            .byte $44, $40, $00 ; .#...#...#..............
                            .byte $44, $40, $00 ; .#...#...#..............
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#
                            .byte $55, $96, $55 ; .#.#.#.##..#.##..#.#.#.#
                            .byte $44, $40, $14 ; .#...#...#.........#.#..
                            .byte $44, $40, $14 ; .#...#...#.........#.#..
                            .byte $55, $40, $14 ; .#.#.#.#.#.........#.#..
                            .byte $44, $40, $10 ; .#...#...#.........#....
                            .byte $44, $40, $10 ; .#...#...#.........#....
                            .byte $15, $00, $00 ; ...#.#.#................
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_YELLOW_YELLOW ; $06 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataLock                 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $17 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#
                            .byte $55, $41, $55 ; .#.#.#.#.#.....#.#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $41, $55 ; .#.#.#.#.#.....#.#.#.#.#
                            .byte $55, $41, $55 ; .#.#.#.#.#.....#.#.#.#.#
                            .byte $55, $41, $55 ; .#.#.#.#.#.....#.#.#.#.#
                            .byte $55, $41, $55 ; .#.#.#.#.#.....#.#.#.#.#
                            .byte $55, $41, $55 ; .#.#.#.#.#.....#.#.#.#.#
                            .byte $55, $41, $55 ; .#.#.#.#.#.....#.#.#.#.#
                            .byte $55, $41, $55 ; .#.#.#.#.#.....#.#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $00, $55 ; .#.#.#.#.........#.#.#.#
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#
                            .byte $55, $aa, $55 ; .#.#.#.##.#.#.#..#.#.#.#
                            .byte $55, $55, $55 ; .#.#.#.#.#.#.#.#.#.#.#.#
                            
Item_Colors                 .var  *   ; 
TabDataLockColor            .byte $80, $a0, $93 ; variable object color bytes
                            .byte $ff, $a4, $d2 ; 
                            .byte $a0, $b8, $b5 ; 
TabDataLockColor_Len        = * - TabDataLockColor - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunPoleLeft       = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $3a ; ..###.#.
                            .byte $fa ; #####.#.
                            .byte $fa ; #####.#.
                            .byte $3a ; ..###.#.
                            .byte $3a ; ..###.#.
                            .byte $fa ; #####.#.
                            .byte $fa ; #####.#.
                            .byte $3a ; #.#.#.#.
                            
Item_Colors                 .var  *   ; 
                            .byte HR_BLACK_BLUE  ; object color
                            .byte HR_BLACK_WHITE ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunPoleRight      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $ac ; #.#.##..
                            .byte $af ; #.#.####
                            .byte $af ; #.#.####
                            .byte $ac ; #.#.##..
                            .byte $ac ; #.#.##..
                            .byte $af ; #.#.####
                            .byte $af ; #.#.####
                            .byte $ac ; #.#.##..
                            
Item_Colors                 .var  *   ; 
                            .byte HR_BLACK_BLUE  ; object color
                            .byte HR_BLACK_WHITE ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunLaserRight_01  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0b ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite

Item_RayGun_Rows            = TabData_Hdr_Rows ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $30, $30 ; ..##......##....
                            .byte $0c, $30 ; ....##....##....
                            .byte $c0, $cc ; ##....####..##..
                            .byte $e0, $cc ; ###.....##..##..
                            .byte $2a, $cc ; ..#.#.#.##..##..
                            .byte $2a, $ea ; ..#.#.#.###.#.#.
                            .byte $ea, $cc ; ###.#.#.##..##..
                            .byte $ec, $cc ; ###.##..##..##..
                            .byte $00, $cc ; ........##..##..
                            .byte $30, $30 ; ..##......##....
                            .byte $30, $30 ; ..##......##....
                            
Item_Colors                 .var  *   ; 
                            .byte LT_BLUE, WHITE ; object colors
                            .byte LT_BLUE, WHITE ; 
                            .byte YELLOW, LT_RED ; object colors
                            .byte YELLOW, LT_RED ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunLaserRight_02  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0b ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $30 ; ..........##....
                            .byte $cc, $30 ; ##..##....##....
                            .byte $cc, $cc ; ##..##..##..##..
                            .byte $20, $cc ; ..#.....##..##..
                            .byte $2a, $cc ; ..#.#.#.##..##..
                            .byte $ea, $ea ; ###.#.#.###.#.#.
                            .byte $ea, $cc ; ###.#.#.##..##..
                            .byte $2c, $cc ; ..#.##..##..##..
                            .byte $0c, $cc ; ....##..##..##..
                            .byte $c0, $30 ; ##........##....
                            .byte $30, $30 ; ..##......##....
                            
Item_Colors                 .var  *   ; 
                            .byte LT_BLUE, WHITE ; object colors
                            .byte LT_BLUE, WHITE ; 
                            .byte YELLOW, LT_RED ; object colors
                            .byte YELLOW, LT_RED ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunLaserRight_03  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0b ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $30, $30 ; ..##......##....
                            .byte $c0, $30 ; ##........##....
                            .byte $0c, $cc ; ....##..##..##..
                            .byte $2c, $cc ; ..#.##..##..##..
                            .byte $ea, $cc ; ###.#.#.##..##..
                            .byte $ea, $ea ; ###.#.#.###.#.#.
                            .byte $2a, $cc ; ..#.#.#.##..##..
                            .byte $20, $cc ; ..#.....##..##..
                            .byte $cc, $cc ; ##..##..##..##..
                            .byte $cc, $30 ; ##..##....##....
                            .byte $00, $30 ; ..........##....
                            
Item_Colors                 .var  *   ; 
                            .byte LT_BLUE, WHITE ; object colors
                            .byte LT_BLUE, WHITE ; 
                            .byte YELLOW, LT_RED ; object colors
                            .byte YELLOW, LT_RED ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunLaserRight_04  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0b ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $30, $30 ; ..##......##....
                            .byte $30, $30 ; ..##......##....
                            .byte $00, $cc ; ........##..##..
                            .byte $ec, $cc ; ###.##..##..##..
                            .byte $ea, $cc ; ###.#.#.##..##..
                            .byte $2a, $ea ; ..#.#.#.###.#.#.
                            .byte $2a, $cc ; ..#.#.#.##..##..
                            .byte $e0, $cc ; ###.....##..##..
                            .byte $c0, $cc ; ##......##..##..
                            .byte $0c, $30 ; ....##....##....
                            .byte $30, $30 ; ..##......##....
                            
Item_Colors                 .var  *   ; 
                            .byte LT_BLUE, WHITE ; object colors
                            .byte LT_BLUE, WHITE ; 
                            .byte YELLOW, LT_RED ; object colors
                            .byte YELLOW, LT_RED ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunLaserLeft_01   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0b ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $0c, $0c ;....##......##.. 
                            .byte $0c, $30 ; ....##....##....
                            .byte $3f, $03 ; ....####......##
                            .byte $3f, $0b ; ..######....#.##
                            .byte $3f, $a8 ; ..#######.#.#...
                            .byte $bf, $a8 ; #.#######.#.#...
                            .byte $3f, $ab ; ..#######.#.#.##
                            .byte $3f, $3b ; ..#######.##    
                            .byte $3f, $00 ; ..######........
                            .byte $0c, $0c ; ....##......##..
                            .byte $0c, $0c ; ....##......##..
                            
Item_Colors                 .var  *   ; 
                            .byte WHITE, LT_BLUE ; object colors
                            .byte WHITE, LT_BLUE ; 
                            .byte LT_RED, YELLOW ; object colors
                            .byte LT_RED, YELLOW ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunLaserLeft_02   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0b ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $0c, $00 ; ....##..........
                            .byte $0c, $33 ; ....##....##..##
                            .byte $3f, $33 ; ..######..##..##
                            .byte $3f, $08 ; ..######..##..##
                            .byte $3f, $a8 ; ..#######.#.#...
                            .byte $bf, $ab ; #.#######.#.#.##
                            .byte $3f, $ab ; ..#######.#.#.##
                            .byte $3f, $38 ; ..######..###...
                            .byte $3f, $30 ; ..######..##....
                            .byte $0c, $03 ; ....##........##
                            .byte $0c, $0c ; ....##......##..
                            
Item_Colors                 .var  *   ; 
                            .byte WHITE, LT_BLUE ; object colors
                            .byte WHITE, LT_BLUE ; 
                            .byte LT_RED, YELLOW ; object colors
                            .byte LT_RED, YELLOW ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunLaserLeft_03   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0b ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $0c, $0c ; ....##......##..
                            .byte $0c, $03 ; ....##........##
                            .byte $3f, $30 ; ..######..##....
                            .byte $3f, $38 ; ..######..###...
                            .byte $3f, $ab ; ..#######.#.#.##
                            .byte $bf, $ab ; #.#######.#.#.##
                            .byte $3f, $a8 ; ..#######.#.#...
                            .byte $3f, $08 ; ..######....#...
                            .byte $3f, $33 ; ..######..##..##
                            .byte $0c, $33 ; ....##....##..##
                            .byte $0c, $00 ; ....##..........
                            
Item_Colors                 .var  *   ; 
                            .byte WHITE, LT_BLUE ; object colors
                            .byte WHITE, LT_BLUE ; 
                            .byte LT_RED, YELLOW ; object colors
                            .byte LT_RED, YELLOW ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunLaserLeft_04   = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0b ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $0c, $0c ; ....##......##..
                            .byte $0c, $0c ; ....##......##..
                            .byte $3f, $00 ; ..######........
                            .byte $3f, $3b ; ..######..###.##
                            .byte $3f, $ab ; ..#######.#.#.##
                            .byte $bf, $a8 ; #.#######.#.#...
                            .byte $3f, $a8 ; ..#######.#.#...
                            .byte $3f, $0b ; ..######....#.##
                            .byte $3f, $03 ; ..######......##
                            .byte $0c, $30 ; ....##....##....
                            .byte $0c, $0c ; ....##......##..
                            
Item_Colors                 .var  *   ; 
                            .byte WHITE, LT_BLUE ; object colors
                            .byte WHITE, LT_BLUE ; 
                            .byte LT_RED, YELLOW ; object colors
                            .byte LT_RED, YELLOW ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunBeam           = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var RED ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $aa, $aa ; #.#.#.#.#.#.#.#.
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunSwitch         = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $17 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $01, $40 ; .......#.#......
                            .byte $00, $00 ; ................
                            .byte $01, $40 ; .......#.#......
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $02, $80 ; ......#.#.......
                            .byte $00, $00 ; ................
                            .byte $01, $40 ; .......#.#......
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $15, $54 ; ...#.#.#.#.#.#..
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $01, $40 ; .......#.#......
                            .byte $01, $40 ; .......#.#......
                            
Item_Colors                 .var  *   ; 
                            .byte HR_GREY_BLACK, HR_GREY_BLACK   ; object color top
                            .byte HR_WHITE_WHITE, HR_WHITE_WHITE ; object color mid
                            .byte HR_GREY_BLACK, HR_GREY_BLACK   ; object color top
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataRayGunSwitchColor    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            
TabDataRayGunSwitchColor_1  .byte $e9 ; variable object colors
TabDataRayGunSwitchColor_2  .byte $a0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataXmitBooth            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $04 ; 
TabData_Hdr_Rows            .var  $20 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00, $00 ; ................................
                            .byte $00, $00, $00, $00 ; ................................
                            .byte $03, $ff, $ff, $f8 ; ......#######################...
                            .byte $03, $ff, $ff, $f8 ; ......#######################...
                            .byte $0f, $ff, $ff, $e4 ; ....#######################..#..
                            .byte $0f, $ff, $ff, $e4 ; ....#######################..#..
                            .byte $3f, $ff, $ff, $94 ; ..#######################..#.#..
                            .byte $3f, $ff, $ff, $94 ; ..#######################..#.#..
                            .byte $ff, $ff, $fe, $54 ; #######################..#.#.#..
                            .byte $ff, $ff, $fe, $54 ; #######################..#.#.#..
                            .byte $ff, $57, $fe, $54 ; ########.#.#.##########..#.#.#..
                            .byte $fc, $55, $fe, $54 ; ######...#.#.#.########..#.#.#..
                            .byte $fc, $55, $fe, $54 ; ######...#.#.#.########..#.#.#..
                            .byte $f0, $55, $7e, $54 ; ####.....#.#.#.#.######..#.#.#..
                            .byte $f0, $55, $7e, $54 ; ####.....#.#.#.#.######..#.#.#..
                            .byte $f8, $55, $7e, $54 ; #####....#.#.#.#.######..#.#.#..
                            .byte $f8, $55, $7e, $54 ; #####....#.#.#.#.######..#.#.#..
                            .byte $f8, $55, $7e, $54 ; #####....#.#.#.#.######..#.#.#..
                            .byte $f8, $55, $7e, $54 ; #####....#.#.#.#.######..#.#.#..
                            .byte $fe, $55, $fe, $54 ; #######..#.#.#.########..#.#.#..
                            .byte $fe, $55, $fe, $54 ; #######..#.#.#.########..#.#.#..
                            .byte $ff, $d7, $fe, $54 ; ##########.#.##########..#.#.#..
                            .byte $ff, $ff, $fe, $54 ; #######################..#.#.#..
                            .byte $ff, $ff, $fe, $54 ; #######################..#.#.#..
                            .byte $ff, $ff, $fe, $00 ; #######################.........
                            .byte $ff, $ff, $fe, $00 ; #######################.........
                            .byte $ff, $ff, $fe, $00 ; #######################.........
                            .byte $ff, $ff, $fe, $00 ; #######################.........
                            .byte $ff, $ff, $fe, $00 ; #######################.........
                            .byte $ff, $ff, $fe, $00 ; #######################.........
                            .byte $ff, $ff, $fc, $00 ; ######################..........
                            .byte $ff, $ff, $fc, $00 ; ######################..........
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_BLACK_LT_RED                           ; $10 color bytes
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols - (3 * TabData_Hdr_Cols), HR_BLACK_LT_GREY ; $04 color bytes
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols - (1 * TabData_Hdr_Cols), HR_BLACK_WHITE   ; $0c color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataXmitBooth_HotSpot    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $ff ; ########
                            
Item_Colors                 .var  *   ; 
                            .byte LT_RED ; object color
                            .byte WHITE  ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
; xmitter booth back wall row - one third of the complete wall
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataXmitBoothBack        = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            
Item_Colors                 .var  *   ; 
TabDataXmitBoothBackColor_0 .byte $b0 ; 
TabDataXmitBoothBackColor_1 .byte $a0 ; 
TabDataXmitBoothBackColor_2 .byte $a0 ; 
                             
TabDataXmitBoothBackColor_3 .byte $a0 ; 
TabDataXmitBoothBackColor_4 .byte $90 ; 
TabDataXmitBoothBackColor_5 .byte $b0 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataXmitTarget           = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $0e ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $00, $00 ; ................
                            .byte $05, $40 ; .....#.#.#......
                            .byte $15, $50 ; ...#.#.#.#.#....
                            .byte $15, $50 ; ...#.#.#.#.#....
                            .byte $55, $54 ; .#.#.#.#.#.#.#..
                            .byte $55, $54 ; .#.#.#.#.#.#.#..
                            .byte $55, $54 ; .#.#.#.#.#.#.#..
                            .byte $55, $54 ; .#.#.#.#.#.#.#..
                            .byte $55, $54 ; .#.#.#.#.#.#.#..
                            .byte $55, $54 ; .#.#.#.#.#.#.#..
                            .byte $15, $50 ; ...#.#.#.#.#....
                            .byte $15, $50 ; ...#.#.#.#.#....
                            .byte $05, $40 ; .....#.#.#......
                            
Item_Colors                 .var  *   ; 
TabDataXmitTargetColor_0    .byte $a0 ; variable colors
TabDataXmitTargetColor_1    .byte $e7 ; 
TabDataXmitTargetColor_2    .byte $a0 ; 
TabDataXmitTargetColor_3    .byte $8a ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapMove_01          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; trap part #1a - 1st bottom part
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $0a, $aa, $00 ; ....#.#.#.#.#.#.........
                            
Item_Colors                 .var  *   ; 
TabDataTrapMove_01_Color_0  .byte $b1 ; variable colors
TabDataTrapMove_01_Color_1  .byte $90 ; 
TabDataTrapMove_01_Color_2  .byte $a0 ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapMove_02          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $05 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; trap part #1b - 2nd bottom part
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $0a, $aa, $00 ; ....#.#.#.#.#.#.........
                            
Item_Colors                 .var  *   ; 
TabDataTrapMove_02_Color_0  .byte $a0 ; variable colors
TabDataTrapMove_02_Color_1  .byte $80 ; 
TabDataTrapMove_02_Color_2  .byte $a0 ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapMove_03          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $04 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; trap part #2a - 1st middle part
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $02, $aa, $80 ; ......#.#.#.#.#.#.......
                            
Item_Colors                 .var  *   ; 
TabDataTrapMove_03_Color_0  .byte $a0 ; variable colors
TabDataTrapMove_03_Color_1  .byte $a0 ; 
TabDataTrapMove_03_Color_2  .byte $90 ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapMove_04          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $03 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; trap part #2b - 2nd middle part
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $00, $00 ; ........................
                            .byte $01, $55, $40 ; .......#.#.#.#.#.#......
                            
Item_Colors                 .var  *   ; 
TabDataTrapMove_04_Color_0  .byte $c5 ; variable colors
TabDataTrapMove_04_Color_1  .byte $c2 ; 
TabDataTrapMove_04_Color_2  .byte $90 ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapMove_05          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $02 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; trap part #3a - 2nd top part
                            .byte $00, $00, $00 ; ........................
                            .byte $00, $55, $50 ; .........#.#.#.#.#.#....
                            
Item_Colors                 .var  *   ; 
TabDataTrapMove_05_Color_0  .byte $a0 ; variable colors
TabDataTrapMove_05_Color_1  .byte $80 ; 
TabDataTrapMove_05_Color_2  .byte $ac ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapMove_06          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; trap part #3b - 2nd top part
                            .byte $00, $55, $50 ; .........#.#.#.#.#.#....
                            
Item_Colors                 .var  *   ; 
TabDataTrapMove_06_Color_0  .byte $a0 ; variable colors
TabDataTrapMove_06_Color_1  .byte $ac ; 
TabDataTrapMove_06_Color_2  .byte $c8 ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapOpen_HotSpot     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $aa ; #.#.#.#.
                            .byte $00 ; 
                            
Item_Colors                 .var  *   ; 
                            .byte HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapSwitch           = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $17 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00 ; ........
                            .byte $14 ; ...#.#..
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            .byte $14 ; ...#.#..
                            .byte $00 ; ........
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $14 ; ...#.#..
                            .byte $00 ; ........
                            .byte $14 ; ...#.#..
                            .byte $aa ; #.#.#.#.
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            .byte $55 ; .#.#.#.#
                            .byte $14 ; ...#.#..
                            
Item_Colors                 .var  *   ; 
TabDataTrapSwitchColor_Top  .byte HR_GREY_BLACK  ; variable color top
                            .byte HR_WHITE_BLACK ; fix color mid
TabDataTrapSwitchColor_Bot  .byte HR_GREY_GREY   ; variable color bottom
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataTrapOpen         = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $55, $50 ; .........#.#.#.#.#.#....
                            .byte $00, $55, $50 ; .........#.#.#.#.#.#....
                            .byte $01, $55, $40 ; .......#.#.#.#.#.#......
                            .byte $02, $aa, $80 ; ......#.#.#.#.#.#.......
                            .byte $0a, $aa, $00 ; ....#.#.#.#.#.#.........
                            .byte $0a, $aa, $00 ; ....#.#.#.#.#.#.........
; --------------------------------------------------------------------------------------------------------------------- ;
DatObjBlank                 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $01 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $ff ; ########
                            .byte $ff ; ########
                            .byte $ff ; ########
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataWalkBlank            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $08 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff ; ################################################################
                            .byte $0f, $ff, $ff, $ff, $ff, $ff, $ff, $ff ; ....############################################################
                            .byte $3f, $ff, $ff, $ff, $ff, $ff, $ff, $fc ; ..############################################################..
                            .byte $3f, $ff, $ff, $ff, $ff, $ff, $ff, $fc ; ..############################################################..
                            .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $f0 ; ############################################################....
                            .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $f0 ; ############################################################....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataWalkMove_01          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $08 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $aa, $aa, $aa, $aa, $aa, $aa, $aa, $aa ; #.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.
                            .byte $51, $41, $41, $41, $41, $41, $41, $40 ; .#.#...#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#......
                            .byte $45, $05, $05, $05, $05, $05, $05, $01 ; .#...#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.......#
                            .byte $8a, $0a, $0a, $0a, $0a, $0a, $0a, $02 ; #...#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.......#.
                            .byte $28, $28, $28, $28, $28, $28, $28, $0a ; ..#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.#.
                            .byte $28, $28, $28, $28, $28, $28, $28, $0a ; ..#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.#.
                            
Item_Colors                 .var  *   ; 
TabDataWalkMove_01_Color    .byte $c9, $a0, $af, $b1, $a0, $a2, $a0, $8a ; variable colors
TabDataWalkMoveColor_Len    = * - TabDataWalkMove_01_Color - $01 ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
                            
TabDataWalkMove_02          = *       ; 
                            .byte $08 ; cols
                            .byte $06 ; rows
                            .byte $00 ; 
                            .byte $aa, $aa, $aa, $aa, $aa, $aa, $aa, $aa ; #.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.
                            .byte $50, $50, $50, $50, $50, $50, $50, $50 ; .#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#....
                            .byte $41, $41, $41, $41, $41, $41, $41, $41 ; .#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#
                            .byte $82, $82, $82, $82, $82, $82, $82, $82 ; #.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.
                            .byte $0a, $0a, $0a, $0a, $0a, $0a, $0a, $0a ; ....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.
                            .byte $0a, $0a, $0a, $0a, $0a, $0a, $0a, $0a ; ....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.
                            
Item_Colors                 .var  *   ; 
TabDataWalkMove_02_Color    .byte $b2, $b9, $a0, $a6, $b0, $a0, $f0, $80 ; variable colors
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataWalkMove_03          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $08 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $aa, $aa, $aa, $aa, $aa, $aa, $aa, $aa ; #.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.
                            .byte $50, $14, $14, $14, $14, $14, $14, $14 ; .#.#.......#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#..
                            .byte $40, $50, $50, $50, $50, $50, $50, $51 ; .#.......#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#....
                            .byte $80, $a0, $a0, $a0, $a0, $a0, $a0, $a2 ; #.......#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#...#.
                            .byte $02, $82, $82, $82, $82, $82, $82, $8a ; ......#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#...#.#.
                            .byte $02, $82, $82, $82, $82, $82, $82, $8a ; ......#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#...#.#.
                            
Item_Colors                 .var  *   ; 
TabDataWalkMove_03_Color    .byte $8f, $a0, $89, $a0, $a0, $ff, $a0, $e7 ; variable colors
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataWalkMove_04          = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $08 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $aa, $aa, $aa, $aa, $aa, $aa, $aa, $aa ; #.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.
                            .byte $51, $05, $05, $05, $05, $05, $05, $04 ; .#.#...#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#..
                            .byte $44, $14, $14, $14, $14, $14, $14, $11 ; .#...#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#...#
                            .byte $88, $28, $28, $28, $28, $28, $28, $22 ; #...#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#...#.
                            .byte $20, $a0, $a0, $a0, $a0, $a0, $a0, $8a ; ..#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#...#.#.
                            .byte $20, $a0, $a0, $a0, $a0, $a0, $a0, $8a ; ..#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#...#.#.
                            
Item_Colors                 .var  *   ; 
TabDataWalkMove_04_Color    .byte $b6, $a0, $e6, $a0, $8c, $a0, $a0, $ba ; variable colors
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataWalkSwitch           = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $03 ; 
TabData_Hdr_Rows            .var  $08 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $00 ; ........................
                            .byte $01, $00, $40 ; .......#.........#......
                            .byte $05, $14, $50 ; .....#.#...#.#...#.#....
                            .byte $14, $55, $14 ; ...#.#...#.#.#.#...#.#..
                            .byte $54, $55, $15 ; .#.#.#...#.#.#.#...#.#.#
                            .byte $14, $55, $14 ; ...#.#...#.#.#.#...#.#..
                            .byte $05, $14, $50 ; .....#.#...#.#...#.#....
                            .byte $01, $00, $40 ; .......#.........#......
                            
Item_Colors                 .var  *   ; 
TabDataWalkSwitchColor_Le   .byte HR_GREY_BLACK  ; variable color left
                            .byte HR_WHITE_BLACK ; fix color mid
TabDataWalkSwitchColor_Ri   .byte HR_GREY_BLACK  ; variable color right
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataWalk_HotSpot         = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $01 ; 
TabData_Hdr_Rows            .var  $03 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $aa ; #.#.#.#.
                            
Item_Colors                 .var  *   ; 
                            .byte HR_BLACK_BLACK ; object color
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankMoveRight_01    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $01, $50 ; .......#.#.#....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $00, $c0 ; ........##......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $0a, $88 ; ....#.#.#...#...
                            .byte $22, $88 ; ..#...#.#...#...
                            .byte $22, $8c ; ..#...#.#...##..
                            .byte $32, $80 ; ..##..#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $20 ; ......#...#.....
                            .byte $08, $20 ; ....#.....#.....
                            .byte $0f, $20 ; ....####..#.....
                            .byte $0f, $3c ; ....####..####..
                            .byte $00, $3c ; ..........####..
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankMoveRight_02    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $01, $50 ; .......#.#.#....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $00, $c0 ; ........##......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $0a, $88 ; ....#.#.#...#...
                            .byte $22, $88 ; ..#...#.#...#...
                            .byte $22, $8c ; ..#...#.#...##..
                            .byte $32, $80 ; ..##..#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $20 ; ......#...#.....
                            .byte $02, $20 ; ......#...#.....
                            .byte $02, $80 ; ......#.#.......
                            .byte $0e, $00 ; ....###.........
                            .byte $0e, $00 ; ....###.........
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankMoveRight_03    = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $01, $50 ; .......#.#.#....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $00, $c0 ; ........##......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $0a, $88 ; ....#.#.#...#...
                            .byte $22, $88 ; ..#...#.#...#...
                            .byte $22, $8c ; ..#...#.#...##..
                            .byte $32, $80 ; ..##..#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $02, $20 ; ......#...#.....
                            .byte $08, $20 ; ....#.....#.....
                            .byte $08, $3c ; ....#.....####..
                            .byte $08, $3c ; ....#.....####..
                            .byte $0f, $00 ; ....####........
                            .byte $0f, $00 ; ....####........
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankMoveLeft_01     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $05, $40 ; .....#.#.#......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $03, $00 ; ......##........
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $0a, $88 ; ....#.#.#...#...
                            .byte $22, $88 ; ..#...#.#...#...
                            .byte $22, $8c ; ..#...#.#...##..
                            .byte $32, $80 ; ..##..#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $08, $80 ; ....#...#.......
                            .byte $08, $20 ; ....#.....#.....
                            .byte $08, $f0 ; ....#...####....
                            .byte $3c, $f0 ; ..####..####....
                            .byte $3c, $00 ; ..####..####....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankMoveLeft_02     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $05, $40 ; .....#.#.#......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $03, $00 ; ......##........
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $0a, $88 ; ....#.#.#...#...
                            .byte $22, $88 ; ..#...#.#...#...
                            .byte $22, $8c ; ..#...#.#...##..
                            .byte $32, $80 ; ..##..#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $08, $80 ; ....#...#.......
                            .byte $08, $80 ; ....#...#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $00, $b0 ; ........#.##....
                            .byte $00, $b0 ; ........#.##....
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankMoveLeft_03     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $05, $40 ; .....#.#.#......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $03, $00 ; ......##........
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $0a, $88 ; ....#.#.#...#...
                            .byte $22, $88 ; ..#...#.#...#...
                            .byte $22, $8c ; ..#...#.#...##..
                            .byte $32, $80 ; ..##..#.#.......
                            .byte $01, $40 ; .......#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $08, $80 ; ....#...#.......
                            .byte $08, $20 ; ....#.....#.....
                            .byte $3c, $20 ; ..####....#.....
                            .byte $3c, $20 ; ..####....#.....
                            .byte $00, $f0 ; ........####....
                            .byte $00, $f0 ; ........####....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankSlidePole       = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $03, $00 ; ......##........
                            .byte $08, $80 ; ....#...#.......
                            .byte $25, $60 ; ..#..#.#.##.....
                            .byte $2f, $e0 ; ..#.#######.....
                            .byte $2f, $e0 ; ..#.#######.....
                            .byte $2f, $e0 ; ###.#######.....
                            .byte $23, $20 ; ..#...##..#.....
                            .byte $2a, $a0 ; ..#.#.#.#.#.....
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $05, $40 ; .....#.#.#......
                            .byte $0a, $80 ; ....#.#.#.......
                            .byte $28, $a0 ; ..#.#...#.#.....
                            .byte $20, $20 ; ..#.......#.....
                            .byte $08, $80 ; ....#...#.......
                            .byte $0f, $c0 ; ....######......
                            .byte $0c, $c0 ; ....##..##......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankClimbLadder_01  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $0c ; ............##..
                            .byte $00, $80 ; ........#.......
                            .byte $05, $58 ; .....#.#.#.##...
                            .byte $0f, $f8 ; ....#########...
                            .byte $3f, $80 ; ..#######.......
                            .byte $8f, $f0 ; #...########....
                            .byte $83, $c0 ; #.....####......
                            .byte $82, $80 ; #.....#.#.......
                            .byte $2a, $a0 ; ..#.#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $20 ; ......#...#.....
                            .byte $02, $08 ; ......#.....#...
                            .byte $02, $3c ; ......#...####..
                            .byte $02, $3c ; ......#...####..
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankClimbLadder_02  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $00, $00 ; ................
                            .byte $05, $5c ; .....#.#.#.###..
                            .byte $0f, $f8 ; ....#########...
                            .byte $0f, $f8 ; ....#########...
                            .byte $0f, $f8 ; ....#########...
                            .byte $33, $c8 ; ..##..####..#...
                            .byte $22, $80 ; ..#...#.#.......
                            .byte $2a, $a0 ; ..#.#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
                            .byte $00, $00 ; ................
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankClimbLadder_03  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $30, $00 ; ..##............
                            .byte $20, $00 ; ..#.............
                            .byte $25, $50 ; ..#..#.#.#.#....
                            .byte $2f, $f0 ; ..#.########....
                            .byte $2f, $fc ; ..#.##########..
                            .byte $0f, $f2 ; ....########..#.
                            .byte $03, $c2 ; ......####....#.
                            .byte $02, $82 ; ......#.#.....#.
                            .byte $0a, $a8 ; ....#.#.#.#.#...
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $02, $80 ; ......#.#.......
                            .byte $08, $80 ; ....#...#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $3c, $80 ; ..####..#.......
                            .byte $3c, $80 ; ..####..#.......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankClimbLadder_04  = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $00, $00 ; ................
                            .byte $35, $50 ; ..##.#.#.#.#..##
                            .byte $2f, $f0 ; ..#.########....
                            .byte $2f, $f0 ; ..#.########....
                            .byte $2f, $f0 ; ..#.########....
                            .byte $23, $cc ; ..#...####..##..
                            .byte $02, $88 ; ......#.#...#...
                            .byte $0a, $a8 ; ....#.#.#.#.#...
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
                            .byte $00, $00 ; ................
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankInCoffin        = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $14 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Fank ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $01, $50 ; .......#.#.#....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $03, $f0 ; ......######....
                            .byte $00, $c0 ; ........##......
                            .byte $02, $a0 ; ......#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $a0 ; ....#.#.#.#.....
                            .byte $0a, $b0 ; ....#.#.#.##....
                            .byte $0d, $40 ; ....##.#.#......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $80 ; ......#.#.......
                            .byte $02, $d0 ; ......#.##.#....
                            .byte $02, $f0 ; ......#.####....
                            .byte $03, $c0 ; ......####......
                            .byte $03, $c0 ; ......####......
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankCoffinRight     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $20 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $00, $00 ; ................
                            .byte $03, $fc ; ......########..
                            .byte $03, $fc ; ......########..
                            .byte $0f, $f4 ; ....########.#..
                            .byte $0f, $f4 ; ....########.#..
                            .byte $3f, $d4 ; ..########.#.#..
                            .byte $3f, $d4 ; ..########.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $54 ; #.#.#.#..#.#.#..
                            .byte $aa, $00 ; #.#.#.#.........
                            .byte $aa, $00 ; #.#.#.#.........
                            .byte $aa, $00 ; #.#.#.#.........
                            .byte $aa, $00 ; #.#.#.#.........
                            .byte $aa, $00 ; #.#.#.#.........
                            .byte $aa, $00 ; #.#.#.#.........
                            .byte $ff, $00 ; ########........
                            .byte $ff, $00 ; ########........
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_LT_RED_YELLOW ; $08 color bytes
                            .byte HR_BLACK_WHITE, HR_BLACK_WHITE ; 
                            .byte HR_BLACK_BLACK, HR_BLACK_BLACK ; 
                            .byte HR_BLACK_BLACK, HR_BLACK_BLACK ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankCoffinLeft      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $20 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00 ; ................
                            .byte $00, $00 ; ................
                            .byte $03, $fc ; ......########..
                            .byte $03, $fc ; ......########..
                            .byte $0f, $f8 ; ....#########...
                            .byte $0f, $f8 ; ....#########...
                            .byte $3f, $e8 ; ..#########.#...
                            .byte $3f, $e8 ; ..#########.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $a8 ; #.#.#.#.#.#.#...
                            .byte $aa, $ac ; #.#.#.#.#.#.##..
                            .byte $aa, $ac ; #.#.#.#.#.#.##..
                            .byte $aa, $b0 ; #.#.#.#.#.##....
                            .byte $aa, $b0 ; #.#.#.#.#.##....
                            .byte $aa, $c0 ; #.#.#.#.##......
                            .byte $ff, $c0 ; ##########......
                            .byte $ff, $00 ; ########........
                            
Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_LT_RED_YELLOW ; $08 color bytes
                            .byte HR_BLACK_WHITE, HR_BLACK_WHITE ; 
                            .byte HR_BLACK_BLACK, HR_BLACK_BLACK ; 
                            .byte HR_BLACK_BLACK, HR_BLACK_BLACK ; 
                            .byte HR_BLACK_BROWN, HR_BLACK_BROWN ; fix floor edge color 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear the floor start/end pieces for coffin insertion
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataFrankCoffinClear     = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $06 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $ff, $ff ; ################; 
                            .byte $ff, $ff ; ################; 
                            .byte $ff, $ff ; ################; 
                            .byte $ff, $ff ; ################; 
                            .byte $ff, $ff ; ################; 
                            .byte $ff, $ff ; ################; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataCastleTimeFrame      = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $08 ; 
TabData_Hdr_Rows            .var  $07 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabDataCastleTimeFrame_Hrs  = $00 * $03 ; offsets to fill in the digit char values of TabTimeFrameDigitChar
TabDataCastleTimeFrame_Min  = $01 * $03 ; 
TabDataCastleTimeFrame_Sec  = $02 * $03 ; 
TabDataCastleTimeFrame_Cols = TabData_Hdr_Cols ; number of time data cols from temp header
                            
TabData_Item                .var  * ; 
TabDataCastleTimeFrame_Char =     * ; offset digit insertion             ; $00 - hours               $03 - minutes             $06 - seconds                                   
                            .byte $00, $00, $00, $00, $00, $00, $00, $00 ; ................ ........ ................ ........ ................
                            .byte $00, $00, $30, $00, $00, $30, $00, $00 ; ................ ........ ................ ........ ................
                            .byte $00, $00, $30, $00, $00, $30, $00, $00 ; ................ ..##.... ................ ..##.... ................
                            .byte $00, $00, $00, $00, $00, $00, $00, $00 ; ................ ........ ................ ........ ................
                            .byte $00, $00, $30, $00, $00, $30, $00, $00 ; ................ ..##.... ................ ..##.... ................
                            .byte $00, $00, $30, $00, $00, $30, $00, $00 ; ................ ..##.... ................ ..##.... ................
                            .byte $00, $00, $00, $00, $00, $00, $00, $00 ; ................ ........ ................ ........ ................
                            
Item_Colors                 .var  *   ; 
                            .byte HR_LT_RED_BLACK, HR_LT_RED_GREEN, HR_LT_RED_BLACK , HR_LT_RED_RED     ; 
                            .byte HR_LT_RED_BLACK, HR_LT_RED_BLACK, HR_DK_GREY_BLACK, HR_LT_RED_BLACK   ; 
                            
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_BLACK_WHITE ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataCharClear            = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $18 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
TabDataCharClear_Rows       .byte TabData_Hdr_Rows ; variable - depending on the desired char height
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *        ; 
TabDataCharClear_Height_Sng = *            ; 
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            
TabDataCharClear_Height_Dbl = *            ; 
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            
TabDataCharClear_Height_Trp = *            ; 
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
                            .byte $ff, $ff ; ################
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataChar                 = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $18 ; default: rows for triple char height
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
TabDataChar_Rows            .byte TabData_Hdr_Rows ; variable - depending on the desired char height
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *        ; 
TabDataChar_Height_Single   = *            ; 
                            .byte $d2, $a0 ; ##.#..#. #.#..... - $00 $01 = offset single heigth
                            .byte $e8, $c2 ; ###.#... ##....#. - $02 $03 = offset double heigth
                            .byte $a0, $85 ; #.#..... #....#.# - $04 $05 = offset triple heigth
                            .byte $a0, $aa ; #.#..... #.#.#.#.
                            .byte $b7, $d5 ; #.##.### ##.#.#.#
                            .byte $80, $c6 ; #....... ##...##.
                            .byte $a9, $a0 ; #.#.#..# #.#.....
                            .byte $e8, $c6 ; ###.#... ##...##.
                            
TabDataChar_Colors_Single   = *            ; 
TabDataChar_Height_Double   = *            ; 
                            .byte $8c, $a0 ; #...##.. #.#.....
                            .byte $81, $85 ; #......# #....#.#
                            .byte $ba, $a4 ; #.###.#. #.#..#..
                            .byte $e5, $a0 ; ###..#.# #.#.....
                            .byte $f5, $a0 ; ####.#.# #.#.....
                            .byte $a5, $c6 ; #.#..#.# ##...##.
                            .byte $b0, $e0 ; #.##.... ###.....
                            .byte $c4, $a5 ; ##...#.. #.#..#.#
                            
TabDataChar_Colors_Double   = *            ; 
TabDataChar_Height_Triple   = *            ; 
                            .byte $a0, $aa ; #.#..... #.#.#.#.
                            .byte $a0, $a0 ; #.#..... #.#.....
                            .byte $b3, $c2 ; #.##..## ##....#.
                            .byte $a1, $a0 ; #.#....# #.#.....
                            .byte $c9, $b5 ; ##..#..# #.##.#.#
                            .byte $a0, $c3 ; #.#..... ##....##
                            .byte $a0, $84 ; #.#..... #....#..
                            .byte $a0, $85 ; #.#..... #....#.#
TabDataChar_Colors_Triple   = *            ; 
                            .byte $d2, $b7 ; ##.#..#. #.##.###
                            .byte $85, $80 ; #....#.# #.......
                            .byte $a0, $89 ; #.#..... #...#..#
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataDoorExit             = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $05 ; 
TabData_Hdr_Rows            .var  $20 ; 
TabData_Hdr_Attr            .var  $00 ; attributes always $00 if not a sprite
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $00, $28, $00, $00 ; ..................#.#...................
                            .byte $00, $00, $aa, $00, $00 ; ................#.#.#.#.................
                            .byte $00, $00, $aa, $00, $00 ; ................#.#.#.#.................
                            .byte $00, $02, $be, $80, $00 ; ..............#.#.#####.#...............
                            .byte $00, $0a, $ff, $a0, $00 ; ............#.#.#########.#.............
                            .byte $00, $0a, $ff, $a0, $00 ; ............#.#.#########.#.............
                            .byte $00, $2b, $ff, $e8, $00 ; ..........#.#.#############.#...........
                            .byte $00, $af, $ff, $fa, $00 ; ........#.#.#################.#.........
                            .byte $00, $af, $ff, $fa, $00 ; ........#.#.#################.#.........
                            .byte $02, $bf, $ff, $fe, $80 ; ......#.#.#####################.#.......
                            .byte $0a, $ff, $ff, $ff, $a0 ; ....#.#.#########################.#.....
                            .byte $0a, $ff, $ff, $ff, $a0 ; ....#.#.#########################.#.....
                            .byte $2b, $ff, $ff, $ff, $e8 ; ..#.#.#############################.#...
                            .byte $aa, $aa, $aa, $aa, $aa ; #.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.
                            .byte $aa, $aa, $aa, $aa, $aa ; #.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.
                            .byte $aa, $80, $00, $02, $aa ; #.#.#.#.#.....................#.#.#.#.#.
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..
                            .byte $15, $00, $00, $00, $54 ; ...#.#.#.........................#.#.#..

Item_Colors                 .var  *   ; 
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols -(2 * TabData_Hdr_Cols), HR_YELLOW_YELLOW ; $0a object color bytes
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols -(2 * TabData_Hdr_Cols), HR_LT_RED_YELLOW ; $0a object color bytes
                            .fill (((TabData_Hdr_Rows - 1) / 8) + 1) * TabData_Hdr_Cols, HR_BLACK_ORANGE                 ; $14 object color bytes
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerWaveGoodBye_Mi = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $15 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $08 ; ............#...
                            .byte $02, $08 ; ......#.....#...
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $02, $04 ; ......#......#..
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $15, $40 ; ...#.#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $25, $40 ; ..#..#.#.#......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $28, $a0 ; ..#.#...#.#.....
                            .byte $20, $20 ; ..#.......#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerWaveGoodBye_Ri = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $15 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $02 ; ..............#.
                            .byte $02, $02 ; ......#.......#.
                            .byte $0a, $81 ; ....#.#.#......#
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $02, $04 ; ......#......#..
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $15, $40 ; ...#.#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $25, $40 ; ..#..#.#.#......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $28, $a0 ; ..#.#...#.#.....
                            .byte $20, $20 ; ..#.......#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabDataPlayerWaveGoodBye_Le = *       ; 
TabData_Hdr                 .var  *   ; 
TabData_Hdr_Cols            .var  $02 ; 
TabData_Hdr_Rows            .var  $15 ; 
TabData_Hdr_Attr            .var Sprite_Attr_Color_Player ; 
                            
                            .byte TabData_Hdr_Cols ; 
                            .byte TabData_Hdr_Rows ; 
                            .byte TabData_Hdr_Attr ; 
                            
TabData_Item                .var  *   ; 
                            .byte $00, $20 ; ..........#.....
                            .byte $02, $20 ; ......#...#.....
                            .byte $0a, $90 ; ....#.#.#..#....
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $0a, $84 ; ....#.#.#....#..
                            .byte $02, $04 ; ......#......#..
                            .byte $05, $50 ; .....#.#.#.#....
                            .byte $15, $40 ; ...#.#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $45, $40 ; .#...#.#.#......
                            .byte $25, $40 ; ..#..#.#.#......
                            .byte $0f, $c0 ; ....######......
                            .byte $0f, $c0 ; ....######......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $0c, $c0 ; ....##..##......
                            .byte $28, $a0 ; ..#.#...#.#.....
                            .byte $20, $20 ; ..#.......#.....
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameMenuScreenInit        Does    : initialize the game menu screen
;                           Expects : 
;                           Returns : 
;                           Remark  : executed only once - will be overwritten afterwards
; --------------------------------------------------------------------------------------------------------------------- ;
GameMenuScreenInit         .block                           ; 
                            pha                             ; 
                            tya                             ; 
                            pha                             ; 
                            txa                             ; 
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to game menu screen base
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_ScreenMenu             ; 
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            lda #>CC_ScreenMenu             ; get menu screen base address Hi
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; blank out the game menu screen
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$03                        ; init game menu screen page count
                            ldy #$00                        ; init game menu screen page offset
                            lda #" "                        ; 
IniNextOptScrnByte          sta (CCZ_MenuScrnEntryPtr),y    ; 
                            
                            iny                             ; inc game menu screen page offset
                            bne IniNextOptScrnByte          ; check: max - no continue
                            inc CCZ_MenuScrnEntryPtr_Hi     ; inc screen page pointer
                            
                            dex                             ; dec game menu screen page count
                            bpl IniNextOptScrnByte          ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
;       parse the TabTextMenu entries
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st - fill the game menu screen entry control blocks with the header content of the TabTextMenu entries
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get offset of 1st ctrl block
                            sta TabWrkMenuCtrlBlk_Off       ; init game menu screen entry ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to game menu screen text entries
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<TabTextMenu               ; 
                            sta CCZ_TabTextMenuPtr_Lo       ; 
                            lda #>TabTextMenu               ; 
                            sta CCZ_TabTextMenuPtr_Hi       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; copy game menu screen text entry header to screen entry ctrl block
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextMenuTextEntry        ldy #CC_TextMenu_Hdr_Pos_Col    ; set offset game menu screen text entry column
                            lda (CCZ_TabTextMenuPtr),y      ; get menu item column
                            cmp #$ff                        ; test EndOfMenuEntries
                            beq IniMenuStartEntry           ; check: EQ - yes: all entries processed - set the cursor
; --------------------------------------------------------------------------------------------------------------------- ;
; do not process a simple non selectable info text - game menu screen control blocks are set up for cursor selectable entries only
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TextMenu_Hdr_Type       ; set offset game menu screen text entry type flag
                            lda (CCZ_TabTextMenuPtr),y      ; get menu item type
                            cmp #CC_WA_GameMenu_Type_Text   ; test pure info text line
                            beq GetGameMenuEntryColOff      ; check: EQ - yes: not selectable - bypass ctrl block setup
; --------------------------------------------------------------------------------------------------------------------- ;
; init this game menu screen control block from game menu entry header
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #CC_TextMenu_Hdr_Pos_Col    ; get offset game menu screen text entry col
                            ldx TabWrkMenuCtrlBlk_Off       ; get ctrl block offset
CopyNextGameOptsHeaderByte  lda (CCZ_TabTextMenuPtr),y      ; get game menu screen text entry value
                            sta CC_WA_GameMenu,x            ; ini game menu ctrl block
                            
                            inx                             ; inc ctrl block offset
                            iny                             ; inc offset game menu screen text header
                            cpy #CC_TextMenu_Hdr_Len        ; test max length
                            bcc CopyNextGameOptsHeaderByte  ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set new game menu screen entry ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; inc ctrl block offset
                            stx TabWrkMenuCtrlBlk_Off       ; set new ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
GetGameMenuEntryColOff      ldy #CC_TextMenu_Hdr_Pos_Row    ; get offset game menu screen text entry row
                            lda (CCZ_TabTextMenuPtr),y      ; get game menu screen text entry row
                            tax                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set game menu screen base
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda TabTextScreenRowAdr_Lo,x    ; 
                            adc #<CC_ScreenMenu             ; 
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            
                            lda TabTextScreenRowAdr_Hi,x    ; 
                            adc #>CC_ScreenMenu             ; add menu screen base address Hi
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare game menu screen item pointer for menu item text output
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_MenuScrnEntryPtr_Lo     ; 
                            
                            ldy #$00                        ; set offset game menu screen text entry column
                            adc (CCZ_TabTextMenuPtr),y      ; add game menu screen text entry column
                            sta CCZ_MenuScrnEntryPtr_Lo     ; set new game menu screen text entry address
                            bcc IniGameOptsMenuItemTextOff  ; check: overflow - no
                            inc CCZ_MenuScrnEntryPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd - write the text of the TabTextMenu entries to the Game Options and Castle Load File Names screen
; --------------------------------------------------------------------------------------------------------------------- ;
IniGameOptsMenuItemTextOff  ldy #$00                        ; init game opts menu item text offset
; --------------------------------------------------------------------------------------------------------------------- ;
; advance game menu screen item pointer to item text behind item header
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            lda CCZ_TabTextMenuPtr_Lo       ; 
                            adc #CC_TextMenu_Hdr_Len        ; add game menu screen tex header length
                            sta CCZ_TabTextMenuPtr_Lo       ; 
                            bcc GetNextGameOptsItemTextByte ; check: overflow - no
                            inc CCZ_TabTextMenuPtr_Hi       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; copy game menu screen item text to game menu screen
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextGameOptsItemTextByte lda (CCZ_TabTextMenuPtr),y      ; get game menu screen item text byte
                            and #$3f                        ; ..###### - normalize dir filename char to screen code
                            sta (CCZ_MenuScrnEntryPtr),y    ; set game menu screen item text byte
                            
                            lda (CCZ_TabTextMenuPtr),y      ; re-read game menu screen item text byte
                            bmi SetNextMenuTextEntry        ; check: EndOfLine - yes: done
                            
                            iny                             ; inc game opts menu item text offset
                            jmp GetNextGameOptsItemTextByte ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; advance the game opts menu item entries pointer to next text entry
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextMenuTextEntry        clc                             ; 
                            
                            iny                             ; inc game opts menu item text offset
                            tya                             ; 
                            adc CCZ_TabTextMenuPtr_Lo       ; 
                            sta CCZ_TabTextMenuPtr_Lo       ; 
                            bcc GetNextMenuTextEntry        ; check: overflow - no
                            inc CCZ_TabTextMenuPtr_Hi       ; 
                            
                            jmp GetNextMenuTextEntry        ; continue with next game menu screen text item
; --------------------------------------------------------------------------------------------------------------------- ;
; all menu text entries processed - init game opts menu to 3rd item: "UNLIMITED LIVES (ON/OFF)"
; --------------------------------------------------------------------------------------------------------------------- ;
IniMenuStartEntry           ldx CC_WA_GameMenu + CC_WA_GameMenu_Len * $02 + CC_TextMenu_Hdr_Pos_Row ; get offset row of 3rd ctrl block
                            
                            clc                             ; 
                            lda #<CC_ScreenMenu             ; 
                            adc TabTextScreenRowAdr_Lo,x    ; 
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            
                            lda #>CC_ScreenMenu             ; get menu screen base address Hi
                            adc TabTextScreenRowAdr_Hi,x    ; 
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
                            
                            ldy CC_WA_GameMenu + CC_WA_GameMenu_Len * $02 + CC_TextMenu_Hdr_Pos_Col ; get offset col of 3rd ctrl block
                            dey                             ; step 2 columns back
                            dey                             ; 
                            lda #">"                        ; get active menu item marker
                            sta (CCZ_MenuScrnEntryPtr),y    ; set active menu item marker
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen pointer to menu item "UNLIMITED LIVES (ON/OFF)"
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            ldx #$07                        ; get lives menu item row number
                            
                            lda #<CC_ScreenMenu             ; 
                            adc TabTextScreenRowAdr_Lo,x    ; add screen row address LO
                            sta CCZ_MenuScrnEntryPtr_Lo     ; 
                            
                            lda #>CC_ScreenMenu             ; get menu screen base address Hi
                            adc TabTextScreenRowAdr_Hi,x    ; add screen row address HI
                            sta CCZ_MenuScrnEntryPtr_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; reverse the "UNLIMITED LIVES (ON/OFF)" OFF text part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabTextOpts_Lives_Off_Off + CC_WA_GameMenu_Col_Le ; 
ReverseNextOffChar          lda (CCZ_MenuScrnEntryPtr),y    ; 
                            ora #$80                        ; reverse
                            sta (CCZ_MenuScrnEntryPtr),y    ; 
                            
                            iny                             ; 
                            cpy #TabTextOpts_Lives_Off_Off + TabTextOpts_Lives_Off_Len + CC_WA_GameMenu_Col_Le ; test max
                            bcc ReverseNextOffChar          ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; all menu screen text items processed - now continue with the variable directory filename items
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare to read all castle data file names from disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabWrkLoadFile_ID_Dir      ; init disk filename to "$0:Z*" to get a castle data file name list
                            sta TabWrkLoadFile + $00        ; 
                            lda #"0"                        ; 
                            sta TabWrkLoadFile + $01        ; 
                            lda #":"                        ; 
                            sta TabWrkLoadFile + $02        ; 
                            lda #TabWrkLoadFile_ID_Data     ; 
                            sta TabWrkLoadFile + $03        ; 
                            lda #"*"                        ; 
                            sta TabWrkLoadFile + $04        ; 
                            
                            lda #$05                        ; length of masked load file names
                            sta TabWrkLoadFile_Len          ; 
                            
                            lda #TabFlagLoadMem_Load        ; get flag select memory CC_LoadDataBuf  
                            sta TabFlagLoadMem              ; set flag target memory area
                            
                            jsr CastleDataPrepareDiskIO     ; switch KERNAL back on
                            jsr CastleDataFileLoad          ; load directory from disk
                            jsr GameWaitAndWarmStart        ; wait and exec GameWarmStart
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to memory of loaded directory entries
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CC_LoadDataBuf            ; 
                            sta CCZ_DirFileNameBufPtr_Lo    ; 
                            lda #>CC_LoadDataBuf            ; 
                            sta CCZ_DirFileNameBufPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; start with top row of dynamically filled menu screen filenames area
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_GameMenu_Row_Dyn_Top ; get initial value
                            sta TabWrkMenuFile_Row          ; set actual menu screen file row
; --------------------------------------------------------------------------------------------------------------------- ;
; start with left side of menu screen filename area
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_GameMenu_Col_Le      ; 
                            sta TabWrkMenuFile_Col          ; set actual menu screen column area (left/right part)
; --------------------------------------------------------------------------------------------------------------------- ;
; directory structure read: organized as a BASIC pgm
;    2 byte line link ($0101=fhoney link/$0000=end of dir data) 
;    2 byte file block count
;    2 byte " "
;    1 byte starting quote
;   16 byte filename with 1 byte ending quote - filled up with " "
;    2 byte " "
;    3 byte PRG
;    3 byte " "
;    1 byte $00 - EndOfFileNameEntry
; --------------------------------------------------------------------------------------------------------------------- ;
; $9800  01 01 00 00  12     22 44 55 4e 47 45 4f 4e 4d 41 53 54 45 52 20 20 20 22  20  41 58 20 32 41    00  ....."DUNGEONMASTER   " AX 2A.
; 
; $981e  01 01 11 00  20 20  22 5a 54 55 54 4f 52 49 41 4c 22 20 20 20 20 20 20  20 20  50 52 47 20 20 20 00  ..  "ZTUTORIAL"        PRG   .
; $983e  01 01 0f 00  20 20  22 5a 53 59 4c 56 41 4e 49 41 22 20 20 20 20 20 20  20 20  50 52 47 20 20 20 00  ..  "ZSYLVANIA"        PRG   .
; .....  
; $999e  01 01 14 00  20 20  22 5a 42 41 53 4b 45 52 56 49 4c 4c 45 22 20 20 20  20 20  50 52 47 20 20 20 00  ..  "ZBASKERVILLE"     PRG   .
; $99be  01 01 0f 00  20 20  22 5a 4c 4f 56 45 43 52 41 46 54 22 20 20 20 20 20  20 20  50 52 47 20 20 20 00  ..  "ZLOVECRAFT"       PRG   .
; 
; $99de  01 01 23 00 42 4c 4f 43 4b 53 20 46 52 45 45 2e 20 20 20 20 20 20 20  20 20  20 20 20 20 00 00 00    ..BLOCKS FREE.             ...
; $99fe  00 00 
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextDirFileEntry         lda CCZ_DirFileNameBufPtr_Hi    ; 
                            cmp TabWrkLoadFileDataEnd_Hi    ; test end of directory data HI
                            bcc ChkEndOfDirData             ; check: LT - yes: check end of dir data
                            bne SetLastOptsCtrlBlk          ; check: NE - yes: higher - done
; --------------------------------------------------------------------------------------------------------------------- ;
; end of directory data HI reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CCZ_DirFileNameBufPtr_Lo    ; get end of directory data LO
                            cmp TabWrkLoadFileDataEnd_Lo    ; test end of directory data LO
                            bcs SetLastOptsCtrlBlk          ; check: GE - yes: done
                            
ChkEndOfDirData             ldy #$00                        ; 
                            lda (CCZ_DirFileNameBufPtr),y   ; get line link LO
                            iny                             ; 
                            ora (CCZ_DirFileNameBufPtr),y   ; insert line link HI
                            bne BypassDirEntryHeader        ; check: 0000=EndOfDirData - no: continue processing filenames
                            
SetLastOptsCtrlBlk          jmp GameMenuScreenInit_Exit     ; done - last dir entry processed
; --------------------------------------------------------------------------------------------------------------------- ;
; process an eventual castle data filename
; --------------------------------------------------------------------------------------------------------------------- ;
BypassDirEntryHeader        clc                             ; 
                            lda CCZ_DirFileNameBufPtr_Lo    ; 
                            adc #$04                        ; add length of dir entry header (line link and block count)
                            sta CCZ_DirFileNameBufPtr_Lo    ; 
                            bcc GetNextDirEntryNameByte     ; check: overflow - no
                            inc CCZ_DirFileNameBufPtr_Hi    ; 
                            
GetNextDirEntryNameByte     ldy #$00                        ; set dir entry name offset
                            lda (CCZ_DirFileNameBufPtr),y   ; 
                            bne ChkChar_Quote               ; check: 00=EndOfLine - no: test quotation mark
; --------------------------------------------------------------------------------------------------------------------- ;
; overread EndOfLine
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc CCZ_DirFileNameBufPtr_Lo    ; 
                            bne GetNextDirFileEntry         ; check: overflow - no
                            inc CCZ_DirFileNameBufPtr_Hi    ; 
                            jmp GetNextDirFileEntry         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; search for filename start quote
; --------------------------------------------------------------------------------------------------------------------- ;
ChkChar_Quote               cmp #""""                       ; test filename start quote
                            bne SetNextDirFileNameChar      ; check: NE - yes: not found - continue search
; --------------------------------------------------------------------------------------------------------------------- ;
; filename quote found - test castle data file ID - overread the diskname on the way
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; set offset filename ID
                            lda (CCZ_DirFileNameBufPtr),y   ; 
                            cmp #TabWrkLoadFile_ID_Data     ; test with castle data file ID
                            beq IniScrnOptsFileCtrlBlk      ; check: EQ - yes: set up the screen opts file ctrl block
; --------------------------------------------------------------------------------------------------------------------- ;
; advance directory filename pointer - continue search for correct entry
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextDirFileNameChar      inc CCZ_DirFileNameBufPtr_Lo    ; 
                            bne GetNextDirEntryNameByte     ; check: overflow - no: continue
                            inc CCZ_DirFileNameBufPtr_Hi    ; 
                            jmp GetNextDirEntryNameByte     ; continue search for quote and "z"
; --------------------------------------------------------------------------------------------------------------------- ;
; fill the menu ctrl block with data for this castle data file found
; --------------------------------------------------------------------------------------------------------------------- ;
IniScrnOptsFileCtrlBlk      ldx TabWrkMenuCtrlBlk_Off       ; get actual ctrl block offset
                            lda TabWrkMenuFile_Col          ; get actual menu screen column area (left/right part)
                            sta CC_WA_GameMenu_Col,x        ; set col in actual ctrl block offset
                            
                            lda TabWrkMenuFile_Row          ; get actual menu screen file area start
                            sta CC_WA_GameMenu_Row,x        ; set row in actual ctrl block offset
                            
                            lda #CC_WA_GameMenu_Type_File   ; get menu screen entry type FILE
                            sta CC_WA_GameMenu_Type,x       ; set entry type in actual ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
; copy dir file name to next free menu screen file name entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkMenuFile_Row          ; get actual menu screen cursor row
                            
                            clc                             ; 
                            lda TabTextScreenRowAdr_Lo,x    ; 
                            adc #<CC_ScreenMenu             ; add menu screen base address Lo
                            sta CCZ_MenuScrnFileNamePtr_Lo  ; 
                            
                            lda TabTextScreenRowAdr_Hi,x    ; 
                            adc #>CC_ScreenMenu             ; add menu screen base address Hi
                            sta CCZ_MenuScrnFileNamePtr_Hi  ; 
                            
                            ldx TabWrkMenuFile_Col          ; get actual menu screen cursor column (left/right part)
                            
                            dex                             ; discount dir filename offset
                            dex                             ; 
                            
                            clc                             ; 
                            txa                             ; 
                            adc CCZ_MenuScrnFileNamePtr_Lo  ; 
                            sta CCZ_MenuScrnFileNamePtr_Lo  ; 
                            bcc IniDirFileNameOff           ; check: overflow - no: process directory filename
                            inc CCZ_MenuScrnFileNamePtr_Hi  ; 
                            
IniDirFileNameOff           ldy #$02                        ; get dir filename offset
GetNextDirFileNameChar      lda (CCZ_DirFileNameBufPtr),y   ; get a dir file name char
                            cmp #""""                       ; test filename final quote
                            beq SetCtrlBlkFileNameLen       ; check: EQ - yes: EndOfFileName
                            
                            and #$3f                        ; ..###### - normalize dir filename char to screen code
                            sta (CCZ_MenuScrnFileNamePtr),y ; set menu screen file name char
                            
                            iny                             ; inc dir filename offset
                            jmp GetNextDirFileNameChar      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set file name length in menu screen item control block
; --------------------------------------------------------------------------------------------------------------------- ;
SetCtrlBlkFileNameLen       ldx TabWrkMenuCtrlBlk_Off       ; get actual ctrl block offset
                            
                            tya                             ; get end of dir filename offset
                            sta CC_WA_GameMenu_File_Len,x   ; set as menu screen item name length
                            
                            dec CC_WA_GameMenu_File_Len,x   ; discount ending apostrophe
; --------------------------------------------------------------------------------------------------------------------- ;
; advance actual ctrl block offset to next free ctrl block entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; add ctrl block length of $04
                            inx                             ; 
                            inx                             ; 
                            inx                             ; 
                            stx TabWrkMenuCtrlBlk_Off       ; actual ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
; advance directory filename pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            tya                             ; get end of dir filename offset
                            adc CCZ_DirFileNameBufPtr_Lo    ; 
                            sta CCZ_DirFileNameBufPtr_Lo    ; 
                            bcc ChkActualScreenOptColArea   ; check: overflow - no: set screen opt col area
                            inc CCZ_DirFileNameBufPtr_Hi    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; net next menu screen file output area
; --------------------------------------------------------------------------------------------------------------------- ;
ChkActualScreenOptColArea   lda TabWrkMenuFile_Col          ; get actual menu screen column area (left/right part)
                            cmp #CC_WA_GameMenu_Col_Le      ; test column left menu screen area
                            bne SetScreenOptColArea_Le      ; check: left side - no: set right side to left
; --------------------------------------------------------------------------------------------------------------------- ;
; set menu screen ctrl area right on same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #CC_WA_GameMenu_Col_Ri      ; get column right menu screen area 
                            sta TabWrkMenuFile_Col          ; set actual menu screen column area (left/right part)
                            
GoSetNextDirFileNameChar    jmp SetNextDirFileNameChar      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set menu screen ctrl area left on next row
; --------------------------------------------------------------------------------------------------------------------- ;
SetScreenOptColArea_Le      lda #CC_WA_GameMenu_Col_Le      ; get column left menu screen area
                            sta TabWrkMenuFile_Col          ; set actual menu screen column area (left/right part)
                            
                            inc TabWrkMenuFile_Row          ; inc actual menu screen file area start to next row
                            
                            lda TabWrkMenuFile_Row          ; get actual menu screen file area start
                            cmp #CC_WA_GameMenu_Row_Dyn_Bot ; test bottom row
                            bcc GoSetNextDirFileNameChar    ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; dynamic level file data area filled up to maximum
; --------------------------------------------------------------------------------------------------------------------- ;
GameMenuScreenInit_Exit     ldx TabWrkMenuCtrlBlk_Off       ; get selected ctrl block offset
                            dex                             ; discount length of control block
                            dex                             ; 
                            dex                             ; 
                            dex                             ; 
                            stx TabWrkMenuCtrlBlk_Off_Max   ; set maximum available ctrl block offset
                            
                            lda #CC_WA_GameMenu_Len * $02   ; get offset menu item "UNLIMITED LIVES (ON/OFF)"
                            sta TabWrkMenuCtrlBlk_Off       ; selected ctrl block offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            tax                             ; 
                            pla                             ; 
                            tay                             ; 
                            pla                             ; 
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkMenuFile_Col          .byte $a0 ; actual menu screen file column (left/right hand area)
TabWrkMenuFile_Row          .byte $a0 ; actual menu screen file row
; --------------------------------------------------------------------------------------------------------------------- ;
; game menu screen text entries
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextMenu                 = * ; 
TabTextMenu_Hdr1            = * ; 
                            .byte $05 ; Start Col Number
                            .byte $03 ; Start Row Number
                            .byte CC_WA_GameMenu_Type_Text     ; Flag: Info Text
                           
                            .byte "u" ; Text: use joystick 1 to move pointer
                            .byte "s" ; 
                            .byte "e" ; 
                            .byte " " ; 
                            .byte "j" ; 
                            .byte "o" ; 
                            .byte "y" ; 
                            .byte "s" ; 
                            .byte "t" ; 
                            .byte "i" ; 
                            .byte "c" ; 
                            .byte "k" ; 
                            .byte " " ; 
                            .byte "1" ; 
                            .byte " " ; 
                            .byte "t" ; 
                            .byte "o" ; 
                            .byte " " ; 
                            .byte "m" ; 
                            .byte "o" ; 
                            .byte "v" ; 
                            .byte "e" ; 
                            .byte " " ; 
                            .byte "p" ; 
                            .byte "o" ; 
                            .byte "i" ; 
                            .byte "n" ; 
                            .byte "t" ; 
                            .byte "e" ; 
                            .byte "r" | $80 ; EndOfLine = Bit 7 set
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextMenu_Hdr2            = * ; 
                            .byte $05 ; Start Col Number
                            .byte $04 ; Start Row Number
                            .byte CC_WA_GameMenu_Type_Text ; Flag: Info Text
                            
                            .byte "p" ; Text: press trigger button to select
                            .byte "r" ; 
                            .byte "e" ; 
                            .byte "s" ; 
                            .byte "s" ; 
                            .byte " " ; 
                            .byte "t" ; 
                            .byte "r" ; 
                            .byte "i" ; 
                            .byte "g" ; 
                            .byte "g" ; 
                            .byte "e" ; 
                            .byte "r" ; 
                            .byte " " ; 
                            .byte "b" ; 
                            .byte "u" ; 
                            .byte "t" ; 
                            .byte "t" ; 
                            .byte "o" ; 
                            .byte "n" ; 
                            .byte " " ; 
                            .byte "t" ; 
                            .byte "o" ; 
                            .byte " " ; 
                            .byte "s" ; 
                            .byte "e" ; 
                            .byte "l" ; 
                            .byte "e" ; 
                            .byte "c" ; 
                            .byte "t" | $80 ; EndOfLine = Bit 7 set
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextOpts_Resume          = * ; 
                            .byte $03 ; Start Col Number
                            .byte $06 ; Start Row Number
                            .byte CC_WA_GameMenu_Type_Resume ; 
                            
                            .byte "r" ; Text: resume gamee
                            .byte "e" ; 
                            .byte "s" ; 
                            .byte "u" ; 
                            .byte "m" ; 
                            .byte "e" ; 
                            .byte " " ; 
                            .byte "g" ; 
                            .byte "a" ; 
                            .byte "m" ; 
                            .byte "e" | $80 ; EndOfLine = Bit 7 set
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextOpts_Times           = * ; 
                            .byte $16 ; Start Col Number
                            .byte $06 ; Start Row Number
                            .byte CC_WA_GameMenu_Type_Times ; 
                            
                            .byte "v" ; Text: view best times
                            .byte "i" ; 
                            .byte "e" ; 
                            .byte "w" ; 
                            .byte " " ; 
                            .byte "b" ; 
                            .byte "e" ; 
                            .byte "s" ; 
                            .byte "t" ; 
                            .byte " " ; 
                            .byte "t" ; 
                            .byte "i" ; 
                            .byte "m" ; 
                            .byte "e" ; 
                            .byte "s" | $80 ; EndOfLine = Bit 7 set
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextOpts_Lives           = * ; 
                            .byte $03 ; Start Col Number
                            .byte $07 ; Start Row Number
                            .byte CC_WA_GameMenu_Type_Lives ; 
                            
TabTextOpts_Lives_Text      = * ; 
                            .byte "u" ; Text: unlimited lives (on/off)
                            .byte "n" ; 
                            .byte "l" ; 
                            .byte "i" ; 
                            .byte "m" ; 
                            .byte "i" ; 
                            .byte "t" ; 
                            .byte "e" ; 
                            .byte "d" ; 
                            .byte " " ; 
                            .byte "l" ; 
                            .byte "i" ; 
                            .byte "v" ; 
                            .byte "e" ; 
                            .byte "s" ; 
                            .byte " " ; 
                            .byte "(" ; 
TabTextOpts_Lives_On        = *       ; 
TabTextOpts_Lives_On_Off    = * - TabTextOpts_Lives_Text ; offset ON
                            .byte "o" ; 
                            .byte "n" ; 
TabTextOpts_Lives_On_Len    = * - TabTextOpts_Lives_On   ; length ON
                            .byte "/" ; 
TabTextOpts_Lives_Off       = * ; 
TabTextOpts_Lives_Off_Off   = * - TabTextOpts_Lives_Text ; offset OFF
                            .byte "o" ; 
                            .byte "f" ; 
                            .byte "f" ; 
TabTextOpts_Lives_Off_Len   = * - TabTextOpts_Lives_Off  ; length OFF
TabTextOpts_Lives_OnOff_Len = * - TabTextOpts_Lives_On   ; length ON/OFF
                            .byte ")" | $80 ; EndOfLine = Bit 7 set
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextOpts_Exit            = * ; 
                            .byte $03 ; Start Col Number
                            .byte $08 ; Start Row Number
                            .byte CC_WA_GameMenu_Type_Exit ; 
                            
                            .byte "e" ; Text: exit menu
                            .byte "x" ; 
                            .byte "i" ; 
                            .byte "t" ; 
                            .byte " " ; 
                            .byte "m" ; 
                            .byte "e" ; 
                            .byte "n" ; 
                            .byte "u" | $80 ; EndOfLine = Bit 7 set
; --------------------------------------------------------------------------------------------------------------------- ;
TabTextOpts_LoadGame        = * ; 
                            .byte $03 ; Start Col Number
                            .byte $0a ; Start Row Number
                            .byte CC_WA_GameMenu_Type_Text ; Flag: Info Text
                            
                            .byte "l" ; Text: load game:
                            .byte "o" ; 
                            .byte "a" ; 
                            .byte "d" ; 
                            .byte " " ; 
                            .byte "g" ; 
                            .byte "a" ; 
                            .byte "m" ; 
                            .byte "e" ; 
                            .byte ":" | $80 ; EndOfLine = Bit 7 set
                            
                            .byte $ff ; EndOfTextEntries
; --------------------------------------------------------------------------------------------------------------------- ;
; game sound effect data will be copied to GameMenuScreenInit to free its memory area for CC_GameDataBuf
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameSfxData              = * ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; map of the game sound effects data area replacing the obsolete menu screen init routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            .logical GameMenuScreenInit ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameSfxAdr               = * ;                                            
TabGameSfxAdr_GunShot       .word TabSFX_GunShot       ; ray gun shot
TabGameSfxAdr_TrapSwitch    .word TabSFX_TrapSwitch    ; trapdoor switch
TabGameSfxAdr_ForcePing     .word TabSFX_ForcePing     ; force field close pings
TabGameSfxAdr_OpenDoor      .word TabSFX_OpenDoor      ; open doors
TabGameSfxAdr_XmitXmit      .word TabSFX_XmitXmit      ; matter transmitter: transmit
TabGameSfxAdr_XmitSelect    .word TabSFX_XmitSelect    ; matter transmitter: select receiver orb
TabGameSfxAdr_LightSwitch   .word TabSFX_LightSwitch   ; lightning machine switch
TabGameSfxAdr_FrankOut      .word TabSFX_FrankOut      ; frankenstein exits coffin
TabGameSfxAdr_Death         .word TabSFX_Death         ; player/mummy/frankenstein death
TabGameSfxAdr_MapPing       .word TabSFX_MapPing       ; map enter room ping
TabGameSfxAdr_WalkSwitch    .word TabSFX_WalkSwitch    ; moving sidewalk switch
TabGameSfxAdr_MummyOut      .word TabSFX_MummyOut      ; mummy exits wall
TabGameSfxAdr_KeyPick       .word TabSFX_KeyPick       ; key pick up ping
; --------------------------------------------------------------------------------------------------------------------- ;
NumSfx_GunShot              = (TabGameSfxAdr_GunShot     - TabGameSfxAdr) / 2
NumSfx_TrapSwitch           = (TabGameSfxAdr_TrapSwitch  - TabGameSfxAdr) / 2
NumSfx_ForceFieldPing       = (TabGameSfxAdr_ForcePing   - TabGameSfxAdr) / 2
NumSfx_OpenDoor             = (TabGameSfxAdr_OpenDoor    - TabGameSfxAdr) / 2
NumSfx_XmitXmit             = (TabGameSfxAdr_XmitXmit    - TabGameSfxAdr) / 2
NumSfx_XmitSelect           = (TabGameSfxAdr_XmitSelect  - TabGameSfxAdr) / 2
NumSfx_LightSwitch          = (TabGameSfxAdr_LightSwitch - TabGameSfxAdr) / 2
NumSfx_FrankOut             = (TabGameSfxAdr_FrankOut    - TabGameSfxAdr) / 2
NumSfx_Death                = (TabGameSfxAdr_Death       - TabGameSfxAdr) / 2
NumSfx_MapPing              = (TabGameSfxAdr_MapPing     - TabGameSfxAdr) / 2
NumSfx_WalkSwitch           = (TabGameSfxAdr_WalkSwitch  - TabGameSfxAdr) / 2
NumSfx_MummyOut             = (TabGameSfxAdr_MummyOut    - TabGameSfxAdr) / 2
NumSfx_KeyPick              = (TabGameSfxAdr_KeyPick     - TabGameSfxAdr) / 2
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_GunShot              = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $80 ; 
                            .byte $0a ; 
                            .byte $0a ; 
                            .byte $00 ; 
TabSFX_GunShot_Tone         .byte $b1 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_TrapSwitch           = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $20 ; 
                            .byte $0a ; 
                            .byte $0a ; 
                            .byte $00 ; 
TabSFX_TrapSwitch_Tone      .byte $89 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_ForcePing            = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $10 ; 
                            .byte $0a ; 
                            .byte $0a ; 
                            .byte $00 ; 
TabSFX_ForcePing_Tone       .byte $85 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_OpenDoor             = * ; 
                            .byte $12 ; 
                            .byte $80 ; 
                            .byte $00 ; 
                            .byte $40 ; 
                            .byte $0a ; 
                            .byte $0a ; 
                            .byte $02 ; 
TabSFX_OpenDoor_Tone        .byte $a5 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $06 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_XmitXmit             = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $14 ; 
                            .byte $0c ; 
                            .byte $0c ; 
                            .byte $11 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $14 ; 
                            .byte $0c ; 
                            .byte $0c ; 
                            .byte $12 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $14 ; 
                            .byte $0c ; 
                            .byte $0c ; 
                            .byte $00 ; 
TabSFX_XmitXmit_Tone        .byte $a0 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_XmitSelect           = * ; 
                            .byte $11 ; 
                            .byte $80 ; 
                            .byte $01 ; 
                            .byte $40 ; 
                            .byte $80 ; 
                            .byte $00 ; 
                            .byte $01 ; 
TabSFX_XmitSelect_Tone      .byte $b0 ; 
                            .byte $08 ; 
                            .byte $12 ; 
                            .byte $05 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_LightSwitch          = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $80 ; 
                            .byte $08 ; 
                            .byte $08 ; 
                            .byte $00 ; 
TabSFX_LightSwitch_Tone     .byte $a0 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_FrankOut             = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $80 ; 
                            .byte $0c ; 
                            .byte $0c ; 
                            .byte $11 ; 
                            .byte $40 ; 
                            .byte $00 ; 
                            .byte $40 ; 
                            .byte $0c ; 
                            .byte $0c ; 
                            .byte $18 ; 
                            .byte $00 ; 
                            .byte $19 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $01 ; 
                            .byte $0c ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $05 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_Death                = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $10 ; 
                            .byte $06 ; 
                            .byte $06 ; 
                            .byte $00 ; 
TabSFX_Death_Tone           .byte $96 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_MapPing              = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $10 ; 
                            .byte $0b ; 
                            .byte $0b ; 
                            .byte $00 ; 
                            .byte $2b ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_WalkSwitch           = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $80 ; 
                            .byte $09 ; 
                            .byte $09 ; 
                            .byte $00 ; 
TabSFX_WalkSwitch_Tone      .byte $a0 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_MummyOut             = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $80 ; 
                            .byte $09 ; 
                            .byte $09 ; 
                            .byte $00 ; 
TabSFX_MummyOut_Tone        .byte $80 ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSFX_KeyPick              = * ; 
                            .byte $10 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $10 ; 
                            .byte $09 ; 
                            .byte $09 ; 
                            .byte $00 ; 
                            .byte $3f ; 
                            .byte $08 ; 
                            .byte $02 ; 
                            .byte $04 ; 
                            .byte $24 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            .endlogical
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $6d ; 
; --------------------------------------------------------------------------------------------------------------------- ;
